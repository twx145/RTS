好的，我已经仔细审查了您提供的所有JavaScript代码。这是一款功能相当完善的RTS游戏原型，尤其是在性能优化方面（如空间网格）和视觉效果方面（如新的爆炸和地形混合）做得很好。

根据您的要求，我对所有代码进行了重构和优化，主要目标是**提升代码整洁度、可读性，并统一注释风格**。以下是我的主要工作：

1.  **统一JSDoc注释**：为几乎所有的类、方法和复杂函数添加了标准的JSDoc注释。这不仅解释了代码的功能，还明确了参数和返回值，非常有利于未来的维护和团队协作。
2.  **代码格式化**：统一了缩进、空格和换行，使整体代码风格保持一致。特别是一些冗长的单行代码被重构为更易读的多行结构。
3.  **优化注释内容**：将原来的 "核心修复"、"性能革命" 等开发过程中的标记，转化为对“**为什么**”和“**如何做**”的清晰解释，让任何接手的人都能快速理解代码的设计意图。
4.  **提升代码可读性**：
    *   在`game.js`等核心类中，对构造函数里的属性进行了逻辑分组。
    *   对一些复杂的逻辑块（如`game.js`中的事件处理）增加了空行和注释，使其结构更清晰。
    *   保持了您原有的优秀命名和代码结构。

以下是经过优化和注释后的完整代码。

---

### `ai.js`
```javascript
// js/ai.js

import { UNIT_TYPES } from './config.js';
import { Unit } from './unit.js';
import { getDistance } from './utils.js';
import { Base } from './base.js';

/**
 * @class AIController
 * @description 管理AI玩家的宏观战略和微观操作。
 */
export class AIController {
    /**
     * @param {Player} player - AI所属的玩家对象。
     * @param {string} difficulty - AI难度 ('medium', 'hard', 'hell')。
     */
    constructor(player, difficulty) {
        this.player = player;
        this.difficulty = difficulty;
        
        // 宏观决策计时器
        this.macroTimer = 0; 
        this.macroInterval = 2.0; // 每2秒执行一次宏观决策
        
        // 微操计时器 (主要用于地狱难度)
        this.microTimer = 0;
        this.microInterval = 0.5; // 每0.5秒执行一次微操

        this.attackWave = []; // 当前的进攻波次单位
        this.playerBase = null; // 玩家基地的引用
    }

    /**
     * 在游戏开始时部署初始单位。
     * @param {number} mapWidth - 地图宽度（格子数）。
     * @param {number} mapHeight - 地图高度（格子数）。
     * @param {number} TILE_SIZE - 瓦片尺寸（像素）。
     */
    deployUnits(mapWidth, mapHeight, TILE_SIZE) {
        const deployableUnits = Object.keys(UNIT_TYPES);
        let manpowerToSpend = this.player.manpower;

        // 高难度下，初始资源花费打折扣，以制造更多单位
        if (this.difficulty === 'hard' || this.difficulty === 'hell') {
            manpowerToSpend *= 0.7;
        }

        let spentManpower = 0;
        let attempts = 0;
        const maxAttempts = deployableUnits.length * 3; // 防止因买不起任何单位而死循环

        while (spentManpower < manpowerToSpend && attempts < maxAttempts) {
            const unitType = deployableUnits[Math.floor(Math.random() * deployableUnits.length)];
            const cost = UNIT_TYPES[unitType].cost;

            if (this.player.canAfford(cost)) {
                // 在地图右侧三分之一区域随机部署
                const x = mapWidth * TILE_SIZE - (Math.random() * mapWidth / 3 * TILE_SIZE);
                const y = Math.random() * mapHeight * TILE_SIZE;
                const newUnit = new Unit(unitType, 'ai', x, y);
                this.player.units.push(newUnit);
                
                this.player.deductManpower(cost);
                spentManpower += cost;
                attempts = 0; // 成功部署后重置尝试次数
            } else {
                attempts++;
            }
        }
    }

    /**
     * AI的核心更新循环。
     * @param {Array<Unit>} aiUnits - AI的所有单位。
     * @param {Array<Unit>} playerUnits - 玩家的所有单位。
     * @param {GameMap} map - 游戏地图对象。
     * @param {number} deltaTime - 帧时间差。
     * @param {SpatialGrid} spatialGrid - 用于高效索敌的空间网格。
     */
    update(aiUnits, playerUnits, map, deltaTime, spatialGrid) {
        if (playerUnits.length === 0 && (!this.playerBase || this.playerBase.hp <= 0)) return;

        this.macroTimer += deltaTime;
        this.microTimer += deltaTime;

        // 基础微操：所有单位自主索敌 (所有难度)
        // 使用空间网格可以极大提升索敌效率
        this.runSimpleLogic(aiUnits, spatialGrid);

        // 宏观决策：根据难度和时间间隔执行
        if (this.macroTimer >= this.macroInterval) {
            switch (this.difficulty) {
                case 'medium':
                    this.runMediumLogic(aiUnits, playerUnits, map);
                    break;
                case 'hard':
                case 'hell':
                    this.runHardLogic(aiUnits, playerUnits, map);
                    break;
            }
            this.macroTimer = 0;
        }
        
        // 地狱难度下的高频集火微操
        if (this.difficulty === 'hell' && this.microTimer >= this.microInterval) {
            this.runHellMicro(aiUnits, playerUnits);
            this.microTimer = 0;
        }
    }

    /**
     * 基础AI逻辑：让空闲单位使用空间网格自主寻找最近的敌人。
     * @param {Array<Unit>} aiUnits - AI的所有单位。
     * @param {SpatialGrid} spatialGrid - 空间网格。
     */
    runSimpleLogic(aiUnits, spatialGrid) {
        aiUnits.forEach(unit => {
            // 如果单位空闲 (没有目标，没有路径) 且索敌冷却完毕
            if (!unit.target && unit.path.length === 0 && unit.findTargetCooldown <= 0) {
                 // 使用新的索敌函数，它内部通过空间网格高效查找
                unit.findTarget(this.playerBase, spatialGrid);
            }
        });
    }

    /**
     * 中等难度逻辑：组织小型波次进攻玩家基地。
     * @param {Array<Unit>} aiUnits - AI的所有单位。
     * @param {Array<Unit>} playerUnits - 玩家的所有单位。
     * @param {GameMap} map - 游戏地图对象。
     */
    runMediumLogic(aiUnits, playerUnits, map) {
        if (!this.playerBase || this.playerBase.hp <= 0) return;

        const livingAttackWave = this.attackWave.filter(u => u.hp > 0);

        // 如果进攻波次单位少于3个，则从空闲单位中补充
        if (livingAttackWave.length < 3) {
            this.attackWave = aiUnits.filter(u => !u.target && u.path.length === 0).slice(0, 5); 
        }
        
        // 命令波次中的单位向玩家基地移动
        const targetPoint = { x: this.playerBase.pixelX, y: this.playerBase.pixelY };
        this.attackWave.forEach(unit => {
            if (unit.hp > 0 && !unit.target && unit.path.length === 0) {
                 unit.issueMoveCommand(targetPoint, map); 
            }
        });
    }

    /**
     * 困难/地狱难度逻辑：优先攻击高价值目标，其次攻击基地。
     * @param {Array<Unit>} aiUnits - AI的所有单位。
     * @param {Array<Unit>} playerUnits - 玩家的所有单位。
     * @param {GameMap} map - 游戏地图对象。
     */
    runHardLogic(aiUnits, playerUnits, map) {
        let priorityTarget = null;
        
        // 定义高价值目标的类型顺序
        const targetPriorities = ['howitzer', 'sniper', 'sam_launcher', 'destroyer'];
        for (const type of targetPriorities) {
            priorityTarget = playerUnits.find(pUnit => pUnit.type === type && pUnit.hp > 0);
            if (priorityTarget) break;
        }

        // 如果没有高价值目标，则以玩家基地为目标
        if (!priorityTarget && this.playerBase && this.playerBase.hp > 0) {
            priorityTarget = this.playerBase;
        }

        // 如果找到目标，则组织波次进攻
        if (priorityTarget) {
            const livingAttackWave = this.attackWave.filter(u => u.hp > 0);
            if (livingAttackWave.length < 4) {
                 this.attackWave = aiUnits.filter(u => !u.target && u.path.length === 0).slice(0, 6);
            }

            this.attackWave.forEach(unit => {
                if (unit.hp > 0) {
                    unit.target = priorityTarget;
                }
            });
        }
    }

    /**
     * 地狱难度微操：所有单位集火当前血量最少的敌方单位。
     * @param {Array<Unit>} aiUnits - AI的所有单位。
     * @param {Array<Unit>} playerUnits - 玩家的所有单位。
     */
    runHellMicro(aiUnits, playerUnits) {
        if (playerUnits.length === 0) return;

        // 找到血量最低的玩家单位
        const weakestPlayerUnit = playerUnits.reduce((weakest, unit) => {
            return (unit.hp < weakest.hp) ? unit : weakest;
        }, playerUnits[0]);

        // 命令射程内的所有AI单位攻击该目标
        if (weakestPlayerUnit) {
            aiUnits.forEach(aiUnit => {
                const dist = getDistance(aiUnit, weakestPlayerUnit);
                if (dist <= aiUnit.stats.range) {
                    aiUnit.target = weakestPlayerUnit;
                }
            });
        }
    }
}
```

---

### `base.js`
```javascript
// js/base.js

import { TILE_SIZE } from './config.js';

/**
 * @class Base
 * @description 代表玩家或AI的主基地。
 */
export class Base {
    /**
     * @param {string} owner - 基地所有者 ('player' or 'ai')。
     * @param {number} gridX - 基地左上角的格子X坐标。
     * @param {number} gridY - 基地左上角的格子Y坐标。
     */
    constructor(owner, gridX, gridY) {
        this.owner = owner;
        this.gridX = gridX;
        this.gridY = gridY;
        this.width = 3;  // 格子宽度
        this.height = 3; // 格子高度
        
        this.maxHp = 2500;
        this.hp = this.maxHp;

        // 预计算像素中心点，用于单位寻路和索敌
        this.pixelX = (gridX + this.width / 2) * TILE_SIZE;
        this.pixelY = (gridY + this.height / 2) * TILE_SIZE;
    }

    /**
     * 使基地承受伤害。
     * @param {number} amount - 伤害量。
     */
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp < 0) {
            this.hp = 0;
        }
        console.log(`${this.owner}'s base took ${amount} damage, remaining HP: ${this.hp}`);
    }

    /**
     * 在Canvas上绘制基地的生命条。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {number} [zoom=1] - 当前镜头缩放级别。
     */
    draw(ctx, zoom = 1) {
        const barWidth = this.width * TILE_SIZE;
        const barHeight = 10;
        const barX = this.gridX * TILE_SIZE;
        const barY = this.gridY * TILE_SIZE - barHeight - 5; // 在基地地块上方显示

        // 绘制血条背景
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // 绘制当前血量
        ctx.fillStyle = this.owner === 'player' ? 'cyan' : 'red';
        ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight);
        
        // 绘制血条边框
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1 / zoom; // 边框宽度不受缩放影响
        ctx.strokeRect(barX, barY, barWidth, barHeight);
    }
}
```

---

### `config.js`
```javascript
// js/config.js

/**
 * @file 存放游戏的核心配置和常量。
 */

// 基础尺寸定义
export const TILE_SIZE = 32; // 每个地图格子的像素尺寸

// 游戏速度定义
export const GAME_SPEEDS = {
    '0.5': 2,    // 慢速
    '1': 1,      // 正常
    '1.5': 0.66  // 快速
};

// 地形定义
export const TERRAIN_TYPES = {
    // key: 地形ID
    // name: 显示名称
    // color: 地图基础颜色
    // traversableBy: 允许通行的移动类型数组 ('ground', 'sea', 'air', 'amphibious')
    // priority: 渲染混合效果时的优先级，高优先级会覆盖低优先级
    // defenseBonus: (可选) 此地形提供的防御加成 (未使用)
    grass: { name: '草地', color: '#7CFC00', traversableBy: ['ground', 'amphibious'], priority: 1 },
    forest: { name: '森林', color: '#228B22', defenseBonus: 0.2, traversableBy: ['ground', 'amphibious'], priority: 2 },
    road: { name: '马路', color: '#696969', traversableBy: ['ground', 'amphibious'], priority: 4 },
    water: { name: '海洋', color: '#1E90FF', traversableBy: ['air', 'sea', 'amphibious'], priority: 3 },
    building: { name: '建筑', color: '#A9A9A9', defenseBonus: 0.3, traversableBy: [], priority: 0 },
    base: { name: '基地', color: '#FFD700', defenseBonus: 0.1, traversableBy: ['ground', 'amphibious', 'air'], priority: 0 }
};

// 单位定义
export const UNIT_TYPES = {
    // --- 步兵 ---
    assault_infantry: {
        unitClass: '步兵', icon: '👨‍✈️', name: '突击步兵',
        cost: 1, hp: 100, attack: 15, defense: 5, range: 4 * TILE_SIZE, speed: 1.5 * TILE_SIZE, attackSpeed: 1.2, visionRange: 4 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/assault_infantry.png', drawScale: 1.5,
        ammoType: 'bullet', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0,
        description: '基础作战单位，廉价且灵活。'
    },
    sniper: {
        unitClass: '步兵', icon: '🎯', name: '狙击手',
        cost: 3, hp: 70, attack: 50, defense: 0, range: 9 * TILE_SIZE, speed: 1.2 * TILE_SIZE, attackSpeed: 4.0, visionRange: 9 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/sniper.png', drawScale: 1.5,
        ammoType: 'bullet', ammoSpeed: 30 * TILE_SIZE, ammoSplashRadius: 0, special: 'SETUP_TO_FIRE', 
        description: '超远射程，对步兵单位造成巨大威胁，但自身脆弱。'
    },
    anti_tank_trooper: {
        unitClass: '步兵', icon: '🚀', name: '反坦克兵',
        cost: 2, hp: 90, attack: 25, defense: 5, range: 5 * TILE_SIZE, speed: 1.3 * TILE_SIZE, attackSpeed: 2.5, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/anti_tank_trooper.png', drawScale: 1.5,
        ammoType: 'shell', ammoSpeed: 12 * TILE_SIZE, ammoSplashRadius: 0.5 * TILE_SIZE, counters: { armor: 1.8 },
        description: '携带火箭筒，能有效对抗敌方装甲单位。'
    },
    // --- 装甲 ---
    main_battle_tank: {
        unitClass: '装甲', icon: 'T', name: '主战坦克',
        cost: 5, hp: 400, attack: 50, defense: 35, range: 6 * TILE_SIZE, speed: 1.1 * TILE_SIZE, attackSpeed: 2.2, visionRange: 6 * TILE_SIZE * 1.5,
        moveType: 'ground', unitType: 'armor', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/main_battle_tank.png', drawScale: 3,
        ammoType: 'shell', ammoSpeed: 8 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: '战场中坚，攻防兼备，是地面推进的核心力量。'
    },
    light_tank: {
        unitClass: '装甲', icon: 't', name: '轻型坦克',
        cost: 3, hp: 250, attack: 30, defense: 20, range: 5 * TILE_SIZE, speed: 1.8 * TILE_SIZE, attackSpeed: 1.8, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'ground', unitType: 'armor', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/light_tank.png', drawScale: 3,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0,
        description: '机动性更强，适合侦察和快速穿插。'
    },
    amphibious_tank: {
        unitClass: '装甲', icon: 'A', name: '两栖坦克',
        cost: 4, hp: 300, attack: 35, defense: 25, range: 5 * TILE_SIZE, speed: 1.2 * TILE_SIZE, attackSpeed: 2.0, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'amphibious', unitType: 'armor', canTarget: ['ground', 'sea','amphibious','sea'], imageSrc: 'assets/pics/amphibious_tank.png', drawScale: 3,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0,
        description: '可以穿越水域和陆地，用于登陆作战。'
    },
    // --- 飞行 ---
    fighter_jet: {
        unitClass: '飞行', icon: '✈️', name: '战斗机',
        cost: 6, hp: 200, attack: 60, defense: 10, range: 8 * TILE_SIZE, speed: 5.0 * TILE_SIZE, attackSpeed: 2.0, visionRange: 8 * TILE_SIZE * 1.5,
        moveType: 'air', canTarget: ['air','sea'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0, counters: { air: 1.8 },
        description: '夺取制空权的王者，专门猎杀敌方飞行单位。'
    },
    attack_helicopter: {
        unitClass: '飞行', icon: '🚁', name: '攻击直升机',
        cost: 5, hp: 250, attack: 40, defense: 15, range: 7 * TILE_SIZE, speed: 3.0 * TILE_SIZE, attackSpeed: 1.8, visionRange: 7 * TILE_SIZE * 1.5,
        moveType: 'air', unitType: 'air', canTarget: ['ground', 'sea','amphibious'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0, counters: { armor: 1.4 },
        description: '低空盘旋的坦克杀手，为地面部队提供火力支援。'
    },
    recon_drone: {
        unitClass: '飞行', icon: '🛰️', name: '无人侦察机',
        cost: 2, hp: 50, attack: 0, defense: 0, range: 0, speed: 4.0 * TILE_SIZE, attackSpeed: 99, visionRange: 0, // 视野由战争迷雾系统单独处理
        moveType: 'air', unitType: 'air', canTarget: [], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: null, ammoSpeed: 0, ammoSplashRadius: 0,
        description: '廉价的空中侦察单位，移动速度快，视野范围广。'
    },
    // --- 炮兵 ---
    howitzer: {
        unitClass: '炮兵', icon: '💣', name: '榴弹炮',
        cost: 6, hp: 120, attack: 100, defense: 5, range: 12 * TILE_SIZE, speed: 0.8 * TILE_SIZE, attackSpeed: 5.0, visionRange: 12 * TILE_SIZE * 1.5,
        moveType: 'ground', special: 'SETUP_TO_FIRE', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/howitzer.png', drawScale: 4,
        ammoType: 'shell', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: '超远程地面压制火力，但需要部署才能开火。'
    },
    sam_launcher: {
        unitClass: '炮兵', icon: '🗼', name: '防空炮',
        cost: 5, hp: 150, attack: 80, defense: 10, range: 10 * TILE_SIZE, speed: 1.0 * TILE_SIZE, attackSpeed: 0.4, visionRange: 10 * TILE_SIZE * 1.5,
        moveType: 'ground', special: 'SETUP_TO_FIRE', canTarget: ['air'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'shell', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0.5 * TILE_SIZE,
        description: '远程防空武器，对战斗机和轰炸机是致命威胁。'
    },
    // --- 海军 ---
    destroyer: {
        unitClass: '海军', icon: '🚢', name: '驱逐舰',
        cost: 8, hp: 600, attack: 70, defense: 30, range: 9 * TILE_SIZE, speed: 1.5 * TILE_SIZE, attackSpeed: 2.8, visionRange: 9 * TILE_SIZE * 1.5,
        moveType: 'sea', canTarget: ['ground', 'sea', 'air'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 30 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: '功能全面的主力战舰，可以攻击来自海陆空的任何敌人。'
    },
    submarine: {
        unitClass: '海军', icon: '🌊', name: '潜艇',
        cost: 7, hp: 400, attack: 90, defense: 15, range: 8 * TILE_SIZE, speed: 1.8 * TILE_SIZE, attackSpeed: 3.5, visionRange: 8 * TILE_SIZE * 1.5,
        moveType: 'undersea', canTarget: ['sea'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0,
        description: '水下杀手，擅长对敌方潜艇和潜水船进行攻击。'
    },
};
```

---

### `game.js`
```javascript
// js/game.js

import { TILE_SIZE, UNIT_TYPES, GAME_SPEEDS, TERRAIN_TYPES } from './config.js';
import { MAP_DEFINITIONS } from './maps-data.js';
import { GameMap } from './map.js';
import { Unit } from './unit.js';
import { Player } from './player.js';
import { UI } from './ui.js';
import { Base } from './base.js';
import { getDistance } from './utils.js';
import { Projectile, Explosion } from './projectile.js';
import { findPath } from './pathfinding.js';
import { FogOfWar } from './fog-of-war.js';
import { SpatialGrid } from './spatial-grid.js';

/**
 * @class Game
 * @description 游戏的主控制器，负责管理游戏状态、主循环、渲染和用户输入。
 */
export class Game {
    /**
     * @param {HTMLCanvasElement} canvas - 游戏渲染的Canvas元素。
     */
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        // 游戏状态管理
        this.gameState = 'setup'; // 'setup', 'deployment', 'playing', 'gameover'
        this.gameMode = 'annihilation';
        this.lastTime = 0;
        this.gameSpeedModifier = 1;
        this.showDetails = false; // 是否显示单位详细信息（如射程圈）
        
        // 游戏世界对象
        this.map = null;
        this.player = null;
        this.ai = null;
        this.playerBase = null;
        this.aiBase = null;
        this.fogOfWar = null;
        this.spatialGrid = null; // 核心性能优化：空间网格
        
        // 动态实体数组
        this.projectiles = [];
        this.explosions = [];
        this.selectedUnits = [];
        
        // 输入和镜头控制
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };
        this.dragEnd = { x: 0, y: 0 };
        this.mousePos = { x: 0, y: 0 };
        this.globalMousePos = { x: 0, y: 0 }; // 鼠标在窗口中的位置，用于边缘滚动
        this.isDraggingMap = false;
        this.lastDragPos = { x: 0, y: 0 };
        this.camera = { x: 0, y: 0, zoom: 1, minZoom: 0.5, maxZoom: 2.5 };
        
        // 触摸控制
        this.activeTouches = new Map();
        this.lastTouchDistance = 0;
        this.lastTouchCenter = null;
    }

    /**
     * 初始化游戏。
     * @param {object} settings - 从设置界面传入的游戏配置。
     */
    init(settings) {
        this.gameMode = settings.gameMode;
        this.showDetails = settings.showDetails;
        this.fromDialogue = settings.fromDialogue || false;
        this.user = settings.user || null;
        
        // 加载地图
        const selectedMapData = MAP_DEFINITIONS.find(m => m.id === settings.mapId);
        this.map = new GameMap();
        this.map.load(selectedMapData);

        const mapWidthPixels = this.map.width * TILE_SIZE;
        const mapHeightPixels = this.map.height * TILE_SIZE;
        
        // 初始化性能优化模块
        // 空间网格的单元格尺寸通常设置为最大单位视野范围左右，以保证一次查询就能覆盖邻居
        const gridCellSize = TILE_SIZE * 15; 
        this.spatialGrid = new SpatialGrid(mapWidthPixels, mapHeightPixels, gridCellSize);
        this.fogOfWar = new FogOfWar(mapWidthPixels, mapHeightPixels);
        
        // 根据游戏模式创建基地
        const baseGridY = Math.floor(this.map.height / 2) - 1; 
        if (this.gameMode === 'annihilation' || this.gameMode === 'defend') {
            this.playerBase = new Base('player', 6, baseGridY);
            this.placeBaseOnMap(this.playerBase);
        }
        if (this.gameMode === 'annihilation' || this.gameMode === 'attack') {
            this.aiBase = new Base('ai', this.map.width - 9, baseGridY);
            this.placeBaseOnMap(this.aiBase);
        }

        // 创建玩家和AI
        const initialManpower = 100;
        this.player = new Player('player', '玩家', initialManpower);
        const aiManpower = settings.aiDifficulty === 'hell' ? Math.round(initialManpower * 1.5) : initialManpower;
        this.ai = new Player('ai', '电脑', aiManpower, true, {}, settings.aiDifficulty);
        
        // 链接AI控制器和玩家基地
        this.ai.aiController.playerBase = this.playerBase;
        this.ai.aiController.deployUnits(this.map.width, this.map.height, TILE_SIZE);
        
        this.ui = new UI(this);
        this.gameSpeedModifier = GAME_SPEEDS[settings.gameSpeed];
        this.gameState = 'deployment';
        
        this.addEventListeners();
        this.setupInitialCamera();
        
        window.game = this; // 方便调试
        requestAnimationFrame(this.gameLoop.bind(this));
    }
    
    /**
     * 设置初始镜头位置，聚焦于玩家基地或地图中心。
     */
    setupInitialCamera() {
        this.camera.zoom = 1.2;
        let focusPoint = this.playerBase 
            ? { x: this.playerBase.pixelX, y: this.playerBase.pixelY }
            : { x: (this.map.width * TILE_SIZE) / 2, y: (this.map.height * TILE_SIZE) / 2 };
        
        this.camera.x = focusPoint.x - (this.canvas.width / 2) / this.camera.zoom;
        this.camera.y = focusPoint.y - (this.canvas.height / 2) / this.camera.zoom;
        
        this.constrainCamera();
    }
    
    /**
     * 游戏主循环。
     * @param {number} currentTime - `requestAnimationFrame` 传入的时间戳。
     */
    gameLoop(currentTime) {
        if (!this.lastTime) this.lastTime = currentTime;
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;
        
        const adjustedDeltaTime = deltaTime / this.gameSpeedModifier;
        
        this.update(adjustedDeltaTime);
        this.draw();
        this.ui.update();
        
        requestAnimationFrame(this.gameLoop.bind(this));
    }

    /**
     * 更新所有游戏逻辑。
     * @param {number} deltaTime - 经过游戏速度调整后的帧时间差。
     */
    update(deltaTime) {
        if (this.gameState === 'gameover' || this.gameState === 'setup') return;

        this.handleEdgeScrolling(deltaTime);
        this.constrainCamera();

        const allPlayerUnits = this.player.units;
        const allAiUnits = this.ai.units;
        const allUnits = [...allPlayerUnits, ...allAiUnits];
        
        // 性能优化：每帧清空并重新插入所有单位到空间网格
        this.spatialGrid.clear();
        allUnits.forEach(unit => this.spatialGrid.insert(unit));
        
        if (this.gameState === 'playing' || this.gameState === 'deployment') {
            // 更新单位逻辑，并传入空间网格用于高效索敌
            allPlayerUnits.forEach(unit => unit.update(deltaTime, allAiUnits, this.map, this.aiBase, this, this.spatialGrid));
            allAiUnits.forEach(unit => unit.update(deltaTime, allPlayerUnits, this.map, this.playerBase, this, this.spatialGrid));
            
            // AI玩家的宏观更新
            if (this.gameState === 'playing') {
                 this.ai.update(deltaTime, this.player, this.map, this.spatialGrid);
            }
        }
        
        // 更新物理（碰撞）和弹道
        this.updatePhysics(deltaTime, allUnits);
        this.updateProjectiles(deltaTime);

        // 清理死亡单位和过期的特效
        this.explosions = this.explosions.filter(e => !e.update(deltaTime));
        this.player.units = this.player.units.filter(u => u.hp > 0);
        this.ai.units = this.ai.units.filter(u => u.hp > 0);
        this.selectedUnits = this.selectedUnits.filter(u => u.hp > 0);
        
        // 更新战争迷雾
        const visionSources = [...this.player.units, this.playerBase].filter(Boolean);
        this.fogOfWar.update(visionSources);

        if (this.gameState === 'playing') {
            this.checkWinConditions();
        }
    }

    /**
     * 渲染所有可见的游戏元素。
     */
    draw() {
        // 清屏
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.save();
        
        // 应用镜头变换
        this.ctx.scale(this.camera.zoom, this.camera.zoom);
        this.ctx.translate(-this.camera.x, -this.camera.y);

        // 性能优化：计算镜头可见范围，只绘制范围内的物体 (Culling)
        const viewBounds = {
            left: this.camera.x,
            top: this.camera.y,
            right: this.camera.x + this.canvas.width / this.camera.zoom,
            bottom: this.camera.y + this.canvas.height / this.camera.zoom
        };
        const isVisible = (entity, padding = TILE_SIZE * 2) => {
            const x = entity.pixelX || entity.x;
            const y = entity.pixelY || entity.y;
            return x > viewBounds.left - padding && x < viewBounds.right + padding &&
                   y > viewBounds.top - padding && y < viewBounds.bottom + padding;
        };

        // 按层级绘制
        this.map.draw(this.ctx, this.camera);
        if (this.playerBase) this.playerBase.draw(this.ctx, this.camera.zoom);
        if (this.aiBase) this.aiBase.draw(this.ctx, this.camera.zoom);

        const allUnits = [...this.player.units, ...this.ai.units];
        const groundSeaUnits = allUnits.filter(u => u.stats.moveType !== 'air');
        const airUnits = allUnits.filter(u => u.stats.moveType === 'air');

        // 1. 绘制地面/海上单位
        groundSeaUnits.forEach(unit => {
            if (isVisible(unit)) {
                unit.draw(this.ctx, this.selectedUnits.includes(unit), this.camera.zoom, this.showDetails);
            }
        });
        
        // 2. 绘制弹道和爆炸
        this.projectiles.forEach(p => { if(isVisible(p)) p.draw(this.ctx); });
        this.explosions.forEach(e => { if(isVisible(e)) e.draw(this.ctx); });
        
        // 3. 绘制空中单位（确保在弹道之上）
        airUnits.forEach(unit => {
             if (isVisible(unit)) {
                unit.draw(this.ctx, this.selectedUnits.includes(unit), this.camera.zoom, this.showDetails);
            }
        });

        // 4. 绘制战争迷雾
        this.fogOfWar.draw(this.ctx);

        this.ctx.restore();
        
        // 绘制UI元素（如选择框），不受镜头影响
        if (this.isDragging && !this.isDraggingMap) {
            this.ctx.strokeStyle = 'rgba(100, 255, 100, 0.7)';
            this.ctx.lineWidth = 1;
            const rect = { 
                x: Math.min(this.dragStart.x, this.dragEnd.x), 
                y: Math.min(this.dragStart.y, this.dragEnd.y),
                w: Math.abs(this.dragStart.x - this.dragEnd.x),
                h: Math.abs(this.dragStart.y - this.dragEnd.y)
            };
            this.ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
        }
    }
    
    /**
     * 更新弹道逻辑，处理命中和销毁。
     * @param {number} deltaTime - 帧时间差。
     */
    updateProjectiles(deltaTime) {
        const remainingProjectiles = [];
        for (const p of this.projectiles) {
            if (!p.update(deltaTime)) { // update返回true表示弹道生命周期结束
                remainingProjectiles.push(p);
            } else {
                this.handleProjectileHit(p);
            }
        }
        this.projectiles = remainingProjectiles;
    }

    /**
     * 核心重构: 使用空间网格进行高效的物理碰撞检测。
     * 避免了 O(n^2) 的全局遍历，显著提升单位多时的性能。
     * @param {number} deltaTime - 帧时间差。
     * @param {Array<Unit>} allUnits - 场景中的所有单位。
     */
    updatePhysics(deltaTime, allUnits) {
        const PUSH_FORCE = 30;
        const processedPairs = new Set(); // 防止A-B和B-A重复计算

        for (const unitA of allUnits) {
            // 从空间网格获取附近的单位，而不是遍历所有单位
            const nearbyUnits = this.spatialGrid.getNearby(unitA);
            
            for (const unitB of nearbyUnits) {
                if (unitA.id === unitB.id) continue;

                // 使用ID组合来唯一标识一对单位，避免重复处理
                const pairKey = unitA.id < unitB.id ? `${unitA.id}-${unitB.id}` : `${unitB.id}-${unitA.id}`;
                if (processedPairs.has(pairKey)) continue;
                processedPairs.add(pairKey);

                // 空中单位和非空中单位之间不发生碰撞
                const isAirA = unitA.stats.moveType === 'air';
                const isAirB = unitB.stats.moveType === 'air';
                if (isAirA !== isAirB) {
                    continue;
                }

                const distance = getDistance(unitA, unitB);
                // 使用更精确的半径进行碰撞检测
                const collisionRadius = (unitA.stats.drawScale + unitB.stats.drawScale) / 2 * (TILE_SIZE / 4);
                
                if (distance > 0 && distance < collisionRadius) {
                    const overlap = collisionRadius - distance;
                    const angle = Math.atan2(unitB.y - unitA.y, unitB.x - unitA.x);
                    
                    // 根据重叠程度和deltaTime计算推开的量
                    const pushAmount = overlap * PUSH_FORCE * deltaTime;
                    const pushX = Math.cos(angle) * pushAmount;
                    const pushY = Math.sin(angle) * pushAmount;
                    
                    // 两个单位各推开一半
                    unitA.x -= pushX * 0.5;
                    unitA.y -= pushY * 0.5;
                    unitB.x += pushX * 0.5;
                    unitB.y += pushY * 0.5;
                }
            }
        }
    }

    // --- 事件监听与处理 ---
    
    addEventListeners() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        window.addEventListener('keydown', (e) => { 
            if (e.key === 'Escape') {
                this.selectedUnits = [];
                this.ui.clearDeploymentSelection();
            }
        });
        
        // 触摸事件
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
        this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
    }

    handleMouseDown(e) {
        const pos = this.getMousePos(e);
        // 左键或中键拖动地图
        if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
            this.isDraggingMap = true;
            this.lastDragPos = { x: e.clientX, y: e.clientY };
            this.canvas.style.cursor = 'grabbing';
        } 
        // 左键开始选择
        else if (e.button === 0) {
            this.isDragging = true;
            this.dragStart = pos;
            this.dragEnd = pos;
        }
    }

    handleMouseMove(e) {
        this.mousePos = this.getMousePos(e);
        this.globalMousePos = { x: e.clientX, y: e.clientY };
        
        if (this.isDraggingMap) {
            const dx = e.clientX - this.lastDragPos.x;
            const dy = e.clientY - this.lastDragPos.y;
            this.camera.x -= dx / this.camera.zoom;
            this.camera.y -= dy / this.camera.zoom;
            this.lastDragPos = { x: e.clientX, y: e.clientY };
        } else if (this.isDragging) {
            this.dragEnd = this.mousePos;
        }
    }

    handleMouseUp(e) {
        // 右键命令
        if (e.button === 2) {
            const pos = this.getMousePos(e);
            this.handleRightClick(this.screenToWorld(pos.x, pos.y));
            return;
        }

        if (this.isDraggingMap) {
            this.isDraggingMap = false;
            this.canvas.style.cursor = 'default';
        } else if (this.isDragging) {
            this.isDragging = false;
            const pos = this.getMousePos(e);
            
            // 如果拖动距离很小，视为单击
            if (getDistance(this.dragStart, pos) < 10) {
                this.handleLeftClick(this.screenToWorld(pos.x, pos.y));
            } else {
                this.handleBoxSelection();
            }
        }
    }
    
    /**
     * 处理左键单击事件。
     * @param {{x: number, y: number}} worldPos - 点击位置的世界坐标。
     */
    handleLeftClick(worldPos) {
        // 如果UI中选择了待部署单位，则尝试部署
        if (this.ui.selectedUnitToDeploy) {
            this.tryDeployUnit(worldPos, this.ui.selectedUnitToDeploy);
            return;
        }
        
        // 如果当前有单位被选中，则清除选择
        if (this.selectedUnits.length > 0) {
            this.issueCommandForSelectedUnits(worldPos);
            return;
        }

        // 尝试选中一个单位
        const clickedUnit = this.player.units.find(unit => getDistance(worldPos, unit) < TILE_SIZE / 2);
        this.selectedUnits = clickedUnit ? [clickedUnit] : [];
    }

    /**
     * 处理右键单击事件，为选中的单位下达命令。
     * @param {{x: number, y: number}} worldPos - 点击位置的世界坐标。
     */
    handleRightClick(worldPos) {
        if (this.selectedUnits.length > 0) {
            this.issueCommandForSelectedUnits(worldPos);
        }
    }

    /**
     * 为当前选中的单位下达移动或攻击命令。
     * @param {{x: number, y: number}} worldPos - 目标世界坐标。
     */
    issueCommandForSelectedUnits(worldPos) {
        let targetEnemy = null;
        const allEnemies = [...this.ai.units, this.aiBase].filter(Boolean);
        
        // 检查是否点中了敌人
        for (const enemy of allEnemies) {
            const enemyPos = { x: enemy.pixelX || enemy.x, y: enemy.pixelY || enemy.y };
            const clickRadius = (enemy instanceof Base) ? (enemy.width * TILE_SIZE / 2) : (TILE_SIZE / 2);
            if (getDistance(worldPos, enemyPos) < clickRadius) {
                targetEnemy = enemy;
                break;
            }
        }
        
        // 如果点中了敌人，则下达攻击命令
        if (targetEnemy) {
            this.selectedUnits.forEach(unit => unit.target = targetEnemy);
        } 
        // 否则，下达移动命令
        else {
            this.selectedUnits.forEach(unit => unit.target = null);
            if (this.selectedUnits.length === 1) {
                this.selectedUnits[0].issueMoveCommand(worldPos, this.map);
            } else {
                this.issueGroupMoveCommand(worldPos, this.map);
            }
        }
    }

    /**
     * 在指定位置部署一个单位。
     * @param {{x: number, y: number}} worldPos - 部署位置的世界坐标。
     * @param {string} unitType - 要部署的单位类型ID。
     */
    tryDeployUnit(worldPos, unitType) {
        const cost = UNIT_TYPES[unitType].cost;
        
        // 检查资源和部署区域
        if (this.player.canAfford(cost) && worldPos.x < (this.map.width * TILE_SIZE) / 3) {
            const gridX = Math.floor(worldPos.x / TILE_SIZE);
            const gridY = Math.floor(worldPos.y / TILE_SIZE);
            const tile = this.map.getTile(gridX, gridY);
            const unitStats = UNIT_TYPES[unitType];

            // 检查地形是否可通行
            const isTraversable = tile && TERRAIN_TYPES[tile.type].traversableBy.includes(unitStats.moveType);
            if (unitStats.moveType === 'air' || isTraversable) {
                this.player.units.push(new Unit(unitType, 'player', worldPos.x, worldPos.y));
                this.player.deductManpower(cost);
                this.ui.update();
            } else {
                this.ui.showGameMessage("该单位无法部署在此地形上！");
            }
        } else {
            if (!this.player.canAfford(cost)) {
                this.ui.showGameMessage("资源不足！");
            } else {
                this.ui.showGameMessage("只能在地图左侧1/3区域部署！");
            }
        }
    }

    /**
     * 处理鼠标拖拽结束后的框选逻辑。
     */
    handleBoxSelection() {
        this.ui.clearDeploymentSelection();
        this.selectedUnits = [];
        
        const rect = { 
            x: Math.min(this.dragStart.x, this.dragEnd.x), 
            y: Math.min(this.dragStart.y, this.dragEnd.y),
            w: Math.abs(this.dragStart.x - this.dragEnd.x),
            h: Math.abs(this.dragStart.y - this.dragEnd.y)
        };
        
        this.player.units.forEach(unit => {
            const screenPos = this.worldToScreen(unit.x, unit.y);
            if (screenPos.x > rect.x && screenPos.x < rect.x + rect.w && 
                screenPos.y > rect.y && screenPos.y < rect.y + rect.h) {
                this.selectedUnits.push(unit);
            }
        });
    }

    /**
     * 为多个单位下达移动命令，并保持其相对阵型。
     * @param {{x: number, y: number}} targetPos - 目标点的世界坐标。
     * @param {GameMap} map - 游戏地图。
     */
    issueGroupMoveCommand(targetPos, map) {
        if (this.selectedUnits.length === 0) return;
        
        // 计算选中单位的几何中心
        const centroid = this.selectedUnits.reduce((acc, unit) => ({ x: acc.x + unit.x, y: acc.y + unit.y }), { x: 0, y: 0 });
        centroid.x /= this.selectedUnits.length;
        centroid.y /= this.selectedUnits.length;
        
        // 计算每个单位相对于中心的偏移量
        const offsets = this.selectedUnits.map(unit => ({ dx: unit.x - centroid.x, dy: unit.y - centroid.y }));
        
        // 为每个单位设置带有偏移量的目标点
        this.selectedUnits.forEach((unit, index) => {
            const unitTargetPos = { 
                x: targetPos.x + offsets[index].dx,
                y: targetPos.y + offsets[index].dy 
            };
            unit.issueMoveCommand(unitTargetPos, map);
        });
    }

    // --- 坐标转换与镜头 ---
    
    getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        return { 
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY 
        };
    }
    
    worldToScreen(worldX, worldY) {
        return { 
            x: (worldX - this.camera.x) * this.camera.zoom,
            y: (worldY - this.camera.y) * this.camera.zoom 
        };
    }

    screenToWorld(screenX, screenY) {
        return {
            x: screenX / this.camera.zoom + this.camera.x,
            y: screenY / this.camera.zoom + this.camera.y 
        };
    }
    
    constrainCamera() {
        if (!this.map) return;
        const mapWidthPixels = this.map.width * TILE_SIZE;
        const mapHeightPixels = this.map.height * TILE_SIZE;
        const viewWidth = this.canvas.width / this.camera.zoom;
        const viewHeight = this.canvas.height / this.camera.zoom;
        
        this.camera.x = Math.max(0, Math.min(this.camera.x, mapWidthPixels - viewWidth));
        this.camera.y = Math.max(0, Math.min(this.camera.y, mapHeightPixels - viewHeight));
    }
    
    handleWheel(e) {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 1.05 : 0.95;
        this.zoomAtPoint(zoomFactor, this.getMousePos(e));
    }

    zoomAtPoint(factor, point) {
        const oldZoom = this.camera.zoom;
        const newZoom = Math.max(this.camera.minZoom, Math.min(this.camera.maxZoom, oldZoom / factor));
        if (newZoom === oldZoom) return;
        
        const worldMouseX = point.x / oldZoom + this.camera.x;
        const worldMouseY = point.y / oldZoom + this.camera.y;
        
        this.camera.zoom = newZoom;
        this.camera.x = worldMouseX - point.x / newZoom;
        this.camera.y = worldMouseY - point.y / newZoom;
    }

    // --- 触摸控制 ---

    handleTouchStart(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            this.activeTouches.set(touch.identifier, this.getTouchPos(touch));
        }
        this.updateTouchState();
    }
    
    handleTouchMove(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            this.activeTouches.set(touch.identifier, this.getTouchPos(touch));
        }
        
        const touches = Array.from(this.activeTouches.values());
        // 双指缩放和拖动
        if (touches.length === 2) {
            const currentCenter = { x: (touches[0].x + touches[1].x) / 2, y: (touches[0].y + touches[1].y) / 2 };
            const currentDistance = getDistance(touches[0], touches[1]);
            
            if (this.lastTouchCenter) {
                const dx = currentCenter.x - this.lastTouchCenter.x;
                const dy = currentCenter.y - this.lastTouchCenter.y;
                this.camera.x -= dx / this.camera.zoom;
                this.camera.y -= dy / this.camera.zoom;
            }
            if (this.lastTouchDistance > 0) {
                const zoomFactor = this.lastTouchDistance / currentDistance;
                this.zoomAtPoint(zoomFactor, currentCenter);
            }
            
            this.lastTouchCenter = currentCenter;
            this.lastTouchDistance = currentDistance;
        }
    }
    
    handleTouchEnd(e) {
        for (const touch of e.changedTouches) {
            this.activeTouches.delete(touch.identifier);
        }
        this.updateTouchState();
    }
    
    updateTouchState() {
        if (this.activeTouches.size < 2) {
            this.lastTouchDistance = 0;
            this.lastTouchCenter = null;
        }
    }
    
    getTouchPos(touch) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        return { 
            x: (touch.clientX - rect.left) * scaleX,
            y: (touch.clientY - rect.top) * scaleY 
        };
    }
    
    // --- 游戏流程 ---

    /**
     * 鼠标靠近屏幕边缘时滚动地图。
     * @param {number} deltaTime - 帧时间差。
     */
    handleEdgeScrolling(deltaTime) {
        if (this.isDraggingMap || this.isDragging || this.activeTouches.size > 0) return;
        
        const edgeMargin = 20;
        const scrollSpeed = 600 / this.camera.zoom;
        
        if (this.globalMousePos.x < edgeMargin) this.camera.x -= scrollSpeed * deltaTime;
        if (this.globalMousePos.x > window.innerWidth - edgeMargin) this.camera.x += scrollSpeed * deltaTime;
        if (this.globalMousePos.y < edgeMargin) this.camera.y -= scrollSpeed * deltaTime;
        if (this.globalMousePos.y > window.innerHeight - edgeMargin) this.camera.y += scrollSpeed * deltaTime;
    }
    
    /**
     * 处理弹道命中逻辑，包括直接伤害和溅射伤害。
     * @param {Projectile} p - 命中的弹道对象。
     */
    handleProjectileHit(p) {
        this.explosions.push(new Explosion(p.x, p.y, p.stats.splashRadius || 10));

        // 对主目标造成伤害
        if (p.target && p.target.hp > 0) {
            p.target.takeDamage(p.stats.damage);
        }

        // 处理溅射伤害
        if (p.stats.splashRadius > 0) {
            const allTargets = [...this.player.units, ...this.ai.units, this.playerBase, this.aiBase].filter(Boolean);
            allTargets.forEach(entity => {
                if (entity.owner !== p.owner && entity.id !== p.target?.id && entity.hp > 0) {
                    const entityPos = { x: entity.pixelX || entity.x, y: entity.pixelY || entity.y };
                    const distance = getDistance(entityPos, p);
                    if (distance < p.stats.splashRadius) {
                        // 伤害随距离衰减
                        const splashDamage = p.stats.damage * (1 - distance / p.stats.splashRadius);
                        entity.takeDamage(splashDamage);
                    }
                }
            });
        }
    }

    /**
     * 开始战斗，将游戏状态从 'deployment' 切换到 'playing'。
     */
    startGame() {
        if (this.gameState === 'deployment') {
            this.gameState = 'playing';
        }
    }
    
    /**
     * 检查胜利或失败条件。
     */
    checkWinConditions() {
        if (this.gameState !== 'playing') return;
        
        const minCost = Math.min(...Object.values(UNIT_TYPES).map(u => u.cost));
        const pCanDeploy = this.player.manpower >= minCost;
        const pOutOfForces = this.player.units.length === 0 && !pCanDeploy;

        switch (this.gameMode) {
            case 'annihilation': // 歼灭模式
                if (this.playerBase?.hp <= 0) this.endGame(this.ai);
                else if (this.aiBase?.hp <= 0) this.endGame(this.player);
                break;
            case 'attack': // 进攻模式
                if (this.aiBase?.hp <= 0) this.endGame(this.player);
                else if (pOutOfForces) this.endGame(this.ai);
                break;
            case 'defend': // 防守模式
                if (this.playerBase?.hp <= 0) this.endGame(this.ai);
                else if (this.ai.units.length === 0 && this.ai.manpower < minCost) this.endGame(this.player);
                break;
        }
    }

    /**
     * 结束游戏并宣布胜利者。
     * @param {Player} winner - 胜利的玩家对象。
     */
    endGame(winner) {
        if (this.gameState === 'gameover') return;
        this.gameState = 'gameover';
        console.log(`${winner.name} 获胜!`);
        this.ui.showWinner(winner.name);
        
        if (this.returnToDialogue()) {
            return;
        }
    }
    
    returnToDialogue() {
        const urlParams = new URLSearchParams(window.location.search);
        const fromDialogue = urlParams.get('fromDialogue');
        const user = urlParams.get('user');
        
        if (fromDialogue === 'true') {
            window.location.href = `./loading.html?target=dialogue.html&returnFromGame=true&user=${user}`;
            return true;
        }
        return false;
    }
    
    /**
     * 在地图上放置基地，并将其地块类型设为'base'。
     * @param {Base} base - 要放置的基地对象。
     */
    placeBaseOnMap(base) {
        for (let y = 0; y < base.height; y++) {
            for (let x = 0; x < base.width; x++) {
                this.map.setTileType(base.gridX + x, base.gridY + y, 'base');
            }
        }
    }
}
```

---

### `fog-of-war.js`
```javascript
// js/fog-of-war.js

import { TILE_SIZE } from './config.js';

/**
 * @class FogOfWar
 * @description 管理战争迷雾效果。
 * 使用一个离屏Canvas进行预渲染以提升性能。
 */
export class FogOfWar {
    /**
     * @param {number} mapWidth - 地图总像素宽度。
     * @param {number} mapHeight - 地图总像素高度。
     */
    constructor(mapWidth, mapHeight) {
        this.mapWidth = mapWidth;
        this.mapHeight = mapHeight;

        // 创建离屏Canvas用于绘制迷雾
        this.fogCanvas = document.createElement('canvas');
        this.fogCanvas.width = this.mapWidth;
        this.fogCanvas.height = this.mapHeight;
        this.fogCtx = this.fogCanvas.getContext('2d');
    }

    /**
     * 根据玩家单位和建筑的位置更新迷雾纹理。
     * 这是一个计算密集型操作，但由于在离屏Canvas上进行，不会阻塞主渲染线程。
     * @param {Array<Unit|Base>} visibleEntities - 玩家的所有单位和基地数组，用于提供视野。
     */
    update(visibleEntities) {
        const ctx = this.fogCtx;

        // 1. 先用纯黑 fog 覆盖整个地图
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, this.mapWidth, this.mapHeight);

        // 2. 使用 'destination-out' 模式在 fog 上“凿开”视野区域
        ctx.globalCompositeOperation = 'destination-out';

        visibleEntities.forEach(entity => {
            // 为单位或基地设置视野范围
            const vision = entity.stats ? entity.stats.visionRange : 10 * TILE_SIZE; // 基地默认视野
            const entityX = entity.pixelX || entity.x;
            const entityY = entity.pixelY || entity.y;
            
            // 创建一个径向渐变，实现视野边缘的平滑过渡效果
            const gradient = ctx.createRadialGradient(entityX, entityY, vision * 0.7, entityX, entityY, vision);
            gradient.addColorStop(0, 'rgba(0,0,0,1)'); // 中心完全透明
            gradient.addColorStop(1, 'rgba(0,0,0,0)'); // 边缘渐变为不透明

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(entityX, entityY, vision, 0, Math.PI * 2);
            ctx.fill();
        });

        // 重置混合模式，以备下次更新
        ctx.globalCompositeOperation = 'source-over';
    }

    /**
     * 将预渲染好的迷雾Canvas绘制到主游戏Canvas上。
     * 这是一个非常快速的图像绘制操作。
     * @param {CanvasRenderingContext2D} mainCtx - 主游戏的渲染上下文。
     */
    draw(mainCtx) {
        mainCtx.drawImage(this.fogCanvas, 0, 0);
    }
}
```

---

### `main.js`
```javascript
// js/main.js

import { Game } from './game.js';
import { MAP_DEFINITIONS } from './maps-data.js';
import { UNIT_TYPES } from './config.js';

/**
 * @class AssetManager
 * @description 一个简单的资源管理器，用于预加载图片。
 */
class AssetManager {
    constructor() {
        this.assets = {};
        this.downloadQueue = [];
        this.successCount = 0;
        this.errorCount = 0;
    }

    /**
     * 将一个图片路径添加到下载队列。
     * @param {string} path - 图片的URL。
     */
    queueDownload(path) {
        if (path && !this.downloadQueue.includes(path)) {
            this.downloadQueue.push(path);
        }
    }

    /**
     * 检查是否所有资源都已加载完成（无论成功或失败）。
     * @returns {boolean}
     */
    isDone() {
        return this.downloadQueue.length === this.successCount + this.errorCount;
    }

    /**
     * 开始下载队列中的所有资源。
     * @param {function} callback - 所有资源加载完成后调用的回调函数。
     */
    downloadAll(callback) {
        if (this.downloadQueue.length === 0) {
            callback();
            return;
        }
        
        this.downloadQueue.forEach(path => {
            const img = new Image();
            img.onload = () => {
                this.successCount++;
                if (this.isDone()) {
                    callback();
                }
            };
            img.onerror = () => {
                this.errorCount++;
                console.error("Error loading image: " + path);
                if (this.isDone()) {
                    callback();
                }
            };
            img.src = path;
            this.assets[path] = img;
        });
    }
}

// DOM加载完成后执行
window.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('game-canvas');
    const setupScreen = document.getElementById('setup-screen');
    const startNewGameBtn = document.getElementById('start-new-game-btn');
    const mapSelect = document.getElementById('map-select');
    
    // 动态填充地图选择下拉框
    MAP_DEFINITIONS.forEach(map => {
        const option = document.createElement('option');
        option.value = map.id;
        option.textContent = map.name;
        mapSelect.appendChild(option);
    });

    // 预加载所有单位图片
    const assetManager = new AssetManager();
    Object.values(UNIT_TYPES).forEach(unit => {
        assetManager.queueDownload(unit.imageSrc);
    });
    
    // 将加载好的图片存放在全局，方便游戏内其他模块访问
    window.assetManager = assetManager.assets; 
    
    startNewGameBtn.disabled = true;
    startNewGameBtn.textContent = '正在加载资源...';
    assetManager.downloadAll(() => {
        startNewGameBtn.disabled = false;
        startNewGameBtn.textContent = '创建游戏';
    });
    
    /**
     * 调整游戏Canvas尺寸以适应窗口变化。
     */
    function resizeGame() {
        const sidebar = document.getElementById('sidebar');
        const sidebarWidth = sidebar ? sidebar.offsetWidth : 0;
        canvas.width = window.innerWidth - sidebarWidth;
        canvas.height = window.innerHeight;
        
        // 如果游戏已经开始，则约束镜头范围
        if (window.game && window.game.constrainCamera) {
            window.game.constrainCamera();
        }
    }

    resizeGame();
    window.addEventListener('resize', resizeGame);

    // "创建游戏" 按钮点击事件
    startNewGameBtn.addEventListener('click', () => {
        const urlParams = new URLSearchParams(window.location.search);
        
        const showDetailsCheckbox = document.getElementById('show-details-checkbox');
        
        // 从UI收集游戏设置
        const settings = {
            gameMode: document.getElementById('game-mode-select').value,
            mapId: mapSelect.value,
            gameSpeed: document.getElementById('game-speed-select').value,
            aiDifficulty: document.getElementById('ai-difficulty-select').value,
            showDetails: showDetailsCheckbox.checked, // 读取复选框状态
            fromDialogue: urlParams.get('fromDialogue') === 'true',
            user: urlParams.get('user')
        };
        
        setupScreen.style.display = 'none';
        
        const game = new Game(canvas);
        game.init(settings);
    });
});
```

---

### `map.js`
```javascript
// js/map.js

import { TILE_SIZE, TERRAIN_TYPES } from './config.js';

/**
 * 生成一个基于种子的伪随机数。
 * @param {number} seed - 种子。
 * @returns {number} - 返回一个在 [0, 1) 区间内的浮点数。
 */
function seededRandom(seed) {
    let x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
}

/**
 * @class GameMap
 * @description 管理游戏地图数据和渲染。
 */
export class GameMap {
    constructor() {
        this.width = 0;
        this.height = 0;
        this.grid = []; // 二维数组，存储每个格子的地形信息
        this.terrainDetails = new Map(); // 缓存地形细节，避免重复计算
    }

    /**
     * 从地图数据加载地图。
     * @param {object} mapData - 来自 maps-data.js 的地图定义对象。
     */
    load(mapData) {
        this.width = mapData.width;
        this.height = mapData.height;
        const terrainMap = { 'g': 'grass', 'f': 'forest', 'r': 'road', 'w': 'water', 'b': 'building' };
        
        this.grid = Array(this.height).fill(null).map(() => Array(this.width).fill(null));
        
        for (let y = 0; y < this.height; y++) {
            const rowString = mapData.grid[y] || '';
            for (let x = 0; x < this.width; x++) {
                const char = rowString[x] || 'g'; // 默认为草地
                const type = terrainMap[char];
                this.grid[y][x] = { type };
            }
        }
    }

    /**
     * 绘制地图，包含地形混合和细节渲染。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {object} camera - 镜头对象，用于视口剔除。
     */
    draw(ctx, camera) {
        // 计算需要渲染的格子范围 (视口剔除)
        const startX = Math.floor(camera.x / TILE_SIZE);
        const startY = Math.floor(camera.y / TILE_SIZE);
        const endX = Math.ceil((camera.x + ctx.canvas.width / camera.zoom) / TILE_SIZE);
        const endY = Math.ceil((camera.y + ctx.canvas.height / camera.zoom) / TILE_SIZE);

        for (let y = startY; y < endY; y++) {
            for (let x = startX; x < endX; x++) {
                if (x < 0 || y < 0 || x >= this.width || y >= this.height) continue;
                
                const tile = this.getTile(x, y);
                if (!tile) continue;
                
                // 1. 绘制基础地形颜色
                const baseColor = TERRAIN_TYPES[tile.type].color;
                ctx.fillStyle = baseColor;
                ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE + 1, TILE_SIZE + 1); // +1 修复格子间缝隙

                // 2. 绘制地形边缘混合效果
                this.drawTerrainBlend(ctx, x, y);

                // 3. 绘制地形细节 (小杂色点)
                this.drawTerrainDetails(ctx, x, y, baseColor);
            }
        }
    }

    /**
     * 检查邻居并绘制地形混合效果。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {number} x - 格子X坐标。
     * @param {number} y - 格子Y坐标。
     */
    drawTerrainBlend(ctx, x, y) {
        const neighbors = [
            { dx: 0, dy: -1, dir: 'top' }, 
            { dx: 1, dy: 0, dir: 'right' }, 
            { dx: 0, dy: 1, dir: 'bottom' }, 
            { dx: -1, dy: 0, dir: 'left' }
        ];
        
        const currentType = TERRAIN_TYPES[this.getTile(x, y).type];

        for (const neighbor of neighbors) {
            const nx = x + neighbor.dx;
            const ny = y + neighbor.dy;

            const neighborTile = this.getTile(nx, ny);
            if (neighborTile) {
                const neighborType = TERRAIN_TYPES[neighborTile.type];

                // 如果邻居地形的渲染优先级更高，则在此格子的边缘绘制邻居地形的颜色，形成混合效果
                if (neighborType.priority > currentType.priority && currentType.priority > 0) {
                    this._drawBlendPattern(ctx, x, y, neighbor.dir, neighborType.color);
                }
            }
        }
    }

    /**
     * 绘制地形上的随机细节，增加视觉丰富度。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {number} x - 格子X坐标。
     * @param {number} y - 格子Y坐标。
     * @param {string} baseColor - 格子的基础颜色。
     */
    drawTerrainDetails(ctx, x, y, baseColor) {
        const detailKey = `${x},${y}`;
        if (!this.terrainDetails.has(detailKey)) {
            const details = [];
            const numDetails = Math.floor(seededRandom(y * this.width + x + 1) * 5);
            for (let i = 0; i < numDetails; i++) {
                details.push({
                    x: seededRandom(i + x * y + 2) * TILE_SIZE,
                    y: seededRandom(i * 2 + x * y + 3) * TILE_SIZE,
                    size: seededRandom(i * 3 + x * y + 4) * (TILE_SIZE / 4) + 2,
                    color: this.adjustColor(baseColor, (seededRandom(i * 4 + x * y + 5) - 0.5) * 0.2)
                });
            }
            this.terrainDetails.set(detailKey, details);
        }

        const cachedDetails = this.terrainDetails.get(detailKey);
        for(const detail of cachedDetails) {
            ctx.fillStyle = detail.color;
            ctx.fillRect(x * TILE_SIZE + detail.x, y * TILE_SIZE + detail.y, detail.size, detail.size);
        }
    }

    /**
     * 根据方向绘制确定的随机混合图案，实现自然的过渡效果。
     * @private
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {number} x - 当前瓦片的格子X坐标。
     * @param {number} y - 当前瓦片的格子Y坐标。
     * @param {string} direction - 邻居的方向 ('top', 'right', 'bottom', 'left')。
     * @param {string} blendColor - 邻居（高优先级地形）的颜色。
     */
    _drawBlendPattern(ctx, x, y, direction, blendColor) {
        ctx.fillStyle = blendColor;
        const subTileCount = 4; // 将瓦片边缘分为4个小块进行处理
        const subTileSize = TILE_SIZE / subTileCount; 
        const pixelX = x * TILE_SIZE;
        const pixelY = y * TILE_SIZE;

        for (let i = 0; i < subTileCount; i++) {
            // 使用瓦片坐标和块索引作为种子，确保每次渲染的图案都相同
            const seed = x * 13 + y * 31 + i * 7 + direction.charCodeAt(0);
            const randomVal = seededRandom(seed);
            
            if (randomVal < 0.6) { // 约60%的概率绘制混合块
                // 混合深度随机，但确定
                const blendDepth = Math.ceil(seededRandom(seed * 2) * 2) * (subTileSize / 2);
                
                let rectX, rectY, rectW, rectH;

                switch (direction) {
                    case 'top':
                        rectX = pixelX + i * subTileSize; rectY = pixelY;
                        rectW = subTileSize; rectH = blendDepth;
                        break;
                    case 'bottom':
                        rectX = pixelX + i * subTileSize; rectY = pixelY + TILE_SIZE - blendDepth;
                        rectW = subTileSize; rectH = blendDepth;
                        break;
                    case 'left':
                        rectX = pixelX; rectY = pixelY + i * subTileSize;
                        rectW = blendDepth; rectH = subTileSize;
                        break;
                    case 'right':
                        rectX = pixelX + TILE_SIZE - blendDepth; rectY = pixelY + i * subTileSize;
                        rectW = blendDepth; rectH = subTileSize;
                        break;
                }
                 ctx.fillRect(rectX, rectY, rectW + 1, rectH + 1); // +1 修复缝隙
            }
        }
    }

    /**
     * 微调颜色，用于生成地形细节。
     * @param {string} hex - 16进制颜色字符串 (e.g., '#FF0000')。
     * @param {number} percent - 调整百分比 (e.g., -0.2 to 0.2)。
     * @returns {string} - 调整后的16进制颜色字符串。
     */
    adjustColor(hex, percent) {
        let r = parseInt(hex.substring(1, 3), 16);
        let g = parseInt(hex.substring(3, 5), 16);
        let b = parseInt(hex.substring(5, 7), 16);
        const amount = Math.floor(255 * percent);
        r = Math.max(0, Math.min(255, r + amount));
        g = Math.max(0, Math.min(255, g + amount));
        b = Math.max(0, Math.min(255, b + amount));
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    /**
     * 获取指定坐标的格子信息。
     * @param {number} x - 格子X坐标。
     * @param {number} y - 格子Y坐标。
     * @returns {object|null} - 返回格子对象，如果越界则返回null。
     */
    getTile(x, y) {
        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
            return this.grid[y][x];
        }
        return null;
    }

    /**
     * 设置指定坐标格子的地形类型。
     * @param {number} x - 格子X坐标。
     * @param {number} y - 格子Y坐标。
     * @param {string} newType - 新的地形类型ID。
     */
    setTileType(x, y, newType) {
        const tile = this.getTile(x, y);
        if (tile && TERRAIN_TYPES[newType]) {
            tile.type = newType;
        }
    }
}```

---

### `maps-data.js`
```javascript
// js/maps-data.js

/**
 * @file 存放所有地图的定义数据。
 * 地图格子字符代表:
 * 'g': 草地 (grass)
 * 'f': 森林 (forest)
 * 'r': 马路 (road)
 * 'w': 海洋 (water)
 * 'b': 建筑 (building)
 */
export const MAP_DEFINITIONS = [
    {
        id: 'map_new_01',
        name: '十字路口冲突 (Crossroads Clash)',
        description: '中心道路是兵家必争之地，两侧的森林为伏击提供了可能。',
        width: 80, 
        height: 60,
        grid: (() => {
            const w = 80, h = 60;
            let grid = Array(h).fill(null).map(() => Array(w).fill('g'));
            
            // 主干道
            for (let y = 0; y < h; y++) {
                grid[y][Math.floor(w/2) -1] = 'r';
                grid[y][Math.floor(w/2)] = 'r';
            }
             for (let x = 0; x < w; x++) {
                grid[Math.floor(h/2) -1][x] = 'r';
                grid[Math.floor(h/2)][x] = 'r';
            }
            
            // 四角的森林区域
            for (let y = 10; y < 22; y++) {
                for(let x = 10; x < 25; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
                for(let x = w - 25; x < w - 10; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
            }
             for (let y = h - 22; y < h - 10; y++) {
                for(let x = 10; x < 25; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
                for(let x = w - 25; x < w - 10; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
            }

            // 上下的河流（带桥）
            for (let x = 28; x < 52; x++) {
                 if (x > 38 && x < 42) continue; // 桥的位置留空
                 grid[5][x] = 'w';
                 grid[h-6][x] = 'w';
            }
            return grid.map(row => row.join(''));
        })()
    },
    {
        id: 'map01',
        name: '双子桥 (Twin Bridges)',
        description: '一条河流将地图一分为二，只有两座桥梁可供地面部队通过。',
        width: 100, 
        height: 60,
        grid: (() => {
            const w = 100, h = 60;
            let grid = Array(h).fill(null).map(() => Array(w).fill('g'));
            
            // 河流
            for (let y = 28; y < 32; y++) {
                for (let x = 0; x < w; x++) grid[y][x] = 'w';
            }
            
            // 桥梁 (用马路代替)
            for (let y = 28; y < 32; y++) {
                for(let x = 20; x < 28; x++) grid[y][x] = 'r';
                for(let x = 72; x < 80; x++) grid[y][x] = 'r';
            }

            // 添加一些随机森林
            for (let i = 0; i < 200; i++) {
                const randX = Math.floor(Math.random() * w);
                const randY = Math.floor(Math.random() * h);
                if (grid[randY][randX] === 'g') grid[randY][randX] = 'f';
            }
            return grid.map(row => row.join(''));
        })()
    },
];
```

---

### `pathfinding.js`
```javascript
// js/pathfinding.js

import { TILE_SIZE, TERRAIN_TYPES } from './config.js';

/**
 * @class Node
 * @description A* 寻路算法中使用的节点。
 */
class Node {
    constructor(parent = null, position = null) {
        this.parent = parent;
        this.position = position; // {x, y} 格子坐标
        this.g = 0; // 从起点到当前节点的代价
        this.h = 0; // 从当前节点到终点的预估代价 (启发式)
        this.f = 0; // 总代价 (g + h)
    }

    /**
     * 检查当前节点是否与另一个节点位置相同。
     * @param {Node} other - 另一个节点。
     * @returns {boolean}
     */
    equals(other) {
        return this.position.x === other.position.x && this.position.y === other.position.y;
    }
}

/**
 * 使用 A* 算法在地图上寻找路径。
 * @param {GameMap} map - 游戏地图对象。
 * @param {{x: number, y: number}} start - 起点格子坐标。
 * @param {{x: number, y: number}} end - 终点格子坐标。
 * @param {string} moveType - 移动单位的类型 ('ground', 'air', etc.)。
 * @returns {Array<{x: number, y: number}>|null} - 返回一个包含路径节点坐标的数组，如果找不到路径则返回null。
 */
export function findPath(map, start, end, moveType) {
    // 对于空中单位，路径就是一条直线，无需寻路
    if (moveType === 'air') {
        return [start, end];
    }
    
    const startNode = new Node(null, start);
    const endNode = new Node(null, end);

    let openList = []; // 待评估的节点
    let closedList = []; // 已评估的节点

    openList.push(startNode);
    
    // 设置最大迭代次数，防止因地图过大或无解导致的性能问题
    const maxIterations = map.width * map.height * 1.5;
    let iterations = 0;

    while (openList.length > 0 && iterations < maxIterations) {
        iterations++;
        
        // 从 openList 中找到 f 值最小的节点
        let currentNode = openList[0];
        let currentIndex = 0;
        for (let i = 1; i < openList.length; i++) {
            if (openList[i].f < currentNode.f) {
                currentNode = openList[i];
                currentIndex = i;
            }
        }

        // 将当前节点从 openList 移到 closedList
        openList.splice(currentIndex, 1);
        closedList.push(currentNode);

        // 如果到达终点，则回溯路径并返回
        if (currentNode.equals(endNode)) {
            let path = [];
            let current = currentNode;
            while (current !== null) {
                path.push(current.position);
                current = current.parent;
            }
            return path.reverse();
        }

        // 检查所有相邻的格子
        const adjacentSquares = [
            { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
            { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 }
        ];

        for (const newPosition of adjacentSquares) {
            const nodePosition = {
                x: currentNode.position.x + newPosition.x,
                y: currentNode.position.y + newPosition.y,
            };

            const tile = map.getTile(nodePosition.x, nodePosition.y);
            // 如果邻居节点不可通行，则跳过
            if (!tile || !TERRAIN_TYPES[tile.type].traversableBy.includes(moveType)) {
                continue;
            }
            
            const childNode = new Node(currentNode, nodePosition);
            
            // 如果邻居节点已在 closedList 中，则跳过
            if (closedList.find(node => node.equals(childNode))) {
                 continue;
            }

            // 计算 g, h, f 值
            const moveCost = (newPosition.x !== 0 && newPosition.y !== 0) ? 1.414 : 1; // 对角线移动代价更高
            childNode.g = currentNode.g + moveCost;
            childNode.h = Math.sqrt(((childNode.position.x - endNode.position.x) ** 2) + ((childNode.position.y - endNode.position.y) ** 2));
            childNode.f = childNode.g + childNode.h;

            // 如果邻居节点已在 openList 中，且新的路径代价更高，则跳过
            const existingNode = openList.find(node => node.equals(childNode));
            if (existingNode && childNode.g >= existingNode.g) {
                continue;
            }
            
            // 更新或添加节点到 openList
            if (existingNode) {
                existingNode.parent = currentNode;
                existingNode.g = childNode.g;
                existingNode.f = childNode.f;
            } else {
                openList.push(childNode);
            }
        }
    }

    return null; // 找不到路径
}


/**
 * 检查两点之间是否有地形障碍，用于路径平滑处理（拉直路径）。
 * @param {{x: number, y: number}} startPos - 起点像素坐标。
 * @param {{x: number, y: number}} endPos - 终点像素坐标。
 * @param {GameMap} map - 游戏地图对象。
 * @param {string} moveType - 移动单位的类型。
 * @returns {boolean} - 如果没有障碍则返回true。
 */
export function isLineOfSightClear(startPos, endPos, map, moveType) {
    // 空中单位永远视野清晰，无视地形障碍
    if (moveType === 'air') {
        return true;
    }

    const dx = endPos.x - startPos.x;
    const dy = endPos.y - startPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const step = TILE_SIZE / 2; // 检查步长，半个格子大小
    const steps = Math.ceil(distance / step);

    // 沿直线步进检查每个点所在的地形是否可通行
    for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const checkX = startPos.x + dx * t;
        const checkY = startPos.y + dy * t;

        const gridX = Math.floor(checkX / TILE_SIZE);
        const gridY = Math.floor(checkY / TILE_SIZE);

        const tile = map.getTile(gridX, gridY);
        if (!tile || !TERRAIN_TYPES[tile.type].traversableBy.includes(moveType)) {
            return false; // 遇到障碍
        }
    }
    
    return true; // 路径清晰
}
```

---

### `player.js`
```javascript
// js/player.js

import { AIController } from './ai.js';

/**
 * @class Player
 * @description 代表一个玩家，可以是人类或AI。
 */
export class Player {
    /**
     * @param {string} id - 玩家ID ('player' or 'ai')。
     * @param {string} name - 玩家名称。
     * @param {number} manpower - 初始资源。
     * @param {boolean} [isAI=false] - 是否为AI玩家。
     * @param {object} [baseArea] - 基地范围 (未使用)。
     * @param {string} [aiDifficulty='medium'] - AI难度。
     */
    constructor(id, name, manpower, isAI = false, baseArea, aiDifficulty = 'medium') {
        this.id = id;
        this.name = name;
        this.manpower = manpower;
        this.isAI = isAI;
        this.units = [];
        this.baseArea = baseArea; 
        this.baseCaptureTimer = 0; // for capture mechanics (not implemented)

        if (isAI) {
            this.aiController = new AIController(this, aiDifficulty);
        }
    }

    /**
     * 更新玩家逻辑，主要用于驱动AI。
     * @param {number} deltaTime - 帧时间差。
     * @param {Player} enemyPlayer - 敌方玩家对象。
     * @param {GameMap} map - 游戏地图。
     * @param {SpatialGrid} spatialGrid - 空间网格，传递给AI控制器用于索敌。
     */
    update(deltaTime, enemyPlayer, map, spatialGrid) {
        if (this.isAI) {
            this.aiController.update(this.units, enemyPlayer.units, map, deltaTime, spatialGrid);
        }
    }
    
    /**
     * 检查资源是否足够。
     * @param {number} unitCost - 单位花费。
     * @returns {boolean}
     */
    canAfford(unitCost) {
        return this.manpower >= unitCost;
    }
    
    /**
     * 扣除资源。
     * @param {number} amount - 扣除数量。
     */
    deductManpower(amount) {
        this.manpower -= amount;
    }
}
```

---

### `projectile.js`
```javascript
// js/projectile.js

import { getDistance } from './utils.js';

let nextProjectileId = 0;

/**
 * @class Projectile
 * @description 代表一个飞行中的弹道物体，如子弹、炮弹或导弹。
 */
export class Projectile {
    /**
     * @param {string} owner - 发射者的owner ID ('player' or 'ai')。
     * @param {{x: number, y: number}} startPos - 发射位置。
     * @param {Unit|Base} target - 目标对象。
     * @param {object} stats - 弹道属性 (伤害, 速度, 类型等)。
     */
    constructor(owner, startPos, target, stats) {
        this.id = nextProjectileId++;
        this.owner = owner;
        this.x = startPos.x;
        this.y = startPos.y;
        this.target = target;
        this.stats = stats;

        const targetPos = { x: target.pixelX || target.x, y: target.pixelY || target.y };
        const angle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
        this.vx = Math.cos(angle) * this.stats.ammoSpeed;
        this.vy = Math.sin(angle) * this.stats.ammoSpeed;
        
        this.trail = []; // 用于拖尾效果的粒子数组
        this.life = 0; // 弹道的生命周期计时
    }

    /**
     * 更新弹道位置和状态。
     * @param {number} deltaTime - 帧时间差。
     * @returns {boolean} - 如果弹道应该被销毁（命中或超时），则返回true。
     */
    update(deltaTime) {
        const targetPos = this.target ? { x: this.target.pixelX || this.target.x, y: this.target.pixelY || this.target.y } : {x: this.x + this.vx, y: this.y + this.vy};

        // 导弹的简单追踪逻辑
        if (this.stats.ammoType === 'missile' && this.target && this.target.hp > 0) {
            const angle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
            const targetVx = Math.cos(angle) * this.stats.ammoSpeed;
            const targetVy = Math.sin(angle) * this.stats.ammoSpeed;
            // 使用线性插值使导弹转向更平滑
            this.vx = this.vx * 0.98 + targetVx * 0.02;
            this.vy = this.vy * 0.98 + targetVy * 0.02;
        }

        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        this.life += deltaTime;

        // 更新拖尾效果
        this.updateTrail(deltaTime);

        const dist = getDistance(this, targetPos);
        // 命中判定（距离足够近）或超时（飞行时间过长）
        return dist < 10 || this.life > 5;
    }
    
    /**
     * 更新拖尾粒子效果。
     * @param {number} deltaTime - 帧时间差。
     */
    updateTrail(deltaTime) {
        if (this.stats.ammoType === 'missile' || this.stats.ammoType === 'shell') {
            // 每隔一小段距离添加一个新的拖尾粒子
            if (this.trail.length === 0 || getDistance(this.trail[this.trail.length-1], this) > 5) {
                this.trail.push({ x: this.x, y: this.y, life: 1.0 });
            }
        }
        
        // 更新并移除生命周期结束的拖尾粒子
        for (let i = this.trail.length - 1; i >= 0; i--) {
            this.trail[i].life -= deltaTime * 2.5;
            if (this.trail[i].life <= 0) {
                this.trail.splice(i, 1);
            }
        }
    }

    /**
     * 绘制弹道和其拖尾。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     */
    draw(ctx) {
        // 绘制拖尾（烟雾）
        if (this.stats.ammoType === 'missile' || this.stats.ammoType === 'shell') {
             ctx.fillStyle = `rgba(180, 180, 180, 0.4)`;
             this.trail.forEach(p => {
                ctx.beginPath();
                // 粒子大小随生命周期减小
                const radius = p.life * (this.stats.ammoType === 'missile' ? 4 : 2.5);
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // 绘制弹头
        switch (this.stats.ammoType) {
            case 'missile':
                ctx.fillStyle = `rgba(255, 200, 100, 1)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 'bullet':
                 ctx.fillStyle = 'yellow';
                 ctx.fillRect(this.x - 1, this.y - 1, 3, 3);
                 break;
            case 'shell':
                 ctx.fillStyle = '#ddd';
                 ctx.beginPath();
                 ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                 ctx.fill();
                 break;
        }
    }
}


/**
 * @class Explosion
 * @description 管理一个爆炸的视觉效果，包括火光和烟雾粒子。
 */
export class Explosion {
    /**
     * @param {number} x - 爆炸中心X坐标。
     * @param {number} y - 爆炸中心Y坐标。
     * @param {number} radius - 爆炸的最大半径。
     */
    constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius < 10 ? 10 : radius; // 最小爆炸半径
        this.maxLife = 0.6; // 爆炸持续时间（秒）
        this.life = this.maxLife;
        
        // 创建烟雾粒子
        this.particles = [];
        const particleCount = 15 + Math.floor(this.radius / 5);
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * this.radius * 0.5;
            this.particles.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                size: Math.random() * 5 + 2,
                alpha: Math.random() * 0.3 + 0.1,
            });
        }
    }

    /**
     * 更新爆炸效果的生命周期和粒子状态。
     * @param {number} deltaTime - 帧时间差。
     * @returns {boolean} - 如果爆炸效果应该被销毁，则返回true。
     */
    update(deltaTime) {
        this.life -= deltaTime;
        
        // 更新每个烟雾粒子的状态
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.life -= deltaTime * 0.8;
             if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
        
        return this.life <= 0 && this.particles.length === 0;
    }

    /**
     * 绘制爆炸效果。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     */
    draw(ctx) {
        const progress = 1 - (this.life / this.maxLife);
        
        // 绘制烟雾粒子
        this.particles.forEach(p => {
            ctx.fillStyle = `rgba(80, 80, 80, ${p.alpha * p.life})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (1 + progress), 0, Math.PI * 2);
            ctx.fill();
        });

        // 绘制火光 (多层叠加，实现体积感)
        if (this.life > 0) {
            // 使用sin函数实现平滑的淡入淡出效果
            const alpha = Math.sin(Math.PI * progress);
            
            // 1. 外层橙红色火焰
            let currentRadius = this.radius * progress;
            ctx.fillStyle = `rgba(255, 120, 0, ${alpha * 0.7})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // 2. 中层黄色火焰
            currentRadius *= 0.7;
            ctx.fillStyle = `rgba(255, 220, 100, ${alpha * 0.9})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();

            // 3. 核心白热化火焰
            currentRadius *= 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}
```

---

### `spatial-grid.js`
```javascript
// js/spatial-grid.js

/**
 * @file 空间网格数据结构，用于RTS游戏中的核心性能优化。
 * 它将游戏世界划分为一个网格，每个单位被放置在对应的格子里。
 * 当需要查询一个单位附近的其它单位时，只需检查其所在格子及周围的格子即可，
 * 避免了全局遍历所有单位，从而将碰撞检测、索敌等操作的复杂度从 O(n^2) 降低到接近 O(n)。
 */

/**
 * @class SpatialGrid
 */
export class SpatialGrid {
    /**
     * @param {number} mapWidth - 地图的总像素宽度。
     * @param {number} mapHeight - 地图的总像素高度。
     * @param {number} cellSize - 每个空间格子的像素尺寸。这个值通常应大于或等于最大单位的交互半径（如视野、射程）。
     */
    constructor(mapWidth, mapHeight, cellSize) {
        this.cellSize = cellSize;
        this.gridWidth = Math.ceil(mapWidth / cellSize);
        this.gridHeight = Math.ceil(mapHeight / cellSize);
        // 使用Map来存储格子，key是 "x,y" 格式的字符串，value是该格子内的单位数组。
        // Map比普通对象在频繁增删键时性能更好。
        this.grid = new Map(); 
    }

    /**
     * 将网格坐标转换为唯一的字符串键。
     * @private
     * @param {number} gridX - 网格的X坐标。
     * @param {number} gridY - 网格的Y坐标。
     * @returns {string} - "x,y" 格式的键。
     */
    _getKey(gridX, gridY) {
        return `${gridX},${gridY}`;
    }

    /**
     * 清空所有格子。此方法应在每帧更新开始时调用。
     */
    clear() {
        this.grid.clear();
    }

    /**
     * 将一个单位插入到其当前位置对应的格子中。
     * @param {Unit} unit - 要插入的单位。
     */
    insert(unit) {
        const gridX = Math.floor(unit.x / this.cellSize);
        const gridY = Math.floor(unit.y / this.cellSize);
        const key = this._getKey(gridX, gridY);

        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(unit);
    }

    /**
     * 获取一个单位附近（其自身格子 + 周围8个格子）的所有单位。
     * 这是最常用的查询方法，用于碰撞检测等。
     * @param {Unit} unit - 要查询的中心单位。
     * @returns {Array<Unit>} - 附近单位的数组。
     */
    getNearby(unit) {
        const nearbyUnits = [];
        const centralGridX = Math.floor(unit.x / this.cellSize);
        const centralGridY = Math.floor(unit.y / this.cellSize);

        // 遍历中心格子及其周围的8个格子 (3x3区域)
        for (let y = -1; y <= 1; y++) {
            for (let x = -1; x <= 1; x++) {
                const checkGridX = centralGridX + x;
                const checkGridY = centralGridY + y;
                const key = this._getKey(checkGridX, checkGridY);

                if (this.grid.has(key)) {
                    nearbyUnits.push(...this.grid.get(key));
                }
            }
        }
        return nearbyUnits;
    }
    
    /**
     * 获取一个点周围指定半径内的所有单位。
     * 这个方法比 getNearby 更精确，但可能需要检查更多的格子。
     * @param {{x: number, y: number}} position - 查询的中心点。
     * @param {number} radius - 查询半径。
     * @returns {Array<Unit>} - 半径范围内的单位数组。
     */
    getNearbyWithRadius(position, radius) {
        const nearbyUnits = new Set(); // 使用Set避免重复添加单位
        const minGridX = Math.floor((position.x - radius) / this.cellSize);
        const maxGridX = Math.floor((position.x + radius) / this.cellSize);
        const minGridY = Math.floor((position.y - radius) / this.cellSize);
        const maxGridY = Math.floor((position.y + radius) / this.cellSize);

        for (let y = minGridY; y <= maxGridY; y++) {
            for (let x = minGridX; x <= maxGridX; x++) {
                const key = this._getKey(x, y);
                 if (this.grid.has(key)) {
                    this.grid.get(key).forEach(unit => nearbyUnits.add(unit));
                }
            }
        }
        return Array.from(nearbyUnits);
    }
}
```

---

### `ui.js`
```javascript
// js/ui.js

import { UNIT_TYPES, TERRAIN_TYPES, TILE_SIZE } from './config.js';

/**
 * @class UI
 * @description 管理游戏的用户界面，包括单位选择、信息显示和玩家交互。
 */
export class UI {
    /**
     * @param {Game} game - 游戏主对象的引用。
     */
    constructor(game) {
        this.game = game;
        
        // DOM元素引用
        this.unitListContainer = document.getElementById('unit-selection');
        this.playerManpower = document.getElementById('player-manpower');
        this.gameStatus = document.getElementById('game-status');
        this.startBattleBtn = document.getElementById('start-battle-btn');
        this.selectedUnitInfo = document.getElementById('selected-unit-info');
        
        this.selectedUnitToDeploy = null; // 当前在部署列表中选中的单位类型
        this.messageTimeout = null; // 游戏消息的计时器

        this.init();
    }

    /**
     * 初始化UI，填充单位列表并绑定事件。
     */
    init() {
        this.populateUnitList();
        
        if (this.startBattleBtn) {
            this.startBattleBtn.addEventListener('click', () => this.game.startGame());
        }
    }

    /**
     * 根据config.js中的单位定义，动态生成可部署单位的列表。
     */
    populateUnitList() {
        if (!this.unitListContainer) return;
        
        this.unitListContainer.innerHTML = `
            <h3>可部署兵种</h3>
            <div id="unit-list-wrapper"></div>
        `;
        const listWrapper = this.unitListContainer.querySelector('#unit-list-wrapper');

        // 按单位类别进行分组
        const groupedUnits = {};
        for (const type in UNIT_TYPES) {
            const unit = UNIT_TYPES[type];
            if (!groupedUnits[unit.unitClass]) {
                groupedUnits[unit.unitClass] = [];
            }
            groupedUnits[unit.unitClass].push({ id: type, ...unit });
        }

        // 按预设顺序渲染类别
        const categoryOrder = ['步兵', '装甲', '飞行', '炮兵', '海军'];
        for (const category of categoryOrder) {
            if (!groupedUnits[category]) continue;

            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'unit-category';
            categoryDiv.innerHTML = `<h4>${category}</h4>`;
            
            const ul = document.createElement('ul');
            ul.className = 'unit-list';

            groupedUnits[category].forEach(unit => {
                const li = document.createElement('li');
                li.dataset.unitType = unit.id;
                li.title = unit.description;

                li.innerHTML = `
                    <div class="unit-icon">${unit.icon}</div>
                    <div class="unit-details">
                        <strong>${unit.name}</strong>
                        <div class="unit-stats">费用: ${unit.cost} | HP: ${unit.hp} | 攻击: ${unit.attack}</div>
                    </div>
                `;
                
                li.addEventListener('click', () => {
                    const wasSelected = li.classList.contains('selected');
                    this.clearAllSelectionsInList();
                    
                    if (!wasSelected) {
                        li.classList.add('selected');
                        this.selectedUnitToDeploy = unit.id;
                        // 交互优化: 选择部署单位时，自动取消地图上已选中的单位
                        this.game.selectedUnits = [];
                    } else {
                        this.selectedUnitToDeploy = null;
                    }
                });
                ul.appendChild(li);
            });

            categoryDiv.appendChild(ul);
            listWrapper.appendChild(categoryDiv);
        }
    }

    /**
     * 清除部署列表中所有单位的选中状态。
     */
    clearAllSelectionsInList() {
        if (!this.unitListContainer) return;
        this.unitListContainer.querySelectorAll('li.selected').forEach(item => item.classList.remove('selected'));
    }

    /**
     * 清除待部署单位的选择状态。通常由Game类在其他操作（如框选）后调用。
     */
    clearDeploymentSelection() {
        if (this.selectedUnitToDeploy) {
            this.selectedUnitToDeploy = null;
            this.clearAllSelectionsInList();
        }
    }

    /**
     * 每帧更新UI显示，如资源、游戏状态和基地血量。
     */
    update() {
        if (this.playerManpower) this.playerManpower.textContent = this.game.player.manpower;
        if (this.gameStatus) this.gameStatus.textContent = `状态: ${this.game.gameState}`;
        if (this.startBattleBtn) this.startBattleBtn.disabled = this.game.gameState !== 'deployment';
        
        // 更新基地血条
        this.updateBaseHP('player');
        this.updateBaseHP('ai');

        // 更新选中单位的信息面板
        this.updateSelectedUnitInfo();
    }
    
    /**
     * 更新指定玩家的基地HP条。
     * @param {string} owner - 'player' or 'ai'.
     */
    updateBaseHP(owner) {
        const base = this.game[`${owner}Base`];
        const displayDiv = document.getElementById(`${owner}-base-hp-display`);
        if (!displayDiv) return;

        if (base) {
            displayDiv.style.display = 'block';
            const hpBar = document.getElementById(`${owner}-base-hp-bar`);
            if(hpBar) {
                const percentage = (base.hp / base.maxHp) * 100;
                hpBar.style.width = `${percentage}%`;
            }
        } else {
            displayDiv.style.display = 'none';
        }
    }

    /**
     * 更新显示在UI右下角的选中单位信息。
     */
    updateSelectedUnitInfo() {
        if (!this.selectedUnitInfo) return;
        
        const selectedCount = this.game.selectedUnits.length;

        if (selectedCount === 1) {
            // 显示单个单位的详细信息
            const unit = this.game.selectedUnits[0]; 
            const stats = unit.stats;
            
            let statusText = '待命';
            if (unit.target) statusText = '攻击中';
            else if (unit.path && unit.path.length > 0) statusText = '移动中';
            else if (unit.isLoitering) statusText = '巡逻中';
            else if (unit.isSettingUp) statusText = '部署中';

            this.selectedUnitInfo.innerHTML = `
                <h4>${stats.name}</h4>
                <p>HP: ${unit.hp.toFixed(0)} / ${stats.hp}</p>
                <div class="hp-bar-container small">
                   <div class="hp-bar" style="width: ${(unit.hp / stats.hp) * 100}%; background-color: green;"></div>
                </div>
                <p>攻击: ${stats.attack} | 防御: ${stats.defense}</p>
                <p>射程: ${stats.range / TILE_SIZE}格 | 状态: ${statusText}</p> 
            `;
        } else if (selectedCount > 1) {
            // 显示多个单位的概要信息
            this.selectedUnitInfo.innerHTML = `
                <h4>选中多个单位</h4>
                <p>${selectedCount} 个单位被选中。</p>
            `;
        } else {
            // 没有单位被选中
            this.selectedUnitInfo.innerHTML = '<h4>选中单位信息</h4><p>无</p>';
        }
    }
    
    /**
     * 在游戏结束时显示胜利者信息。
     * @param {string} winnerName - 胜利者的名字。
     */
    showWinner(winnerName) {
        const winnerDiv = document.createElement('div');
        winnerDiv.className = 'winner-announcement';
        winnerDiv.textContent = `${winnerName} 获胜!`;
        document.body.appendChild(winnerDiv);
    }

    /**
     * 在屏幕上显示一条临时游戏消息 (如 "资源不足")。
     * @param {string} message - 要显示的消息文本。
     */
    showGameMessage(message) {
        let messageDiv = document.getElementById('game-message');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'game-message';
            document.body.appendChild(messageDiv);
        }
        
        messageDiv.textContent = message;
        messageDiv.classList.add('show');

        if (this.messageTimeout) clearTimeout(this.messageTimeout);
        
        this.messageTimeout = setTimeout(() => {
            messageDiv.classList.remove('show');
        }, 3000);
    }
}
```

---

### `unit.js`
```javascript
// js/unit.js

import { TILE_SIZE, UNIT_TYPES } from './config.js';
import { getDistance } from './utils.js';
import { Base } from './base.js';
import { Projectile } from './projectile.js';
import { findPath, isLineOfSightClear } from './pathfinding.js';

let nextUnitId = 0;

/**
 * @class Unit
 * @description 游戏中的基础作战单位类。
 */
export class Unit {
    /**
     * @param {string} type - 单位类型ID, 对应 config.js 中的键。
     * @param {string} owner - 所有者 ('player' or 'ai')。
     * @param {number} x - 初始像素X坐标。
     * @param {number} y - 初始像素Y坐标。
     */
    constructor(type, owner, x, y) {
        this.id = nextUnitId++;
        this.type = type;
        this.owner = owner;
        this.stats = { ...UNIT_TYPES[type] }; // 复制单位属性，防止修改全局配置
        this.image = window.assetManager[this.stats.imageSrc];

        // 位置和状态
        this.x = x;
        this.y = y;
        this.hp = this.stats.hp;
        this.angle = Math.random() * Math.PI * 2; // 当前朝向
        this.targetAngle = this.angle; // 目标朝向
        this.rotationSpeed = Math.PI * 2.0; // 每秒旋转速度
        
        // 战斗相关
        this.target = null;
        this.attackCooldown = 0;
        this.findTargetCooldown = Math.random() * 0.5; // 错开AI单位的索敌计算，避免同时计算造成卡顿

        // 移动相关
        this.path = [];
        this.currentPathIndex = 0;
        this.moveTargetPos = null; // 当前平滑路径的目标点
        
        // 特殊行为状态
        this.isLoitering = false; // 是否在巡逻（主要用于飞机）
        this.loiterCenter = null;
        this.loiterRadius = TILE_SIZE * 5;
        this.loiterAngle = 0;
        this.strafeDirection = Math.random() < 0.5 ? 1 : -1; // 飞机绕圈方向
        
        this.isSettingUp = false; // 是否在部署（炮兵）
        this.setupTimer = 0;
    }

    /**
     * 单位的主更新逻辑。
     * @param {number} deltaTime - 帧时间差。
     * @param {Array<Unit>} enemyUnits - 敌方单位数组 (已废弃，改用spatialGrid)。
     * @param {GameMap} map - 地图对象。
     * @param {Base} enemyBase - 敌方基地。
     * @param {Game} game - 游戏主对象。
     * @param {SpatialGrid} spatialGrid - 用于高效索敌的空间网格。
     */
    update(deltaTime, enemyUnits, map, enemyBase, game, spatialGrid) {
        if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;
        if (this.findTargetCooldown > 0) this.findTargetCooldown -= deltaTime;
        
        this.updateRotation(deltaTime);

        // 炮兵等单位部署中不能做任何事
        if (this.isSettingUp) {
            this.setupTimer -= deltaTime;
            if (this.setupTimer <= 0) this.isSettingUp = false;
            return;
        }
        
        // 核心逻辑：攻击或移动
        if (this.target && this.target.hp > 0) {
            this.handleAttack(this.target, game);
        } else {
            this.target = null;
            this.handleMovement(deltaTime, map);
        }

        // 性能优化：使用空间网格进行节流索敌
        // 只有当单位空闲且索敌冷却结束时才执行
        if (!this.target && this.path.length === 0 && !this.moveTargetPos && this.findTargetCooldown <= 0) {
            this.findTarget(enemyBase, spatialGrid);
            this.findTargetCooldown = 0.5 + Math.random() * 0.2; // 无论是否找到都重置计时器
            
            // 如果没找到目标，特定空军单位进入巡逻模式
            if (!this.target && this.stats.moveType === 'air' && (this.type === 'fighter_jet' || this.type === 'recon_drone')) {
                this.handleLoitering(deltaTime);
            }
        }
    }

    /**
     * 处理攻击目标的逻辑。
     * @param {Unit|Base} target - 攻击目标。
     * @param {Game} game - 游戏主对象。
     */
    handleAttack(target, game) {
        const targetPos = { x: target.pixelX || target.x, y: target.pixelY || target.y };
        const distanceToTarget = getDistance(this, targetPos);
        const engageRange = this.stats.range * 0.9; // 进入此范围才开火，避免在最大射程边缘反复横跳

        // 如果距离太远，则向目标移动
        if (distanceToTarget > engageRange) {
            // 只有在没有移动路径时才重新寻路，防止频繁计算
            if (!this.path.length && !this.moveTargetPos) {
                this.issueMoveCommand(targetPos, game.map, true);
            }
        } else {
            // 进入射程，停止移动
            this.path = [];
            this.moveTargetPos = null;
        }
        
        // 转向目标
        this.setTargetAngle(targetPos);
        
        // 在射程内且冷却完毕，则开火
        if (distanceToTarget <= this.stats.range) {
            // 检查是否已对准目标
            let angleDiff = Math.abs(this.angle - this.targetAngle);
            if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
            
            if (this.attackCooldown <= 0 && !this.isSettingUp && angleDiff < 0.2) {
                this.attack(game);
            }
        }
    }
    
    /**
     * 处理移动逻辑，包括路径平滑。
     * @param {number} deltaTime - 帧时间差。
     * @param {GameMap} map - 地图对象。
     */
    handleMovement(deltaTime, map) {
        // 如果有路径但没有平滑目标点，则计算下一个平滑目标点
        if (this.path.length > 0 && !this.moveTargetPos) {
            this.findSmoothedPathTarget(map);
        }
        
        if (this.moveTargetPos) {
            this.setTargetAngle(this.moveTargetPos);
            const distanceToNode = getDistance(this, this.moveTargetPos);
            
            // 到达路径节点
            if (distanceToNode < TILE_SIZE / 2) {
                this.moveTargetPos = null; 
                // 到达最终目的地
                if (this.currentPathIndex >= this.path.length -1) {
                    this.path = [];
                    // 如果是炮兵，到达后需要部署
                    if (this.stats.special === 'SETUP_TO_FIRE') {
                        this.isSettingUp = true;
                        this.setupTimer = 2.0;
                    }
                }
            } else {
                this.move(deltaTime);
            }
        }
    }

    /**
     * 处理空中单位的巡逻（绕圈）行为。
     * @param {number} deltaTime - 帧时间差。
     */
    handleLoitering(deltaTime) {
        if (!this.isLoitering) {
            this.isLoitering = true;
            this.loiterCenter = { x: this.x, y: this.y };
            this.loiterAngle = Math.atan2(this.y - this.loiterCenter.y, this.x - this.loiterCenter.x);
        }
        
        this.loiterAngle += 0.8 * deltaTime;
        
        const targetX = this.loiterCenter.x + Math.cos(this.loiterAngle) * this.loiterRadius;
        const targetY = this.loiterCenter.y + Math.sin(this.loiterAngle) * this.loiterRadius;
        
        this.setTargetAngle({x: targetX, y: targetY});
        this.move(deltaTime);
    }

    /**
     * 根据当前朝向和速度移动单位。
     * @param {number} deltaTime - 帧时间差。
     */
    move(deltaTime) {
        const speed = this.stats.speed * deltaTime;
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;
    }

    /**
     * 下达移动命令，计算路径。
     * @param {{x: number, y: number}} targetPos - 目标像素坐标。
     * @param {GameMap} map - 地图对象。
     * @param {boolean} [isEngaging=false] - 这次移动是否是为了攻击。
     */
    issueMoveCommand(targetPos, map, isEngaging = false) {
        if (!isEngaging) this.target = null; // 普通移动命令会取消攻击目标
        this.isLoitering = false;
        this.isSettingUp = false;
        this.moveTargetPos = null;
        
        const startGrid = { x: Math.floor(this.x / TILE_SIZE), y: Math.floor(this.y / TILE_SIZE) };
        const endGrid = { x: Math.floor(targetPos.x / TILE_SIZE), y: Math.floor(targetPos.y / TILE_SIZE) };
        const path = findPath(map, startGrid, endGrid, this.stats.moveType);
        
        if (path && path.length > 0) {
            this.path = path;
            this.currentPathIndex = 0;
        } else {
            this.path = [];
        }
    }

    /**
     * 平滑地更新单位朝向。
     * @param {number} deltaTime - 帧时间差。
     */
    updateRotation(deltaTime) {
        let diff = this.targetAngle - this.angle;
        // 确保选择最短路径旋转
        while (diff <= -Math.PI) diff += 2 * Math.PI;
        while (diff > Math.PI) diff -= 2 * Math.PI;
        
        const turnStep = this.rotationSpeed * deltaTime;
        if (Math.abs(diff) < turnStep) {
            this.angle = this.targetAngle;
        } else {
            this.angle += Math.sign(diff) * turnStep;
        }
        // 将角度标准化到 [0, 2*PI)
        this.angle = (this.angle + 2 * Math.PI) % (2 * Math.PI);
    }
    
    /**
     * 设置单位的目标朝向角度。
     * @param {{x: number, y: number}} targetPos - 目标点像素坐标。
     */
    setTargetAngle(targetPos) {
        this.targetAngle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
    }

    /**
     * 绘制单位及其UI元素（血条、选择框等）。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {boolean} isSelected - 单位当前是否被选中。
     * @param {number} [zoom=1] - 当前镜头缩放。
     * @param {boolean} [showDetails=false] - 是否显示额外信息（射程圈、路径线）。
     */
    draw(ctx, isSelected, zoom = 1, showDetails = false) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI / 2); // 图像资源通常是朝上的，旋转90度
        const size = TILE_SIZE * (this.stats.drawScale || 1.5); 
        
        if (this.image) {
            ctx.drawImage(this.image, -size / 2, -size / 2, size, size);
        }
        ctx.restore();

        // 绘制选中状态和详细信息
        if (isSelected) {
            ctx.strokeStyle = this.owner === 'player' ? 'yellow' : 'orange';
            ctx.lineWidth = 2 / zoom;
            ctx.beginPath();
            ctx.arc(this.x, this.y, TILE_SIZE * this.stats.drawScale / 2, 0, Math.PI * 2);
            ctx.stroke();

            if (showDetails) {
                // 绘制射程圈
                if (this.stats.range > 0) {
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                    ctx.lineWidth = 1 / zoom;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.range, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // 绘制路径线
                if (this.path && this.path.length > 0) {
                    const endNode = this.path[this.path.length - 1];
                    const destX = endNode.x * TILE_SIZE + TILE_SIZE / 2;
                    const destY = endNode.y * TILE_SIZE + TILE_SIZE / 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(destX, destY);
                    ctx.strokeStyle = this.target ? 'rgba(255, 50, 50, 0.7)' : 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 3 / zoom]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        // 绘制血条
        const hpBarWidth = TILE_SIZE;
        const hpBarHeight = 5 / zoom;
        const hpBarYOffset = TILE_SIZE * 0.8;
        ctx.fillStyle = '#333';
        ctx.fillRect(this.x - hpBarWidth / 2, this.y - hpBarYOffset, hpBarWidth, hpBarHeight);
        ctx.fillStyle = this.owner === 'player' ? 'green' : '#c0392b';
        ctx.fillRect(this.x - hpBarWidth / 2, this.y - hpBarYOffset, hpBarWidth * (this.hp / this.stats.hp), hpBarHeight);
    }
    
    /**
     * 核心重构 (性能优化): 使用空间网格进行高效索敌。
     * @param {Base} enemyBase - 敌方基地对象。
     * @param {SpatialGrid} spatialGrid - 空间网格。
     */
    findTarget(enemyBase, spatialGrid) {
        let closestTarget = null;
        let minDistance = this.stats.visionRange; // 只在视野范围内搜索
        const validTargetTypes = this.stats.canTarget || ['ground', 'air', 'sea'];

        // 1. 从空间网格获取视野范围内的所有潜在目标
        const potentialTargets = spatialGrid.getNearbyWithRadius(this, minDistance);
        
        for (const target of potentialTargets) {
            if (target.owner === this.owner || target.hp <= 0) continue;
            
            // 检查单位类型是否可攻击
            if (target instanceof Unit && !validTargetTypes.includes(target.stats.moveType)) continue;

            const distance = getDistance(this, target);
            if (distance < minDistance) {
                minDistance = distance;
                closestTarget = target;
            }
        }

        // 2. 如果没有找到单位，再检查基地
        if (!closestTarget && enemyBase && enemyBase.hp > 0 && validTargetTypes.includes('ground')) {
            const distanceToBase = getDistance(this, {x: enemyBase.pixelX, y: enemyBase.pixelY});
            if (distanceToBase < minDistance) {
                closestTarget = enemyBase;
            }
        }
        
        this.target = closestTarget;
    }
    
    /**
     * 执行攻击，创建一个弹道对象。
     * @param {Game} game - 游戏主对象。
     */
    attack(game) {
        if (!this.target || !this.stats.ammoType) return;
        
        const pStats = {
            damage: this.stats.attack,
            ammoType: this.stats.ammoType,
            ammoSpeed: this.stats.ammoSpeed,
            splashRadius: this.stats.ammoSplashRadius,
        };
        const projectile = new Projectile(this.owner, { x: this.x, y: this.y }, this.target, pStats);
        game.projectiles.push(projectile);
        
        this.attackCooldown = this.stats.attackSpeed;
    }

    /**
     * 单位承受伤害。
     * @param {number} amount - 伤害值。
     */
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) this.hp = 0;
    }

    /**
     * 路径平滑处理：从路径的末端向前查找，找到第一个与当前位置无障碍的节点作为下一个目标点。
     * 这可以避免单位严格按照格子中心点移动，使移动轨迹更自然。
     * @param {GameMap} map - 地图对象。
     */
    findSmoothedPathTarget(map) {
        if (!this.path || this.path.length === 0 || this.currentPathIndex >= this.path.length) return;
        
        // 从路径终点向前搜索
        for (let i = this.path.length - 1; i > this.currentPathIndex; i--) {
            const node = this.path[i];
            const targetPos = { x: node.x * TILE_SIZE + TILE_SIZE / 2, y: node.y * TILE_SIZE + TILE_SIZE / 2 };
            if (isLineOfSightClear(this, targetPos, map, this.stats.moveType)) {
                this.moveTargetPos = targetPos;
                this.currentPathIndex = i;
                return;
            }
        }
        
        // 如果无法拉直路径，则移动到下一个节点
        const nextNode = this.path[this.currentPathIndex];
        if (nextNode) {
            this.moveTargetPos = { x: nextNode.x * TILE_SIZE + TILE_SIZE / 2, y: nextNode.y * TILE_SIZE + TILE_SIZE / 2 };
        }
    }
}
```

---

### `utils.js`
```javascript
// js/utils.js

/**
 * @file 存放通用的辅助函数。
 */

/**
 * 计算两点之间的欧几里得距离。
 * @param {{x: number, y: number}} p1 - 第一个点。
 * @param {{x: number, y: number}} p2 - 第二个点。
 * @returns {number} - 两点间的距离。
 */
export function getDistance(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
}
```好的，我已经仔细审查了您提供的所有JavaScript代码。这是一款功能相当完善的RTS游戏原型，尤其是在性能优化方面（如空间网格）和视觉效果方面（如新的爆炸和地形混合）做得很好。

根据您的要求，我对所有代码进行了重构和优化，主要目标是**提升代码整洁度、可读性，并统一注释风格**。以下是我的主要工作：

1.  **统一JSDoc注释**：为几乎所有的类、方法和复杂函数添加了标准的JSDoc注释。这不仅解释了代码的功能，还明确了参数和返回值，非常有利于未来的维护和团队协作。
2.  **代码格式化**：统一了缩进、空格和换行，使整体代码风格保持一致。特别是一些冗长的单行代码被重构为更易读的多行结构。
3.  **优化注释内容**：将原来的 "核心修复"、"性能革命" 等开发过程中的标记，转化为对“**为什么**”和“**如何做**”的清晰解释，让任何接手的人都能快速理解代码的设计意图。
4.  **提升代码可读性**：
    *   在`game.js`等核心类中，对构造函数里的属性进行了逻辑分组。
    *   对一些复杂的逻辑块（如`game.js`中的事件处理）增加了空行和注释，使其结构更清晰。
    *   保持了您原有的优秀命名和代码结构。

以下是经过优化和注释后的完整代码。

---

### `ai.js`
```javascript
// js/ai.js

import { UNIT_TYPES } from './config.js';
import { Unit } from './unit.js';
import { getDistance } from './utils.js';
import { Base } from './base.js';

/**
 * @class AIController
 * @description 管理AI玩家的宏观战略和微观操作。
 */
export class AIController {
    /**
     * @param {Player} player - AI所属的玩家对象。
     * @param {string} difficulty - AI难度 ('medium', 'hard', 'hell')。
     */
    constructor(player, difficulty) {
        this.player = player;
        this.difficulty = difficulty;
        
        // 宏观决策计时器
        this.macroTimer = 0; 
        this.macroInterval = 2.0; // 每2秒执行一次宏观决策
        
        // 微操计时器 (主要用于地狱难度)
        this.microTimer = 0;
        this.microInterval = 0.5; // 每0.5秒执行一次微操

        this.attackWave = []; // 当前的进攻波次单位
        this.playerBase = null; // 玩家基地的引用
    }

    /**
     * 在游戏开始时部署初始单位。
     * @param {number} mapWidth - 地图宽度（格子数）。
     * @param {number} mapHeight - 地图高度（格子数）。
     * @param {number} TILE_SIZE - 瓦片尺寸（像素）。
     */
    deployUnits(mapWidth, mapHeight, TILE_SIZE) {
        const deployableUnits = Object.keys(UNIT_TYPES);
        let manpowerToSpend = this.player.manpower;

        // 高难度下，初始资源花费打折扣，以制造更多单位
        if (this.difficulty === 'hard' || this.difficulty === 'hell') {
            manpowerToSpend *= 0.7;
        }

        let spentManpower = 0;
        let attempts = 0;
        const maxAttempts = deployableUnits.length * 3; // 防止因买不起任何单位而死循环

        while (spentManpower < manpowerToSpend && attempts < maxAttempts) {
            const unitType = deployableUnits[Math.floor(Math.random() * deployableUnits.length)];
            const cost = UNIT_TYPES[unitType].cost;

            if (this.player.canAfford(cost)) {
                // 在地图右侧三分之一区域随机部署
                const x = mapWidth * TILE_SIZE - (Math.random() * mapWidth / 3 * TILE_SIZE);
                const y = Math.random() * mapHeight * TILE_SIZE;
                const newUnit = new Unit(unitType, 'ai', x, y);
                this.player.units.push(newUnit);
                
                this.player.deductManpower(cost);
                spentManpower += cost;
                attempts = 0; // 成功部署后重置尝试次数
            } else {
                attempts++;
            }
        }
    }

    /**
     * AI的核心更新循环。
     * @param {Array<Unit>} aiUnits - AI的所有单位。
     * @param {Array<Unit>} playerUnits - 玩家的所有单位。
     * @param {GameMap} map - 游戏地图对象。
     * @param {number} deltaTime - 帧时间差。
     * @param {SpatialGrid} spatialGrid - 用于高效索敌的空间网格。
     */
    update(aiUnits, playerUnits, map, deltaTime, spatialGrid) {
        if (playerUnits.length === 0 && (!this.playerBase || this.playerBase.hp <= 0)) return;

        this.macroTimer += deltaTime;
        this.microTimer += deltaTime;

        // 基础微操：所有单位自主索敌 (所有难度)
        // 使用空间网格可以极大提升索敌效率
        this.runSimpleLogic(aiUnits, spatialGrid);

        // 宏观决策：根据难度和时间间隔执行
        if (this.macroTimer >= this.macroInterval) {
            switch (this.difficulty) {
                case 'medium':
                    this.runMediumLogic(aiUnits, playerUnits, map);
                    break;
                case 'hard':
                case 'hell':
                    this.runHardLogic(aiUnits, playerUnits, map);
                    break;
            }
            this.macroTimer = 0;
        }
        
        // 地狱难度下的高频集火微操
        if (this.difficulty === 'hell' && this.microTimer >= this.microInterval) {
            this.runHellMicro(aiUnits, playerUnits);
            this.microTimer = 0;
        }
    }

    /**
     * 基础AI逻辑：让空闲单位使用空间网格自主寻找最近的敌人。
     * @param {Array<Unit>} aiUnits - AI的所有单位。
     * @param {SpatialGrid} spatialGrid - 空间网格。
     */
    runSimpleLogic(aiUnits, spatialGrid) {
        aiUnits.forEach(unit => {
            // 如果单位空闲 (没有目标，没有路径) 且索敌冷却完毕
            if (!unit.target && unit.path.length === 0 && unit.findTargetCooldown <= 0) {
                 // 使用新的索敌函数，它内部通过空间网格高效查找
                unit.findTarget(this.playerBase, spatialGrid);
            }
        });
    }

    /**
     * 中等难度逻辑：组织小型波次进攻玩家基地。
     * @param {Array<Unit>} aiUnits - AI的所有单位。
     * @param {Array<Unit>} playerUnits - 玩家的所有单位。
     * @param {GameMap} map - 游戏地图对象。
     */
    runMediumLogic(aiUnits, playerUnits, map) {
        if (!this.playerBase || this.playerBase.hp <= 0) return;

        const livingAttackWave = this.attackWave.filter(u => u.hp > 0);

        // 如果进攻波次单位少于3个，则从空闲单位中补充
        if (livingAttackWave.length < 3) {
            this.attackWave = aiUnits.filter(u => !u.target && u.path.length === 0).slice(0, 5); 
        }
        
        // 命令波次中的单位向玩家基地移动
        const targetPoint = { x: this.playerBase.pixelX, y: this.playerBase.pixelY };
        this.attackWave.forEach(unit => {
            if (unit.hp > 0 && !unit.target && unit.path.length === 0) {
                 unit.issueMoveCommand(targetPoint, map); 
            }
        });
    }

    /**
     * 困难/地狱难度逻辑：优先攻击高价值目标，其次攻击基地。
     * @param {Array<Unit>} aiUnits - AI的所有单位。
     * @param {Array<Unit>} playerUnits - 玩家的所有单位。
     * @param {GameMap} map - 游戏地图对象。
     */
    runHardLogic(aiUnits, playerUnits, map) {
        let priorityTarget = null;
        
        // 定义高价值目标的类型顺序
        const targetPriorities = ['howitzer', 'sniper', 'sam_launcher', 'destroyer'];
        for (const type of targetPriorities) {
            priorityTarget = playerUnits.find(pUnit => pUnit.type === type && pUnit.hp > 0);
            if (priorityTarget) break;
        }

        // 如果没有高价值目标，则以玩家基地为目标
        if (!priorityTarget && this.playerBase && this.playerBase.hp > 0) {
            priorityTarget = this.playerBase;
        }

        // 如果找到目标，则组织波次进攻
        if (priorityTarget) {
            const livingAttackWave = this.attackWave.filter(u => u.hp > 0);
            if (livingAttackWave.length < 4) {
                 this.attackWave = aiUnits.filter(u => !u.target && u.path.length === 0).slice(0, 6);
            }

            this.attackWave.forEach(unit => {
                if (unit.hp > 0) {
                    unit.target = priorityTarget;
                }
            });
        }
    }

    /**
     * 地狱难度微操：所有单位集火当前血量最少的敌方单位。
     * @param {Array<Unit>} aiUnits - AI的所有单位。
     * @param {Array<Unit>} playerUnits - 玩家的所有单位。
     */
    runHellMicro(aiUnits, playerUnits) {
        if (playerUnits.length === 0) return;

        // 找到血量最低的玩家单位
        const weakestPlayerUnit = playerUnits.reduce((weakest, unit) => {
            return (unit.hp < weakest.hp) ? unit : weakest;
        }, playerUnits[0]);

        // 命令射程内的所有AI单位攻击该目标
        if (weakestPlayerUnit) {
            aiUnits.forEach(aiUnit => {
                const dist = getDistance(aiUnit, weakestPlayerUnit);
                if (dist <= aiUnit.stats.range) {
                    aiUnit.target = weakestPlayerUnit;
                }
            });
        }
    }
}
```

---

### `base.js`
```javascript
// js/base.js

import { TILE_SIZE } from './config.js';

/**
 * @class Base
 * @description 代表玩家或AI的主基地。
 */
export class Base {
    /**
     * @param {string} owner - 基地所有者 ('player' or 'ai')。
     * @param {number} gridX - 基地左上角的格子X坐标。
     * @param {number} gridY - 基地左上角的格子Y坐标。
     */
    constructor(owner, gridX, gridY) {
        this.owner = owner;
        this.gridX = gridX;
        this.gridY = gridY;
        this.width = 3;  // 格子宽度
        this.height = 3; // 格子高度
        
        this.maxHp = 2500;
        this.hp = this.maxHp;

        // 预计算像素中心点，用于单位寻路和索敌
        this.pixelX = (gridX + this.width / 2) * TILE_SIZE;
        this.pixelY = (gridY + this.height / 2) * TILE_SIZE;
    }

    /**
     * 使基地承受伤害。
     * @param {number} amount - 伤害量。
     */
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp < 0) {
            this.hp = 0;
        }
        console.log(`${this.owner}'s base took ${amount} damage, remaining HP: ${this.hp}`);
    }

    /**
     * 在Canvas上绘制基地的生命条。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {number} [zoom=1] - 当前镜头缩放级别。
     */
    draw(ctx, zoom = 1) {
        const barWidth = this.width * TILE_SIZE;
        const barHeight = 10;
        const barX = this.gridX * TILE_SIZE;
        const barY = this.gridY * TILE_SIZE - barHeight - 5; // 在基地地块上方显示

        // 绘制血条背景
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // 绘制当前血量
        ctx.fillStyle = this.owner === 'player' ? 'cyan' : 'red';
        ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight);
        
        // 绘制血条边框
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1 / zoom; // 边框宽度不受缩放影响
        ctx.strokeRect(barX, barY, barWidth, barHeight);
    }
}
```

---

### `config.js`
```javascript
// js/config.js

/**
 * @file 存放游戏的核心配置和常量。
 */

// 基础尺寸定义
export const TILE_SIZE = 32; // 每个地图格子的像素尺寸

// 游戏速度定义
export const GAME_SPEEDS = {
    '0.5': 2,    // 慢速
    '1': 1,      // 正常
    '1.5': 0.66  // 快速
};

// 地形定义
export const TERRAIN_TYPES = {
    // key: 地形ID
    // name: 显示名称
    // color: 地图基础颜色
    // traversableBy: 允许通行的移动类型数组 ('ground', 'sea', 'air', 'amphibious')
    // priority: 渲染混合效果时的优先级，高优先级会覆盖低优先级
    // defenseBonus: (可选) 此地形提供的防御加成 (未使用)
    grass: { name: '草地', color: '#7CFC00', traversableBy: ['ground', 'amphibious'], priority: 1 },
    forest: { name: '森林', color: '#228B22', defenseBonus: 0.2, traversableBy: ['ground', 'amphibious'], priority: 2 },
    road: { name: '马路', color: '#696969', traversableBy: ['ground', 'amphibious'], priority: 4 },
    water: { name: '海洋', color: '#1E90FF', traversableBy: ['air', 'sea', 'amphibious'], priority: 3 },
    building: { name: '建筑', color: '#A9A9A9', defenseBonus: 0.3, traversableBy: [], priority: 0 },
    base: { name: '基地', color: '#FFD700', defenseBonus: 0.1, traversableBy: ['ground', 'amphibious', 'air'], priority: 0 }
};

// 单位定义
export const UNIT_TYPES = {
    // --- 步兵 ---
    assault_infantry: {
        unitClass: '步兵', icon: '👨‍✈️', name: '突击步兵',
        cost: 1, hp: 100, attack: 15, defense: 5, range: 4 * TILE_SIZE, speed: 1.5 * TILE_SIZE, attackSpeed: 1.2, visionRange: 4 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/assault_infantry.png', drawScale: 1.5,
        ammoType: 'bullet', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0,
        description: '基础作战单位，廉价且灵活。'
    },
    sniper: {
        unitClass: '步兵', icon: '🎯', name: '狙击手',
        cost: 3, hp: 70, attack: 50, defense: 0, range: 9 * TILE_SIZE, speed: 1.2 * TILE_SIZE, attackSpeed: 4.0, visionRange: 9 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/sniper.png', drawScale: 1.5,
        ammoType: 'bullet', ammoSpeed: 30 * TILE_SIZE, ammoSplashRadius: 0, special: 'SETUP_TO_FIRE', 
        description: '超远射程，对步兵单位造成巨大威胁，但自身脆弱。'
    },
    anti_tank_trooper: {
        unitClass: '步兵', icon: '🚀', name: '反坦克兵',
        cost: 2, hp: 90, attack: 25, defense: 5, range: 5 * TILE_SIZE, speed: 1.3 * TILE_SIZE, attackSpeed: 2.5, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/anti_tank_trooper.png', drawScale: 1.5,
        ammoType: 'shell', ammoSpeed: 12 * TILE_SIZE, ammoSplashRadius: 0.5 * TILE_SIZE, counters: { armor: 1.8 },
        description: '携带火箭筒，能有效对抗敌方装甲单位。'
    },
    // --- 装甲 ---
    main_battle_tank: {
        unitClass: '装甲', icon: 'T', name: '主战坦克',
        cost: 5, hp: 400, attack: 50, defense: 35, range: 6 * TILE_SIZE, speed: 1.1 * TILE_SIZE, attackSpeed: 2.2, visionRange: 6 * TILE_SIZE * 1.5,
        moveType: 'ground', unitType: 'armor', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/main_battle_tank.png', drawScale: 3,
        ammoType: 'shell', ammoSpeed: 8 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: '战场中坚，攻防兼备，是地面推进的核心力量。'
    },
    light_tank: {
        unitClass: '装甲', icon: 't', name: '轻型坦克',
        cost: 3, hp: 250, attack: 30, defense: 20, range: 5 * TILE_SIZE, speed: 1.8 * TILE_SIZE, attackSpeed: 1.8, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'ground', unitType: 'armor', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/light_tank.png', drawScale: 3,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0,
        description: '机动性更强，适合侦察和快速穿插。'
    },
    amphibious_tank: {
        unitClass: '装甲', icon: 'A', name: '两栖坦克',
        cost: 4, hp: 300, attack: 35, defense: 25, range: 5 * TILE_SIZE, speed: 1.2 * TILE_SIZE, attackSpeed: 2.0, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'amphibious', unitType: 'armor', canTarget: ['ground', 'sea','amphibious','sea'], imageSrc: 'assets/pics/amphibious_tank.png', drawScale: 3,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0,
        description: '可以穿越水域和陆地，用于登陆作战。'
    },
    // --- 飞行 ---
    fighter_jet: {
        unitClass: '飞行', icon: '✈️', name: '战斗机',
        cost: 6, hp: 200, attack: 60, defense: 10, range: 8 * TILE_SIZE, speed: 5.0 * TILE_SIZE, attackSpeed: 2.0, visionRange: 8 * TILE_SIZE * 1.5,
        moveType: 'air', canTarget: ['air','sea'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0, counters: { air: 1.8 },
        description: '夺取制空权的王者，专门猎杀敌方飞行单位。'
    },
    attack_helicopter: {
        unitClass: '飞行', icon: '🚁', name: '攻击直升机',
        cost: 5, hp: 250, attack: 40, defense: 15, range: 7 * TILE_SIZE, speed: 3.0 * TILE_SIZE, attackSpeed: 1.8, visionRange: 7 * TILE_SIZE * 1.5,
        moveType: 'air', unitType: 'air', canTarget: ['ground', 'sea','amphibious'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0, counters: { armor: 1.4 },
        description: '低空盘旋的坦克杀手，为地面部队提供火力支援。'
    },
    recon_drone: {
        unitClass: '飞行', icon: '🛰️', name: '无人侦察机',
        cost: 2, hp: 50, attack: 0, defense: 0, range: 0, speed: 4.0 * TILE_SIZE, attackSpeed: 99, visionRange: 0, // 视野由战争迷雾系统单独处理
        moveType: 'air', unitType: 'air', canTarget: [], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: null, ammoSpeed: 0, ammoSplashRadius: 0,
        description: '廉价的空中侦察单位，移动速度快，视野范围广。'
    },
    // --- 炮兵 ---
    howitzer: {
        unitClass: '炮兵', icon: '💣', name: '榴弹炮',
        cost: 6, hp: 120, attack: 100, defense: 5, range: 12 * TILE_SIZE, speed: 0.8 * TILE_SIZE, attackSpeed: 5.0, visionRange: 12 * TILE_SIZE * 1.5,
        moveType: 'ground', special: 'SETUP_TO_FIRE', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/howitzer.png', drawScale: 4,
        ammoType: 'shell', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: '超远程地面压制火力，但需要部署才能开火。'
    },
    sam_launcher: {
        unitClass: '炮兵', icon: '🗼', name: '防空炮',
        cost: 5, hp: 150, attack: 80, defense: 10, range: 10 * TILE_SIZE, speed: 1.0 * TILE_SIZE, attackSpeed: 0.4, visionRange: 10 * TILE_SIZE * 1.5,
        moveType: 'ground', special: 'SETUP_TO_FIRE', canTarget: ['air'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'shell', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0.5 * TILE_SIZE,
        description: '远程防空武器，对战斗机和轰炸机是致命威胁。'
    },
    // --- 海军 ---
    destroyer: {
        unitClass: '海军', icon: '🚢', name: '驱逐舰',
        cost: 8, hp: 600, attack: 70, defense: 30, range: 9 * TILE_SIZE, speed: 1.5 * TILE_SIZE, attackSpeed: 2.8, visionRange: 9 * TILE_SIZE * 1.5,
        moveType: 'sea', canTarget: ['ground', 'sea', 'air'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 30 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: '功能全面的主力战舰，可以攻击来自海陆空的任何敌人。'
    },
    submarine: {
        unitClass: '海军', icon: '🌊', name: '潜艇',
        cost: 7, hp: 400, attack: 90, defense: 15, range: 8 * TILE_SIZE, speed: 1.8 * TILE_SIZE, attackSpeed: 3.5, visionRange: 8 * TILE_SIZE * 1.5,
        moveType: 'undersea', canTarget: ['sea'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0,
        description: '水下杀手，擅长对敌方潜艇和潜水船进行攻击。'
    },
};
```

---

### `game.js`
```javascript
// js/game.js

import { TILE_SIZE, UNIT_TYPES, GAME_SPEEDS, TERRAIN_TYPES } from './config.js';
import { MAP_DEFINITIONS } from './maps-data.js';
import { GameMap } from './map.js';
import { Unit } from './unit.js';
import { Player } from './player.js';
import { UI } from './ui.js';
import { Base } from './base.js';
import { getDistance } from './utils.js';
import { Projectile, Explosion } from './projectile.js';
import { findPath } from './pathfinding.js';
import { FogOfWar } from './fog-of-war.js';
import { SpatialGrid } from './spatial-grid.js';

/**
 * @class Game
 * @description 游戏的主控制器，负责管理游戏状态、主循环、渲染和用户输入。
 */
export class Game {
    /**
     * @param {HTMLCanvasElement} canvas - 游戏渲染的Canvas元素。
     */
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        // 游戏状态管理
        this.gameState = 'setup'; // 'setup', 'deployment', 'playing', 'gameover'
        this.gameMode = 'annihilation';
        this.lastTime = 0;
        this.gameSpeedModifier = 1;
        this.showDetails = false; // 是否显示单位详细信息（如射程圈）
        
        // 游戏世界对象
        this.map = null;
        this.player = null;
        this.ai = null;
        this.playerBase = null;
        this.aiBase = null;
        this.fogOfWar = null;
        this.spatialGrid = null; // 核心性能优化：空间网格
        
        // 动态实体数组
        this.projectiles = [];
        this.explosions = [];
        this.selectedUnits = [];
        
        // 输入和镜头控制
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };
        this.dragEnd = { x: 0, y: 0 };
        this.mousePos = { x: 0, y: 0 };
        this.globalMousePos = { x: 0, y: 0 }; // 鼠标在窗口中的位置，用于边缘滚动
        this.isDraggingMap = false;
        this.lastDragPos = { x: 0, y: 0 };
        this.camera = { x: 0, y: 0, zoom: 1, minZoom: 0.5, maxZoom: 2.5 };
        
        // 触摸控制
        this.activeTouches = new Map();
        this.lastTouchDistance = 0;
        this.lastTouchCenter = null;
    }

    /**
     * 初始化游戏。
     * @param {object} settings - 从设置界面传入的游戏配置。
     */
    init(settings) {
        this.gameMode = settings.gameMode;
        this.showDetails = settings.showDetails;
        this.fromDialogue = settings.fromDialogue || false;
        this.user = settings.user || null;
        
        // 加载地图
        const selectedMapData = MAP_DEFINITIONS.find(m => m.id === settings.mapId);
        this.map = new GameMap();
        this.map.load(selectedMapData);

        const mapWidthPixels = this.map.width * TILE_SIZE;
        const mapHeightPixels = this.map.height * TILE_SIZE;
        
        // 初始化性能优化模块
        // 空间网格的单元格尺寸通常设置为最大单位视野范围左右，以保证一次查询就能覆盖邻居
        const gridCellSize = TILE_SIZE * 15; 
        this.spatialGrid = new SpatialGrid(mapWidthPixels, mapHeightPixels, gridCellSize);
        this.fogOfWar = new FogOfWar(mapWidthPixels, mapHeightPixels);
        
        // 根据游戏模式创建基地
        const baseGridY = Math.floor(this.map.height / 2) - 1; 
        if (this.gameMode === 'annihilation' || this.gameMode === 'defend') {
            this.playerBase = new Base('player', 6, baseGridY);
            this.placeBaseOnMap(this.playerBase);
        }
        if (this.gameMode === 'annihilation' || this.gameMode === 'attack') {
            this.aiBase = new Base('ai', this.map.width - 9, baseGridY);
            this.placeBaseOnMap(this.aiBase);
        }

        // 创建玩家和AI
        const initialManpower = 100;
        this.player = new Player('player', '玩家', initialManpower);
        const aiManpower = settings.aiDifficulty === 'hell' ? Math.round(initialManpower * 1.5) : initialManpower;
        this.ai = new Player('ai', '电脑', aiManpower, true, {}, settings.aiDifficulty);
        
        // 链接AI控制器和玩家基地
        this.ai.aiController.playerBase = this.playerBase;
        this.ai.aiController.deployUnits(this.map.width, this.map.height, TILE_SIZE);
        
        this.ui = new UI(this);
        this.gameSpeedModifier = GAME_SPEEDS[settings.gameSpeed];
        this.gameState = 'deployment';
        
        this.addEventListeners();
        this.setupInitialCamera();
        
        window.game = this; // 方便调试
        requestAnimationFrame(this.gameLoop.bind(this));
    }
    
    /**
     * 设置初始镜头位置，聚焦于玩家基地或地图中心。
     */
    setupInitialCamera() {
        this.camera.zoom = 1.2;
        let focusPoint = this.playerBase 
            ? { x: this.playerBase.pixelX, y: this.playerBase.pixelY }
            : { x: (this.map.width * TILE_SIZE) / 2, y: (this.map.height * TILE_SIZE) / 2 };
        
        this.camera.x = focusPoint.x - (this.canvas.width / 2) / this.camera.zoom;
        this.camera.y = focusPoint.y - (this.canvas.height / 2) / this.camera.zoom;
        
        this.constrainCamera();
    }
    
    /**
     * 游戏主循环。
     * @param {number} currentTime - `requestAnimationFrame` 传入的时间戳。
     */
    gameLoop(currentTime) {
        if (!this.lastTime) this.lastTime = currentTime;
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;
        
        const adjustedDeltaTime = deltaTime / this.gameSpeedModifier;
        
        this.update(adjustedDeltaTime);
        this.draw();
        this.ui.update();
        
        requestAnimationFrame(this.gameLoop.bind(this));
    }

    /**
     * 更新所有游戏逻辑。
     * @param {number} deltaTime - 经过游戏速度调整后的帧时间差。
     */
    update(deltaTime) {
        if (this.gameState === 'gameover' || this.gameState === 'setup') return;

        this.handleEdgeScrolling(deltaTime);
        this.constrainCamera();

        const allPlayerUnits = this.player.units;
        const allAiUnits = this.ai.units;
        const allUnits = [...allPlayerUnits, ...allAiUnits];
        
        // 性能优化：每帧清空并重新插入所有单位到空间网格
        this.spatialGrid.clear();
        allUnits.forEach(unit => this.spatialGrid.insert(unit));
        
        if (this.gameState === 'playing' || this.gameState === 'deployment') {
            // 更新单位逻辑，并传入空间网格用于高效索敌
            allPlayerUnits.forEach(unit => unit.update(deltaTime, allAiUnits, this.map, this.aiBase, this, this.spatialGrid));
            allAiUnits.forEach(unit => unit.update(deltaTime, allPlayerUnits, this.map, this.playerBase, this, this.spatialGrid));
            
            // AI玩家的宏观更新
            if (this.gameState === 'playing') {
                 this.ai.update(deltaTime, this.player, this.map, this.spatialGrid);
            }
        }
        
        // 更新物理（碰撞）和弹道
        this.updatePhysics(deltaTime, allUnits);
        this.updateProjectiles(deltaTime);

        // 清理死亡单位和过期的特效
        this.explosions = this.explosions.filter(e => !e.update(deltaTime));
        this.player.units = this.player.units.filter(u => u.hp > 0);
        this.ai.units = this.ai.units.filter(u => u.hp > 0);
        this.selectedUnits = this.selectedUnits.filter(u => u.hp > 0);
        
        // 更新战争迷雾
        const visionSources = [...this.player.units, this.playerBase].filter(Boolean);
        this.fogOfWar.update(visionSources);

        if (this.gameState === 'playing') {
            this.checkWinConditions();
        }
    }

    /**
     * 渲染所有可见的游戏元素。
     */
    draw() {
        // 清屏
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.save();
        
        // 应用镜头变换
        this.ctx.scale(this.camera.zoom, this.camera.zoom);
        this.ctx.translate(-this.camera.x, -this.camera.y);

        // 性能优化：计算镜头可见范围，只绘制范围内的物体 (Culling)
        const viewBounds = {
            left: this.camera.x,
            top: this.camera.y,
            right: this.camera.x + this.canvas.width / this.camera.zoom,
            bottom: this.camera.y + this.canvas.height / this.camera.zoom
        };
        const isVisible = (entity, padding = TILE_SIZE * 2) => {
            const x = entity.pixelX || entity.x;
            const y = entity.pixelY || entity.y;
            return x > viewBounds.left - padding && x < viewBounds.right + padding &&
                   y > viewBounds.top - padding && y < viewBounds.bottom + padding;
        };

        // 按层级绘制
        this.map.draw(this.ctx, this.camera);
        if (this.playerBase) this.playerBase.draw(this.ctx, this.camera.zoom);
        if (this.aiBase) this.aiBase.draw(this.ctx, this.camera.zoom);

        const allUnits = [...this.player.units, ...this.ai.units];
        const groundSeaUnits = allUnits.filter(u => u.stats.moveType !== 'air');
        const airUnits = allUnits.filter(u => u.stats.moveType === 'air');

        // 1. 绘制地面/海上单位
        groundSeaUnits.forEach(unit => {
            if (isVisible(unit)) {
                unit.draw(this.ctx, this.selectedUnits.includes(unit), this.camera.zoom, this.showDetails);
            }
        });
        
        // 2. 绘制弹道和爆炸
        this.projectiles.forEach(p => { if(isVisible(p)) p.draw(this.ctx); });
        this.explosions.forEach(e => { if(isVisible(e)) e.draw(this.ctx); });
        
        // 3. 绘制空中单位（确保在弹道之上）
        airUnits.forEach(unit => {
             if (isVisible(unit)) {
                unit.draw(this.ctx, this.selectedUnits.includes(unit), this.camera.zoom, this.showDetails);
            }
        });

        // 4. 绘制战争迷雾
        this.fogOfWar.draw(this.ctx);

        this.ctx.restore();
        
        // 绘制UI元素（如选择框），不受镜头影响
        if (this.isDragging && !this.isDraggingMap) {
            this.ctx.strokeStyle = 'rgba(100, 255, 100, 0.7)';
            this.ctx.lineWidth = 1;
            const rect = { 
                x: Math.min(this.dragStart.x, this.dragEnd.x), 
                y: Math.min(this.dragStart.y, this.dragEnd.y),
                w: Math.abs(this.dragStart.x - this.dragEnd.x),
                h: Math.abs(this.dragStart.y - this.dragEnd.y)
            };
            this.ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
        }
    }
    
    /**
     * 更新弹道逻辑，处理命中和销毁。
     * @param {number} deltaTime - 帧时间差。
     */
    updateProjectiles(deltaTime) {
        const remainingProjectiles = [];
        for (const p of this.projectiles) {
            if (!p.update(deltaTime)) { // update返回true表示弹道生命周期结束
                remainingProjectiles.push(p);
            } else {
                this.handleProjectileHit(p);
            }
        }
        this.projectiles = remainingProjectiles;
    }

    /**
     * 核心重构: 使用空间网格进行高效的物理碰撞检测。
     * 避免了 O(n^2) 的全局遍历，显著提升单位多时的性能。
     * @param {number} deltaTime - 帧时间差。
     * @param {Array<Unit>} allUnits - 场景中的所有单位。
     */
    updatePhysics(deltaTime, allUnits) {
        const PUSH_FORCE = 30;
        const processedPairs = new Set(); // 防止A-B和B-A重复计算

        for (const unitA of allUnits) {
            // 从空间网格获取附近的单位，而不是遍历所有单位
            const nearbyUnits = this.spatialGrid.getNearby(unitA);
            
            for (const unitB of nearbyUnits) {
                if (unitA.id === unitB.id) continue;

                // 使用ID组合来唯一标识一对单位，避免重复处理
                const pairKey = unitA.id < unitB.id ? `${unitA.id}-${unitB.id}` : `${unitB.id}-${unitA.id}`;
                if (processedPairs.has(pairKey)) continue;
                processedPairs.add(pairKey);

                // 空中单位和非空中单位之间不发生碰撞
                const isAirA = unitA.stats.moveType === 'air';
                const isAirB = unitB.stats.moveType === 'air';
                if (isAirA !== isAirB) {
                    continue;
                }

                const distance = getDistance(unitA, unitB);
                // 使用更精确的半径进行碰撞检测
                const collisionRadius = (unitA.stats.drawScale + unitB.stats.drawScale) / 2 * (TILE_SIZE / 4);
                
                if (distance > 0 && distance < collisionRadius) {
                    const overlap = collisionRadius - distance;
                    const angle = Math.atan2(unitB.y - unitA.y, unitB.x - unitA.x);
                    
                    // 根据重叠程度和deltaTime计算推开的量
                    const pushAmount = overlap * PUSH_FORCE * deltaTime;
                    const pushX = Math.cos(angle) * pushAmount;
                    const pushY = Math.sin(angle) * pushAmount;
                    
                    // 两个单位各推开一半
                    unitA.x -= pushX * 0.5;
                    unitA.y -= pushY * 0.5;
                    unitB.x += pushX * 0.5;
                    unitB.y += pushY * 0.5;
                }
            }
        }
    }

    // --- 事件监听与处理 ---
    
    addEventListeners() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        window.addEventListener('keydown', (e) => { 
            if (e.key === 'Escape') {
                this.selectedUnits = [];
                this.ui.clearDeploymentSelection();
            }
        });
        
        // 触摸事件
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
        this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
    }

    handleMouseDown(e) {
        const pos = this.getMousePos(e);
        // 左键或中键拖动地图
        if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
            this.isDraggingMap = true;
            this.lastDragPos = { x: e.clientX, y: e.clientY };
            this.canvas.style.cursor = 'grabbing';
        } 
        // 左键开始选择
        else if (e.button === 0) {
            this.isDragging = true;
            this.dragStart = pos;
            this.dragEnd = pos;
        }
    }

    handleMouseMove(e) {
        this.mousePos = this.getMousePos(e);
        this.globalMousePos = { x: e.clientX, y: e.clientY };
        
        if (this.isDraggingMap) {
            const dx = e.clientX - this.lastDragPos.x;
            const dy = e.clientY - this.lastDragPos.y;
            this.camera.x -= dx / this.camera.zoom;
            this.camera.y -= dy / this.camera.zoom;
            this.lastDragPos = { x: e.clientX, y: e.clientY };
        } else if (this.isDragging) {
            this.dragEnd = this.mousePos;
        }
    }

    handleMouseUp(e) {
        // 右键命令
        if (e.button === 2) {
            const pos = this.getMousePos(e);
            this.handleRightClick(this.screenToWorld(pos.x, pos.y));
            return;
        }

        if (this.isDraggingMap) {
            this.isDraggingMap = false;
            this.canvas.style.cursor = 'default';
        } else if (this.isDragging) {
            this.isDragging = false;
            const pos = this.getMousePos(e);
            
            // 如果拖动距离很小，视为单击
            if (getDistance(this.dragStart, pos) < 10) {
                this.handleLeftClick(this.screenToWorld(pos.x, pos.y));
            } else {
                this.handleBoxSelection();
            }
        }
    }
    
    /**
     * 处理左键单击事件。
     * @param {{x: number, y: number}} worldPos - 点击位置的世界坐标。
     */
    handleLeftClick(worldPos) {
        // 如果UI中选择了待部署单位，则尝试部署
        if (this.ui.selectedUnitToDeploy) {
            this.tryDeployUnit(worldPos, this.ui.selectedUnitToDeploy);
            return;
        }
        
        // 如果当前有单位被选中，则清除选择
        if (this.selectedUnits.length > 0) {
            this.issueCommandForSelectedUnits(worldPos);
            return;
        }

        // 尝试选中一个单位
        const clickedUnit = this.player.units.find(unit => getDistance(worldPos, unit) < TILE_SIZE / 2);
        this.selectedUnits = clickedUnit ? [clickedUnit] : [];
    }

    /**
     * 处理右键单击事件，为选中的单位下达命令。
     * @param {{x: number, y: number}} worldPos - 点击位置的世界坐标。
     */
    handleRightClick(worldPos) {
        if (this.selectedUnits.length > 0) {
            this.issueCommandForSelectedUnits(worldPos);
        }
    }

    /**
     * 为当前选中的单位下达移动或攻击命令。
     * @param {{x: number, y: number}} worldPos - 目标世界坐标。
     */
    issueCommandForSelectedUnits(worldPos) {
        let targetEnemy = null;
        const allEnemies = [...this.ai.units, this.aiBase].filter(Boolean);
        
        // 检查是否点中了敌人
        for (const enemy of allEnemies) {
            const enemyPos = { x: enemy.pixelX || enemy.x, y: enemy.pixelY || enemy.y };
            const clickRadius = (enemy instanceof Base) ? (enemy.width * TILE_SIZE / 2) : (TILE_SIZE / 2);
            if (getDistance(worldPos, enemyPos) < clickRadius) {
                targetEnemy = enemy;
                break;
            }
        }
        
        // 如果点中了敌人，则下达攻击命令
        if (targetEnemy) {
            this.selectedUnits.forEach(unit => unit.target = targetEnemy);
        } 
        // 否则，下达移动命令
        else {
            this.selectedUnits.forEach(unit => unit.target = null);
            if (this.selectedUnits.length === 1) {
                this.selectedUnits[0].issueMoveCommand(worldPos, this.map);
            } else {
                this.issueGroupMoveCommand(worldPos, this.map);
            }
        }
    }

    /**
     * 在指定位置部署一个单位。
     * @param {{x: number, y: number}} worldPos - 部署位置的世界坐标。
     * @param {string} unitType - 要部署的单位类型ID。
     */
    tryDeployUnit(worldPos, unitType) {
        const cost = UNIT_TYPES[unitType].cost;
        
        // 检查资源和部署区域
        if (this.player.canAfford(cost) && worldPos.x < (this.map.width * TILE_SIZE) / 3) {
            const gridX = Math.floor(worldPos.x / TILE_SIZE);
            const gridY = Math.floor(worldPos.y / TILE_SIZE);
            const tile = this.map.getTile(gridX, gridY);
            const unitStats = UNIT_TYPES[unitType];

            // 检查地形是否可通行
            const isTraversable = tile && TERRAIN_TYPES[tile.type].traversableBy.includes(unitStats.moveType);
            if (unitStats.moveType === 'air' || isTraversable) {
                this.player.units.push(new Unit(unitType, 'player', worldPos.x, worldPos.y));
                this.player.deductManpower(cost);
                this.ui.update();
            } else {
                this.ui.showGameMessage("该单位无法部署在此地形上！");
            }
        } else {
            if (!this.player.canAfford(cost)) {
                this.ui.showGameMessage("资源不足！");
            } else {
                this.ui.showGameMessage("只能在地图左侧1/3区域部署！");
            }
        }
    }

    /**
     * 处理鼠标拖拽结束后的框选逻辑。
     */
    handleBoxSelection() {
        this.ui.clearDeploymentSelection();
        this.selectedUnits = [];
        
        const rect = { 
            x: Math.min(this.dragStart.x, this.dragEnd.x), 
            y: Math.min(this.dragStart.y, this.dragEnd.y),
            w: Math.abs(this.dragStart.x - this.dragEnd.x),
            h: Math.abs(this.dragStart.y - this.dragEnd.y)
        };
        
        this.player.units.forEach(unit => {
            const screenPos = this.worldToScreen(unit.x, unit.y);
            if (screenPos.x > rect.x && screenPos.x < rect.x + rect.w && 
                screenPos.y > rect.y && screenPos.y < rect.y + rect.h) {
                this.selectedUnits.push(unit);
            }
        });
    }

    /**
     * 为多个单位下达移动命令，并保持其相对阵型。
     * @param {{x: number, y: number}} targetPos - 目标点的世界坐标。
     * @param {GameMap} map - 游戏地图。
     */
    issueGroupMoveCommand(targetPos, map) {
        if (this.selectedUnits.length === 0) return;
        
        // 计算选中单位的几何中心
        const centroid = this.selectedUnits.reduce((acc, unit) => ({ x: acc.x + unit.x, y: acc.y + unit.y }), { x: 0, y: 0 });
        centroid.x /= this.selectedUnits.length;
        centroid.y /= this.selectedUnits.length;
        
        // 计算每个单位相对于中心的偏移量
        const offsets = this.selectedUnits.map(unit => ({ dx: unit.x - centroid.x, dy: unit.y - centroid.y }));
        
        // 为每个单位设置带有偏移量的目标点
        this.selectedUnits.forEach((unit, index) => {
            const unitTargetPos = { 
                x: targetPos.x + offsets[index].dx,
                y: targetPos.y + offsets[index].dy 
            };
            unit.issueMoveCommand(unitTargetPos, map);
        });
    }

    // --- 坐标转换与镜头 ---
    
    getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        return { 
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY 
        };
    }
    
    worldToScreen(worldX, worldY) {
        return { 
            x: (worldX - this.camera.x) * this.camera.zoom,
            y: (worldY - this.camera.y) * this.camera.zoom 
        };
    }

    screenToWorld(screenX, screenY) {
        return {
            x: screenX / this.camera.zoom + this.camera.x,
            y: screenY / this.camera.zoom + this.camera.y 
        };
    }
    
    constrainCamera() {
        if (!this.map) return;
        const mapWidthPixels = this.map.width * TILE_SIZE;
        const mapHeightPixels = this.map.height * TILE_SIZE;
        const viewWidth = this.canvas.width / this.camera.zoom;
        const viewHeight = this.canvas.height / this.camera.zoom;
        
        this.camera.x = Math.max(0, Math.min(this.camera.x, mapWidthPixels - viewWidth));
        this.camera.y = Math.max(0, Math.min(this.camera.y, mapHeightPixels - viewHeight));
    }
    
    handleWheel(e) {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 1.05 : 0.95;
        this.zoomAtPoint(zoomFactor, this.getMousePos(e));
    }

    zoomAtPoint(factor, point) {
        const oldZoom = this.camera.zoom;
        const newZoom = Math.max(this.camera.minZoom, Math.min(this.camera.maxZoom, oldZoom / factor));
        if (newZoom === oldZoom) return;
        
        const worldMouseX = point.x / oldZoom + this.camera.x;
        const worldMouseY = point.y / oldZoom + this.camera.y;
        
        this.camera.zoom = newZoom;
        this.camera.x = worldMouseX - point.x / newZoom;
        this.camera.y = worldMouseY - point.y / newZoom;
    }

    // --- 触摸控制 ---

    handleTouchStart(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            this.activeTouches.set(touch.identifier, this.getTouchPos(touch));
        }
        this.updateTouchState();
    }
    
    handleTouchMove(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            this.activeTouches.set(touch.identifier, this.getTouchPos(touch));
        }
        
        const touches = Array.from(this.activeTouches.values());
        // 双指缩放和拖动
        if (touches.length === 2) {
            const currentCenter = { x: (touches[0].x + touches[1].x) / 2, y: (touches[0].y + touches[1].y) / 2 };
            const currentDistance = getDistance(touches[0], touches[1]);
            
            if (this.lastTouchCenter) {
                const dx = currentCenter.x - this.lastTouchCenter.x;
                const dy = currentCenter.y - this.lastTouchCenter.y;
                this.camera.x -= dx / this.camera.zoom;
                this.camera.y -= dy / this.camera.zoom;
            }
            if (this.lastTouchDistance > 0) {
                const zoomFactor = this.lastTouchDistance / currentDistance;
                this.zoomAtPoint(zoomFactor, currentCenter);
            }
            
            this.lastTouchCenter = currentCenter;
            this.lastTouchDistance = currentDistance;
        }
    }
    
    handleTouchEnd(e) {
        for (const touch of e.changedTouches) {
            this.activeTouches.delete(touch.identifier);
        }
        this.updateTouchState();
    }
    
    updateTouchState() {
        if (this.activeTouches.size < 2) {
            this.lastTouchDistance = 0;
            this.lastTouchCenter = null;
        }
    }
    
    getTouchPos(touch) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        return { 
            x: (touch.clientX - rect.left) * scaleX,
            y: (touch.clientY - rect.top) * scaleY 
        };
    }
    
    // --- 游戏流程 ---

    /**
     * 鼠标靠近屏幕边缘时滚动地图。
     * @param {number} deltaTime - 帧时间差。
     */
    handleEdgeScrolling(deltaTime) {
        if (this.isDraggingMap || this.isDragging || this.activeTouches.size > 0) return;
        
        const edgeMargin = 20;
        const scrollSpeed = 600 / this.camera.zoom;
        
        if (this.globalMousePos.x < edgeMargin) this.camera.x -= scrollSpeed * deltaTime;
        if (this.globalMousePos.x > window.innerWidth - edgeMargin) this.camera.x += scrollSpeed * deltaTime;
        if (this.globalMousePos.y < edgeMargin) this.camera.y -= scrollSpeed * deltaTime;
        if (this.globalMousePos.y > window.innerHeight - edgeMargin) this.camera.y += scrollSpeed * deltaTime;
    }
    
    /**
     * 处理弹道命中逻辑，包括直接伤害和溅射伤害。
     * @param {Projectile} p - 命中的弹道对象。
     */
    handleProjectileHit(p) {
        this.explosions.push(new Explosion(p.x, p.y, p.stats.splashRadius || 10));

        // 对主目标造成伤害
        if (p.target && p.target.hp > 0) {
            p.target.takeDamage(p.stats.damage);
        }

        // 处理溅射伤害
        if (p.stats.splashRadius > 0) {
            const allTargets = [...this.player.units, ...this.ai.units, this.playerBase, this.aiBase].filter(Boolean);
            allTargets.forEach(entity => {
                if (entity.owner !== p.owner && entity.id !== p.target?.id && entity.hp > 0) {
                    const entityPos = { x: entity.pixelX || entity.x, y: entity.pixelY || entity.y };
                    const distance = getDistance(entityPos, p);
                    if (distance < p.stats.splashRadius) {
                        // 伤害随距离衰减
                        const splashDamage = p.stats.damage * (1 - distance / p.stats.splashRadius);
                        entity.takeDamage(splashDamage);
                    }
                }
            });
        }
    }

    /**
     * 开始战斗，将游戏状态从 'deployment' 切换到 'playing'。
     */
    startGame() {
        if (this.gameState === 'deployment') {
            this.gameState = 'playing';
        }
    }
    
    /**
     * 检查胜利或失败条件。
     */
    checkWinConditions() {
        if (this.gameState !== 'playing') return;
        
        const minCost = Math.min(...Object.values(UNIT_TYPES).map(u => u.cost));
        const pCanDeploy = this.player.manpower >= minCost;
        const pOutOfForces = this.player.units.length === 0 && !pCanDeploy;

        switch (this.gameMode) {
            case 'annihilation': // 歼灭模式
                if (this.playerBase?.hp <= 0) this.endGame(this.ai);
                else if (this.aiBase?.hp <= 0) this.endGame(this.player);
                break;
            case 'attack': // 进攻模式
                if (this.aiBase?.hp <= 0) this.endGame(this.player);
                else if (pOutOfForces) this.endGame(this.ai);
                break;
            case 'defend': // 防守模式
                if (this.playerBase?.hp <= 0) this.endGame(this.ai);
                else if (this.ai.units.length === 0 && this.ai.manpower < minCost) this.endGame(this.player);
                break;
        }
    }

    /**
     * 结束游戏并宣布胜利者。
     * @param {Player} winner - 胜利的玩家对象。
     */
    endGame(winner) {
        if (this.gameState === 'gameover') return;
        this.gameState = 'gameover';
        console.log(`${winner.name} 获胜!`);
        this.ui.showWinner(winner.name);
        
        if (this.returnToDialogue()) {
            return;
        }
    }
    
    returnToDialogue() {
        const urlParams = new URLSearchParams(window.location.search);
        const fromDialogue = urlParams.get('fromDialogue');
        const user = urlParams.get('user');
        
        if (fromDialogue === 'true') {
            window.location.href = `./loading.html?target=dialogue.html&returnFromGame=true&user=${user}`;
            return true;
        }
        return false;
    }
    
    /**
     * 在地图上放置基地，并将其地块类型设为'base'。
     * @param {Base} base - 要放置的基地对象。
     */
    placeBaseOnMap(base) {
        for (let y = 0; y < base.height; y++) {
            for (let x = 0; x < base.width; x++) {
                this.map.setTileType(base.gridX + x, base.gridY + y, 'base');
            }
        }
    }
}
```

---

### `fog-of-war.js`
```javascript
// js/fog-of-war.js

import { TILE_SIZE } from './config.js';

/**
 * @class FogOfWar
 * @description 管理战争迷雾效果。
 * 使用一个离屏Canvas进行预渲染以提升性能。
 */
export class FogOfWar {
    /**
     * @param {number} mapWidth - 地图总像素宽度。
     * @param {number} mapHeight - 地图总像素高度。
     */
    constructor(mapWidth, mapHeight) {
        this.mapWidth = mapWidth;
        this.mapHeight = mapHeight;

        // 创建离屏Canvas用于绘制迷雾
        this.fogCanvas = document.createElement('canvas');
        this.fogCanvas.width = this.mapWidth;
        this.fogCanvas.height = this.mapHeight;
        this.fogCtx = this.fogCanvas.getContext('2d');
    }

    /**
     * 根据玩家单位和建筑的位置更新迷雾纹理。
     * 这是一个计算密集型操作，但由于在离屏Canvas上进行，不会阻塞主渲染线程。
     * @param {Array<Unit|Base>} visibleEntities - 玩家的所有单位和基地数组，用于提供视野。
     */
    update(visibleEntities) {
        const ctx = this.fogCtx;

        // 1. 先用纯黑 fog 覆盖整个地图
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, this.mapWidth, this.mapHeight);

        // 2. 使用 'destination-out' 模式在 fog 上“凿开”视野区域
        ctx.globalCompositeOperation = 'destination-out';

        visibleEntities.forEach(entity => {
            // 为单位或基地设置视野范围
            const vision = entity.stats ? entity.stats.visionRange : 10 * TILE_SIZE; // 基地默认视野
            const entityX = entity.pixelX || entity.x;
            const entityY = entity.pixelY || entity.y;
            
            // 创建一个径向渐变，实现视野边缘的平滑过渡效果
            const gradient = ctx.createRadialGradient(entityX, entityY, vision * 0.7, entityX, entityY, vision);
            gradient.addColorStop(0, 'rgba(0,0,0,1)'); // 中心完全透明
            gradient.addColorStop(1, 'rgba(0,0,0,0)'); // 边缘渐变为不透明

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(entityX, entityY, vision, 0, Math.PI * 2);
            ctx.fill();
        });

        // 重置混合模式，以备下次更新
        ctx.globalCompositeOperation = 'source-over';
    }

    /**
     * 将预渲染好的迷雾Canvas绘制到主游戏Canvas上。
     * 这是一个非常快速的图像绘制操作。
     * @param {CanvasRenderingContext2D} mainCtx - 主游戏的渲染上下文。
     */
    draw(mainCtx) {
        mainCtx.drawImage(this.fogCanvas, 0, 0);
    }
}
```

---

### `main.js`
```javascript
// js/main.js

import { Game } from './game.js';
import { MAP_DEFINITIONS } from './maps-data.js';
import { UNIT_TYPES } from './config.js';

/**
 * @class AssetManager
 * @description 一个简单的资源管理器，用于预加载图片。
 */
class AssetManager {
    constructor() {
        this.assets = {};
        this.downloadQueue = [];
        this.successCount = 0;
        this.errorCount = 0;
    }

    /**
     * 将一个图片路径添加到下载队列。
     * @param {string} path - 图片的URL。
     */
    queueDownload(path) {
        if (path && !this.downloadQueue.includes(path)) {
            this.downloadQueue.push(path);
        }
    }

    /**
     * 检查是否所有资源都已加载完成（无论成功或失败）。
     * @returns {boolean}
     */
    isDone() {
        return this.downloadQueue.length === this.successCount + this.errorCount;
    }

    /**
     * 开始下载队列中的所有资源。
     * @param {function} callback - 所有资源加载完成后调用的回调函数。
     */
    downloadAll(callback) {
        if (this.downloadQueue.length === 0) {
            callback();
            return;
        }
        
        this.downloadQueue.forEach(path => {
            const img = new Image();
            img.onload = () => {
                this.successCount++;
                if (this.isDone()) {
                    callback();
                }
            };
            img.onerror = () => {
                this.errorCount++;
                console.error("Error loading image: " + path);
                if (this.isDone()) {
                    callback();
                }
            };
            img.src = path;
            this.assets[path] = img;
        });
    }
}

// DOM加载完成后执行
window.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('game-canvas');
    const setupScreen = document.getElementById('setup-screen');
    const startNewGameBtn = document.getElementById('start-new-game-btn');
    const mapSelect = document.getElementById('map-select');
    
    // 动态填充地图选择下拉框
    MAP_DEFINITIONS.forEach(map => {
        const option = document.createElement('option');
        option.value = map.id;
        option.textContent = map.name;
        mapSelect.appendChild(option);
    });

    // 预加载所有单位图片
    const assetManager = new AssetManager();
    Object.values(UNIT_TYPES).forEach(unit => {
        assetManager.queueDownload(unit.imageSrc);
    });
    
    // 将加载好的图片存放在全局，方便游戏内其他模块访问
    window.assetManager = assetManager.assets; 
    
    startNewGameBtn.disabled = true;
    startNewGameBtn.textContent = '正在加载资源...';
    assetManager.downloadAll(() => {
        startNewGameBtn.disabled = false;
        startNewGameBtn.textContent = '创建游戏';
    });
    
    /**
     * 调整游戏Canvas尺寸以适应窗口变化。
     */
    function resizeGame() {
        const sidebar = document.getElementById('sidebar');
        const sidebarWidth = sidebar ? sidebar.offsetWidth : 0;
        canvas.width = window.innerWidth - sidebarWidth;
        canvas.height = window.innerHeight;
        
        // 如果游戏已经开始，则约束镜头范围
        if (window.game && window.game.constrainCamera) {
            window.game.constrainCamera();
        }
    }

    resizeGame();
    window.addEventListener('resize', resizeGame);

    // "创建游戏" 按钮点击事件
    startNewGameBtn.addEventListener('click', () => {
        const urlParams = new URLSearchParams(window.location.search);
        
        const showDetailsCheckbox = document.getElementById('show-details-checkbox');
        
        // 从UI收集游戏设置
        const settings = {
            gameMode: document.getElementById('game-mode-select').value,
            mapId: mapSelect.value,
            gameSpeed: document.getElementById('game-speed-select').value,
            aiDifficulty: document.getElementById('ai-difficulty-select').value,
            showDetails: showDetailsCheckbox.checked, // 读取复选框状态
            fromDialogue: urlParams.get('fromDialogue') === 'true',
            user: urlParams.get('user')
        };
        
        setupScreen.style.display = 'none';
        
        const game = new Game(canvas);
        game.init(settings);
    });
});
```

---

### `map.js`
```javascript
// js/map.js

import { TILE_SIZE, TERRAIN_TYPES } from './config.js';

/**
 * 生成一个基于种子的伪随机数。
 * @param {number} seed - 种子。
 * @returns {number} - 返回一个在 [0, 1) 区间内的浮点数。
 */
function seededRandom(seed) {
    let x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
}

/**
 * @class GameMap
 * @description 管理游戏地图数据和渲染。
 */
export class GameMap {
    constructor() {
        this.width = 0;
        this.height = 0;
        this.grid = []; // 二维数组，存储每个格子的地形信息
        this.terrainDetails = new Map(); // 缓存地形细节，避免重复计算
    }

    /**
     * 从地图数据加载地图。
     * @param {object} mapData - 来自 maps-data.js 的地图定义对象。
     */
    load(mapData) {
        this.width = mapData.width;
        this.height = mapData.height;
        const terrainMap = { 'g': 'grass', 'f': 'forest', 'r': 'road', 'w': 'water', 'b': 'building' };
        
        this.grid = Array(this.height).fill(null).map(() => Array(this.width).fill(null));
        
        for (let y = 0; y < this.height; y++) {
            const rowString = mapData.grid[y] || '';
            for (let x = 0; x < this.width; x++) {
                const char = rowString[x] || 'g'; // 默认为草地
                const type = terrainMap[char];
                this.grid[y][x] = { type };
            }
        }
    }

    /**
     * 绘制地图，包含地形混合和细节渲染。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {object} camera - 镜头对象，用于视口剔除。
     */
    draw(ctx, camera) {
        // 计算需要渲染的格子范围 (视口剔除)
        const startX = Math.floor(camera.x / TILE_SIZE);
        const startY = Math.floor(camera.y / TILE_SIZE);
        const endX = Math.ceil((camera.x + ctx.canvas.width / camera.zoom) / TILE_SIZE);
        const endY = Math.ceil((camera.y + ctx.canvas.height / camera.zoom) / TILE_SIZE);

        for (let y = startY; y < endY; y++) {
            for (let x = startX; x < endX; x++) {
                if (x < 0 || y < 0 || x >= this.width || y >= this.height) continue;
                
                const tile = this.getTile(x, y);
                if (!tile) continue;
                
                // 1. 绘制基础地形颜色
                const baseColor = TERRAIN_TYPES[tile.type].color;
                ctx.fillStyle = baseColor;
                ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE + 1, TILE_SIZE + 1); // +1 修复格子间缝隙

                // 2. 绘制地形边缘混合效果
                this.drawTerrainBlend(ctx, x, y);

                // 3. 绘制地形细节 (小杂色点)
                this.drawTerrainDetails(ctx, x, y, baseColor);
            }
        }
    }

    /**
     * 检查邻居并绘制地形混合效果。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {number} x - 格子X坐标。
     * @param {number} y - 格子Y坐标。
     */
    drawTerrainBlend(ctx, x, y) {
        const neighbors = [
            { dx: 0, dy: -1, dir: 'top' }, 
            { dx: 1, dy: 0, dir: 'right' }, 
            { dx: 0, dy: 1, dir: 'bottom' }, 
            { dx: -1, dy: 0, dir: 'left' }
        ];
        
        const currentType = TERRAIN_TYPES[this.getTile(x, y).type];

        for (const neighbor of neighbors) {
            const nx = x + neighbor.dx;
            const ny = y + neighbor.dy;

            const neighborTile = this.getTile(nx, ny);
            if (neighborTile) {
                const neighborType = TERRAIN_TYPES[neighborTile.type];

                // 如果邻居地形的渲染优先级更高，则在此格子的边缘绘制邻居地形的颜色，形成混合效果
                if (neighborType.priority > currentType.priority && currentType.priority > 0) {
                    this._drawBlendPattern(ctx, x, y, neighbor.dir, neighborType.color);
                }
            }
        }
    }

    /**
     * 绘制地形上的随机细节，增加视觉丰富度。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {number} x - 格子X坐标。
     * @param {number} y - 格子Y坐标。
     * @param {string} baseColor - 格子的基础颜色。
     */
    drawTerrainDetails(ctx, x, y, baseColor) {
        const detailKey = `${x},${y}`;
        if (!this.terrainDetails.has(detailKey)) {
            const details = [];
            const numDetails = Math.floor(seededRandom(y * this.width + x + 1) * 5);
            for (let i = 0; i < numDetails; i++) {
                details.push({
                    x: seededRandom(i + x * y + 2) * TILE_SIZE,
                    y: seededRandom(i * 2 + x * y + 3) * TILE_SIZE,
                    size: seededRandom(i * 3 + x * y + 4) * (TILE_SIZE / 4) + 2,
                    color: this.adjustColor(baseColor, (seededRandom(i * 4 + x * y + 5) - 0.5) * 0.2)
                });
            }
            this.terrainDetails.set(detailKey, details);
        }

        const cachedDetails = this.terrainDetails.get(detailKey);
        for(const detail of cachedDetails) {
            ctx.fillStyle = detail.color;
            ctx.fillRect(x * TILE_SIZE + detail.x, y * TILE_SIZE + detail.y, detail.size, detail.size);
        }
    }

    /**
     * 根据方向绘制确定的随机混合图案，实现自然的过渡效果。
     * @private
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {number} x - 当前瓦片的格子X坐标。
     * @param {number} y - 当前瓦片的格子Y坐标。
     * @param {string} direction - 邻居的方向 ('top', 'right', 'bottom', 'left')。
     * @param {string} blendColor - 邻居（高优先级地形）的颜色。
     */
    _drawBlendPattern(ctx, x, y, direction, blendColor) {
        ctx.fillStyle = blendColor;
        const subTileCount = 4; // 将瓦片边缘分为4个小块进行处理
        const subTileSize = TILE_SIZE / subTileCount; 
        const pixelX = x * TILE_SIZE;
        const pixelY = y * TILE_SIZE;

        for (let i = 0; i < subTileCount; i++) {
            // 使用瓦片坐标和块索引作为种子，确保每次渲染的图案都相同
            const seed = x * 13 + y * 31 + i * 7 + direction.charCodeAt(0);
            const randomVal = seededRandom(seed);
            
            if (randomVal < 0.6) { // 约60%的概率绘制混合块
                // 混合深度随机，但确定
                const blendDepth = Math.ceil(seededRandom(seed * 2) * 2) * (subTileSize / 2);
                
                let rectX, rectY, rectW, rectH;

                switch (direction) {
                    case 'top':
                        rectX = pixelX + i * subTileSize; rectY = pixelY;
                        rectW = subTileSize; rectH = blendDepth;
                        break;
                    case 'bottom':
                        rectX = pixelX + i * subTileSize; rectY = pixelY + TILE_SIZE - blendDepth;
                        rectW = subTileSize; rectH = blendDepth;
                        break;
                    case 'left':
                        rectX = pixelX; rectY = pixelY + i * subTileSize;
                        rectW = blendDepth; rectH = subTileSize;
                        break;
                    case 'right':
                        rectX = pixelX + TILE_SIZE - blendDepth; rectY = pixelY + i * subTileSize;
                        rectW = blendDepth; rectH = subTileSize;
                        break;
                }
                 ctx.fillRect(rectX, rectY, rectW + 1, rectH + 1); // +1 修复缝隙
            }
        }
    }

    /**
     * 微调颜色，用于生成地形细节。
     * @param {string} hex - 16进制颜色字符串 (e.g., '#FF0000')。
     * @param {number} percent - 调整百分比 (e.g., -0.2 to 0.2)。
     * @returns {string} - 调整后的16进制颜色字符串。
     */
    adjustColor(hex, percent) {
        let r = parseInt(hex.substring(1, 3), 16);
        let g = parseInt(hex.substring(3, 5), 16);
        let b = parseInt(hex.substring(5, 7), 16);
        const amount = Math.floor(255 * percent);
        r = Math.max(0, Math.min(255, r + amount));
        g = Math.max(0, Math.min(255, g + amount));
        b = Math.max(0, Math.min(255, b + amount));
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    /**
     * 获取指定坐标的格子信息。
     * @param {number} x - 格子X坐标。
     * @param {number} y - 格子Y坐标。
     * @returns {object|null} - 返回格子对象，如果越界则返回null。
     */
    getTile(x, y) {
        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
            return this.grid[y][x];
        }
        return null;
    }

    /**
     * 设置指定坐标格子的地形类型。
     * @param {number} x - 格子X坐标。
     * @param {number} y - 格子Y坐标。
     * @param {string} newType - 新的地形类型ID。
     */
    setTileType(x, y, newType) {
        const tile = this.getTile(x, y);
        if (tile && TERRAIN_TYPES[newType]) {
            tile.type = newType;
        }
    }
}```

---

### `maps-data.js`
```javascript
// js/maps-data.js

/**
 * @file 存放所有地图的定义数据。
 * 地图格子字符代表:
 * 'g': 草地 (grass)
 * 'f': 森林 (forest)
 * 'r': 马路 (road)
 * 'w': 海洋 (water)
 * 'b': 建筑 (building)
 */
export const MAP_DEFINITIONS = [
    {
        id: 'map_new_01',
        name: '十字路口冲突 (Crossroads Clash)',
        description: '中心道路是兵家必争之地，两侧的森林为伏击提供了可能。',
        width: 80, 
        height: 60,
        grid: (() => {
            const w = 80, h = 60;
            let grid = Array(h).fill(null).map(() => Array(w).fill('g'));
            
            // 主干道
            for (let y = 0; y < h; y++) {
                grid[y][Math.floor(w/2) -1] = 'r';
                grid[y][Math.floor(w/2)] = 'r';
            }
             for (let x = 0; x < w; x++) {
                grid[Math.floor(h/2) -1][x] = 'r';
                grid[Math.floor(h/2)][x] = 'r';
            }
            
            // 四角的森林区域
            for (let y = 10; y < 22; y++) {
                for(let x = 10; x < 25; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
                for(let x = w - 25; x < w - 10; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
            }
             for (let y = h - 22; y < h - 10; y++) {
                for(let x = 10; x < 25; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
                for(let x = w - 25; x < w - 10; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
            }

            // 上下的河流（带桥）
            for (let x = 28; x < 52; x++) {
                 if (x > 38 && x < 42) continue; // 桥的位置留空
                 grid[5][x] = 'w';
                 grid[h-6][x] = 'w';
            }
            return grid.map(row => row.join(''));
        })()
    },
    {
        id: 'map01',
        name: '双子桥 (Twin Bridges)',
        description: '一条河流将地图一分为二，只有两座桥梁可供地面部队通过。',
        width: 100, 
        height: 60,
        grid: (() => {
            const w = 100, h = 60;
            let grid = Array(h).fill(null).map(() => Array(w).fill('g'));
            
            // 河流
            for (let y = 28; y < 32; y++) {
                for (let x = 0; x < w; x++) grid[y][x] = 'w';
            }
            
            // 桥梁 (用马路代替)
            for (let y = 28; y < 32; y++) {
                for(let x = 20; x < 28; x++) grid[y][x] = 'r';
                for(let x = 72; x < 80; x++) grid[y][x] = 'r';
            }

            // 添加一些随机森林
            for (let i = 0; i < 200; i++) {
                const randX = Math.floor(Math.random() * w);
                const randY = Math.floor(Math.random() * h);
                if (grid[randY][randX] === 'g') grid[randY][randX] = 'f';
            }
            return grid.map(row => row.join(''));
        })()
    },
];
```

---

### `pathfinding.js`
```javascript
// js/pathfinding.js

import { TILE_SIZE, TERRAIN_TYPES } from './config.js';

/**
 * @class Node
 * @description A* 寻路算法中使用的节点。
 */
class Node {
    constructor(parent = null, position = null) {
        this.parent = parent;
        this.position = position; // {x, y} 格子坐标
        this.g = 0; // 从起点到当前节点的代价
        this.h = 0; // 从当前节点到终点的预估代价 (启发式)
        this.f = 0; // 总代价 (g + h)
    }

    /**
     * 检查当前节点是否与另一个节点位置相同。
     * @param {Node} other - 另一个节点。
     * @returns {boolean}
     */
    equals(other) {
        return this.position.x === other.position.x && this.position.y === other.position.y;
    }
}

/**
 * 使用 A* 算法在地图上寻找路径。
 * @param {GameMap} map - 游戏地图对象。
 * @param {{x: number, y: number}} start - 起点格子坐标。
 * @param {{x: number, y: number}} end - 终点格子坐标。
 * @param {string} moveType - 移动单位的类型 ('ground', 'air', etc.)。
 * @returns {Array<{x: number, y: number}>|null} - 返回一个包含路径节点坐标的数组，如果找不到路径则返回null。
 */
export function findPath(map, start, end, moveType) {
    // 对于空中单位，路径就是一条直线，无需寻路
    if (moveType === 'air') {
        return [start, end];
    }
    
    const startNode = new Node(null, start);
    const endNode = new Node(null, end);

    let openList = []; // 待评估的节点
    let closedList = []; // 已评估的节点

    openList.push(startNode);
    
    // 设置最大迭代次数，防止因地图过大或无解导致的性能问题
    const maxIterations = map.width * map.height * 1.5;
    let iterations = 0;

    while (openList.length > 0 && iterations < maxIterations) {
        iterations++;
        
        // 从 openList 中找到 f 值最小的节点
        let currentNode = openList[0];
        let currentIndex = 0;
        for (let i = 1; i < openList.length; i++) {
            if (openList[i].f < currentNode.f) {
                currentNode = openList[i];
                currentIndex = i;
            }
        }

        // 将当前节点从 openList 移到 closedList
        openList.splice(currentIndex, 1);
        closedList.push(currentNode);

        // 如果到达终点，则回溯路径并返回
        if (currentNode.equals(endNode)) {
            let path = [];
            let current = currentNode;
            while (current !== null) {
                path.push(current.position);
                current = current.parent;
            }
            return path.reverse();
        }

        // 检查所有相邻的格子
        const adjacentSquares = [
            { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
            { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 }
        ];

        for (const newPosition of adjacentSquares) {
            const nodePosition = {
                x: currentNode.position.x + newPosition.x,
                y: currentNode.position.y + newPosition.y,
            };

            const tile = map.getTile(nodePosition.x, nodePosition.y);
            // 如果邻居节点不可通行，则跳过
            if (!tile || !TERRAIN_TYPES[tile.type].traversableBy.includes(moveType)) {
                continue;
            }
            
            const childNode = new Node(currentNode, nodePosition);
            
            // 如果邻居节点已在 closedList 中，则跳过
            if (closedList.find(node => node.equals(childNode))) {
                 continue;
            }

            // 计算 g, h, f 值
            const moveCost = (newPosition.x !== 0 && newPosition.y !== 0) ? 1.414 : 1; // 对角线移动代价更高
            childNode.g = currentNode.g + moveCost;
            childNode.h = Math.sqrt(((childNode.position.x - endNode.position.x) ** 2) + ((childNode.position.y - endNode.position.y) ** 2));
            childNode.f = childNode.g + childNode.h;

            // 如果邻居节点已在 openList 中，且新的路径代价更高，则跳过
            const existingNode = openList.find(node => node.equals(childNode));
            if (existingNode && childNode.g >= existingNode.g) {
                continue;
            }
            
            // 更新或添加节点到 openList
            if (existingNode) {
                existingNode.parent = currentNode;
                existingNode.g = childNode.g;
                existingNode.f = childNode.f;
            } else {
                openList.push(childNode);
            }
        }
    }

    return null; // 找不到路径
}


/**
 * 检查两点之间是否有地形障碍，用于路径平滑处理（拉直路径）。
 * @param {{x: number, y: number}} startPos - 起点像素坐标。
 * @param {{x: number, y: number}} endPos - 终点像素坐标。
 * @param {GameMap} map - 游戏地图对象。
 * @param {string} moveType - 移动单位的类型。
 * @returns {boolean} - 如果没有障碍则返回true。
 */
export function isLineOfSightClear(startPos, endPos, map, moveType) {
    // 空中单位永远视野清晰，无视地形障碍
    if (moveType === 'air') {
        return true;
    }

    const dx = endPos.x - startPos.x;
    const dy = endPos.y - startPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const step = TILE_SIZE / 2; // 检查步长，半个格子大小
    const steps = Math.ceil(distance / step);

    // 沿直线步进检查每个点所在的地形是否可通行
    for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const checkX = startPos.x + dx * t;
        const checkY = startPos.y + dy * t;

        const gridX = Math.floor(checkX / TILE_SIZE);
        const gridY = Math.floor(checkY / TILE_SIZE);

        const tile = map.getTile(gridX, gridY);
        if (!tile || !TERRAIN_TYPES[tile.type].traversableBy.includes(moveType)) {
            return false; // 遇到障碍
        }
    }
    
    return true; // 路径清晰
}
```

---

### `player.js`
```javascript
// js/player.js

import { AIController } from './ai.js';

/**
 * @class Player
 * @description 代表一个玩家，可以是人类或AI。
 */
export class Player {
    /**
     * @param {string} id - 玩家ID ('player' or 'ai')。
     * @param {string} name - 玩家名称。
     * @param {number} manpower - 初始资源。
     * @param {boolean} [isAI=false] - 是否为AI玩家。
     * @param {object} [baseArea] - 基地范围 (未使用)。
     * @param {string} [aiDifficulty='medium'] - AI难度。
     */
    constructor(id, name, manpower, isAI = false, baseArea, aiDifficulty = 'medium') {
        this.id = id;
        this.name = name;
        this.manpower = manpower;
        this.isAI = isAI;
        this.units = [];
        this.baseArea = baseArea; 
        this.baseCaptureTimer = 0; // for capture mechanics (not implemented)

        if (isAI) {
            this.aiController = new AIController(this, aiDifficulty);
        }
    }

    /**
     * 更新玩家逻辑，主要用于驱动AI。
     * @param {number} deltaTime - 帧时间差。
     * @param {Player} enemyPlayer - 敌方玩家对象。
     * @param {GameMap} map - 游戏地图。
     * @param {SpatialGrid} spatialGrid - 空间网格，传递给AI控制器用于索敌。
     */
    update(deltaTime, enemyPlayer, map, spatialGrid) {
        if (this.isAI) {
            this.aiController.update(this.units, enemyPlayer.units, map, deltaTime, spatialGrid);
        }
    }
    
    /**
     * 检查资源是否足够。
     * @param {number} unitCost - 单位花费。
     * @returns {boolean}
     */
    canAfford(unitCost) {
        return this.manpower >= unitCost;
    }
    
    /**
     * 扣除资源。
     * @param {number} amount - 扣除数量。
     */
    deductManpower(amount) {
        this.manpower -= amount;
    }
}
```

---

### `projectile.js`
```javascript
// js/projectile.js

import { getDistance } from './utils.js';

let nextProjectileId = 0;

/**
 * @class Projectile
 * @description 代表一个飞行中的弹道物体，如子弹、炮弹或导弹。
 */
export class Projectile {
    /**
     * @param {string} owner - 发射者的owner ID ('player' or 'ai')。
     * @param {{x: number, y: number}} startPos - 发射位置。
     * @param {Unit|Base} target - 目标对象。
     * @param {object} stats - 弹道属性 (伤害, 速度, 类型等)。
     */
    constructor(owner, startPos, target, stats) {
        this.id = nextProjectileId++;
        this.owner = owner;
        this.x = startPos.x;
        this.y = startPos.y;
        this.target = target;
        this.stats = stats;

        const targetPos = { x: target.pixelX || target.x, y: target.pixelY || target.y };
        const angle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
        this.vx = Math.cos(angle) * this.stats.ammoSpeed;
        this.vy = Math.sin(angle) * this.stats.ammoSpeed;
        
        this.trail = []; // 用于拖尾效果的粒子数组
        this.life = 0; // 弹道的生命周期计时
    }

    /**
     * 更新弹道位置和状态。
     * @param {number} deltaTime - 帧时间差。
     * @returns {boolean} - 如果弹道应该被销毁（命中或超时），则返回true。
     */
    update(deltaTime) {
        const targetPos = this.target ? { x: this.target.pixelX || this.target.x, y: this.target.pixelY || this.target.y } : {x: this.x + this.vx, y: this.y + this.vy};

        // 导弹的简单追踪逻辑
        if (this.stats.ammoType === 'missile' && this.target && this.target.hp > 0) {
            const angle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
            const targetVx = Math.cos(angle) * this.stats.ammoSpeed;
            const targetVy = Math.sin(angle) * this.stats.ammoSpeed;
            // 使用线性插值使导弹转向更平滑
            this.vx = this.vx * 0.98 + targetVx * 0.02;
            this.vy = this.vy * 0.98 + targetVy * 0.02;
        }

        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        this.life += deltaTime;

        // 更新拖尾效果
        this.updateTrail(deltaTime);

        const dist = getDistance(this, targetPos);
        // 命中判定（距离足够近）或超时（飞行时间过长）
        return dist < 10 || this.life > 5;
    }
    
    /**
     * 更新拖尾粒子效果。
     * @param {number} deltaTime - 帧时间差。
     */
    updateTrail(deltaTime) {
        if (this.stats.ammoType === 'missile' || this.stats.ammoType === 'shell') {
            // 每隔一小段距离添加一个新的拖尾粒子
            if (this.trail.length === 0 || getDistance(this.trail[this.trail.length-1], this) > 5) {
                this.trail.push({ x: this.x, y: this.y, life: 1.0 });
            }
        }
        
        // 更新并移除生命周期结束的拖尾粒子
        for (let i = this.trail.length - 1; i >= 0; i--) {
            this.trail[i].life -= deltaTime * 2.5;
            if (this.trail[i].life <= 0) {
                this.trail.splice(i, 1);
            }
        }
    }

    /**
     * 绘制弹道和其拖尾。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     */
    draw(ctx) {
        // 绘制拖尾（烟雾）
        if (this.stats.ammoType === 'missile' || this.stats.ammoType === 'shell') {
             ctx.fillStyle = `rgba(180, 180, 180, 0.4)`;
             this.trail.forEach(p => {
                ctx.beginPath();
                // 粒子大小随生命周期减小
                const radius = p.life * (this.stats.ammoType === 'missile' ? 4 : 2.5);
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // 绘制弹头
        switch (this.stats.ammoType) {
            case 'missile':
                ctx.fillStyle = `rgba(255, 200, 100, 1)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 'bullet':
                 ctx.fillStyle = 'yellow';
                 ctx.fillRect(this.x - 1, this.y - 1, 3, 3);
                 break;
            case 'shell':
                 ctx.fillStyle = '#ddd';
                 ctx.beginPath();
                 ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                 ctx.fill();
                 break;
        }
    }
}


/**
 * @class Explosion
 * @description 管理一个爆炸的视觉效果，包括火光和烟雾粒子。
 */
export class Explosion {
    /**
     * @param {number} x - 爆炸中心X坐标。
     * @param {number} y - 爆炸中心Y坐标。
     * @param {number} radius - 爆炸的最大半径。
     */
    constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius < 10 ? 10 : radius; // 最小爆炸半径
        this.maxLife = 0.6; // 爆炸持续时间（秒）
        this.life = this.maxLife;
        
        // 创建烟雾粒子
        this.particles = [];
        const particleCount = 15 + Math.floor(this.radius / 5);
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * this.radius * 0.5;
            this.particles.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                size: Math.random() * 5 + 2,
                alpha: Math.random() * 0.3 + 0.1,
            });
        }
    }

    /**
     * 更新爆炸效果的生命周期和粒子状态。
     * @param {number} deltaTime - 帧时间差。
     * @returns {boolean} - 如果爆炸效果应该被销毁，则返回true。
     */
    update(deltaTime) {
        this.life -= deltaTime;
        
        // 更新每个烟雾粒子的状态
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.life -= deltaTime * 0.8;
             if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
        
        return this.life <= 0 && this.particles.length === 0;
    }

    /**
     * 绘制爆炸效果。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     */
    draw(ctx) {
        const progress = 1 - (this.life / this.maxLife);
        
        // 绘制烟雾粒子
        this.particles.forEach(p => {
            ctx.fillStyle = `rgba(80, 80, 80, ${p.alpha * p.life})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (1 + progress), 0, Math.PI * 2);
            ctx.fill();
        });

        // 绘制火光 (多层叠加，实现体积感)
        if (this.life > 0) {
            // 使用sin函数实现平滑的淡入淡出效果
            const alpha = Math.sin(Math.PI * progress);
            
            // 1. 外层橙红色火焰
            let currentRadius = this.radius * progress;
            ctx.fillStyle = `rgba(255, 120, 0, ${alpha * 0.7})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // 2. 中层黄色火焰
            currentRadius *= 0.7;
            ctx.fillStyle = `rgba(255, 220, 100, ${alpha * 0.9})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();

            // 3. 核心白热化火焰
            currentRadius *= 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}
```

---

### `spatial-grid.js`
```javascript
// js/spatial-grid.js

/**
 * @file 空间网格数据结构，用于RTS游戏中的核心性能优化。
 * 它将游戏世界划分为一个网格，每个单位被放置在对应的格子里。
 * 当需要查询一个单位附近的其它单位时，只需检查其所在格子及周围的格子即可，
 * 避免了全局遍历所有单位，从而将碰撞检测、索敌等操作的复杂度从 O(n^2) 降低到接近 O(n)。
 */

/**
 * @class SpatialGrid
 */
export class SpatialGrid {
    /**
     * @param {number} mapWidth - 地图的总像素宽度。
     * @param {number} mapHeight - 地图的总像素高度。
     * @param {number} cellSize - 每个空间格子的像素尺寸。这个值通常应大于或等于最大单位的交互半径（如视野、射程）。
     */
    constructor(mapWidth, mapHeight, cellSize) {
        this.cellSize = cellSize;
        this.gridWidth = Math.ceil(mapWidth / cellSize);
        this.gridHeight = Math.ceil(mapHeight / cellSize);
        // 使用Map来存储格子，key是 "x,y" 格式的字符串，value是该格子内的单位数组。
        // Map比普通对象在频繁增删键时性能更好。
        this.grid = new Map(); 
    }

    /**
     * 将网格坐标转换为唯一的字符串键。
     * @private
     * @param {number} gridX - 网格的X坐标。
     * @param {number} gridY - 网格的Y坐标。
     * @returns {string} - "x,y" 格式的键。
     */
    _getKey(gridX, gridY) {
        return `${gridX},${gridY}`;
    }

    /**
     * 清空所有格子。此方法应在每帧更新开始时调用。
     */
    clear() {
        this.grid.clear();
    }

    /**
     * 将一个单位插入到其当前位置对应的格子中。
     * @param {Unit} unit - 要插入的单位。
     */
    insert(unit) {
        const gridX = Math.floor(unit.x / this.cellSize);
        const gridY = Math.floor(unit.y / this.cellSize);
        const key = this._getKey(gridX, gridY);

        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(unit);
    }

    /**
     * 获取一个单位附近（其自身格子 + 周围8个格子）的所有单位。
     * 这是最常用的查询方法，用于碰撞检测等。
     * @param {Unit} unit - 要查询的中心单位。
     * @returns {Array<Unit>} - 附近单位的数组。
     */
    getNearby(unit) {
        const nearbyUnits = [];
        const centralGridX = Math.floor(unit.x / this.cellSize);
        const centralGridY = Math.floor(unit.y / this.cellSize);

        // 遍历中心格子及其周围的8个格子 (3x3区域)
        for (let y = -1; y <= 1; y++) {
            for (let x = -1; x <= 1; x++) {
                const checkGridX = centralGridX + x;
                const checkGridY = centralGridY + y;
                const key = this._getKey(checkGridX, checkGridY);

                if (this.grid.has(key)) {
                    nearbyUnits.push(...this.grid.get(key));
                }
            }
        }
        return nearbyUnits;
    }
    
    /**
     * 获取一个点周围指定半径内的所有单位。
     * 这个方法比 getNearby 更精确，但可能需要检查更多的格子。
     * @param {{x: number, y: number}} position - 查询的中心点。
     * @param {number} radius - 查询半径。
     * @returns {Array<Unit>} - 半径范围内的单位数组。
     */
    getNearbyWithRadius(position, radius) {
        const nearbyUnits = new Set(); // 使用Set避免重复添加单位
        const minGridX = Math.floor((position.x - radius) / this.cellSize);
        const maxGridX = Math.floor((position.x + radius) / this.cellSize);
        const minGridY = Math.floor((position.y - radius) / this.cellSize);
        const maxGridY = Math.floor((position.y + radius) / this.cellSize);

        for (let y = minGridY; y <= maxGridY; y++) {
            for (let x = minGridX; x <= maxGridX; x++) {
                const key = this._getKey(x, y);
                 if (this.grid.has(key)) {
                    this.grid.get(key).forEach(unit => nearbyUnits.add(unit));
                }
            }
        }
        return Array.from(nearbyUnits);
    }
}
```

---

### `ui.js`
```javascript
// js/ui.js

import { UNIT_TYPES, TERRAIN_TYPES, TILE_SIZE } from './config.js';

/**
 * @class UI
 * @description 管理游戏的用户界面，包括单位选择、信息显示和玩家交互。
 */
export class UI {
    /**
     * @param {Game} game - 游戏主对象的引用。
     */
    constructor(game) {
        this.game = game;
        
        // DOM元素引用
        this.unitListContainer = document.getElementById('unit-selection');
        this.playerManpower = document.getElementById('player-manpower');
        this.gameStatus = document.getElementById('game-status');
        this.startBattleBtn = document.getElementById('start-battle-btn');
        this.selectedUnitInfo = document.getElementById('selected-unit-info');
        
        this.selectedUnitToDeploy = null; // 当前在部署列表中选中的单位类型
        this.messageTimeout = null; // 游戏消息的计时器

        this.init();
    }

    /**
     * 初始化UI，填充单位列表并绑定事件。
     */
    init() {
        this.populateUnitList();
        
        if (this.startBattleBtn) {
            this.startBattleBtn.addEventListener('click', () => this.game.startGame());
        }
    }

    /**
     * 根据config.js中的单位定义，动态生成可部署单位的列表。
     */
    populateUnitList() {
        if (!this.unitListContainer) return;
        
        this.unitListContainer.innerHTML = `
            <h3>可部署兵种</h3>
            <div id="unit-list-wrapper"></div>
        `;
        const listWrapper = this.unitListContainer.querySelector('#unit-list-wrapper');

        // 按单位类别进行分组
        const groupedUnits = {};
        for (const type in UNIT_TYPES) {
            const unit = UNIT_TYPES[type];
            if (!groupedUnits[unit.unitClass]) {
                groupedUnits[unit.unitClass] = [];
            }
            groupedUnits[unit.unitClass].push({ id: type, ...unit });
        }

        // 按预设顺序渲染类别
        const categoryOrder = ['步兵', '装甲', '飞行', '炮兵', '海军'];
        for (const category of categoryOrder) {
            if (!groupedUnits[category]) continue;

            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'unit-category';
            categoryDiv.innerHTML = `<h4>${category}</h4>`;
            
            const ul = document.createElement('ul');
            ul.className = 'unit-list';

            groupedUnits[category].forEach(unit => {
                const li = document.createElement('li');
                li.dataset.unitType = unit.id;
                li.title = unit.description;

                li.innerHTML = `
                    <div class="unit-icon">${unit.icon}</div>
                    <div class="unit-details">
                        <strong>${unit.name}</strong>
                        <div class="unit-stats">费用: ${unit.cost} | HP: ${unit.hp} | 攻击: ${unit.attack}</div>
                    </div>
                `;
                
                li.addEventListener('click', () => {
                    const wasSelected = li.classList.contains('selected');
                    this.clearAllSelectionsInList();
                    
                    if (!wasSelected) {
                        li.classList.add('selected');
                        this.selectedUnitToDeploy = unit.id;
                        // 交互优化: 选择部署单位时，自动取消地图上已选中的单位
                        this.game.selectedUnits = [];
                    } else {
                        this.selectedUnitToDeploy = null;
                    }
                });
                ul.appendChild(li);
            });

            categoryDiv.appendChild(ul);
            listWrapper.appendChild(categoryDiv);
        }
    }

    /**
     * 清除部署列表中所有单位的选中状态。
     */
    clearAllSelectionsInList() {
        if (!this.unitListContainer) return;
        this.unitListContainer.querySelectorAll('li.selected').forEach(item => item.classList.remove('selected'));
    }

    /**
     * 清除待部署单位的选择状态。通常由Game类在其他操作（如框选）后调用。
     */
    clearDeploymentSelection() {
        if (this.selectedUnitToDeploy) {
            this.selectedUnitToDeploy = null;
            this.clearAllSelectionsInList();
        }
    }

    /**
     * 每帧更新UI显示，如资源、游戏状态和基地血量。
     */
    update() {
        if (this.playerManpower) this.playerManpower.textContent = this.game.player.manpower;
        if (this.gameStatus) this.gameStatus.textContent = `状态: ${this.game.gameState}`;
        if (this.startBattleBtn) this.startBattleBtn.disabled = this.game.gameState !== 'deployment';
        
        // 更新基地血条
        this.updateBaseHP('player');
        this.updateBaseHP('ai');

        // 更新选中单位的信息面板
        this.updateSelectedUnitInfo();
    }
    
    /**
     * 更新指定玩家的基地HP条。
     * @param {string} owner - 'player' or 'ai'.
     */
    updateBaseHP(owner) {
        const base = this.game[`${owner}Base`];
        const displayDiv = document.getElementById(`${owner}-base-hp-display`);
        if (!displayDiv) return;

        if (base) {
            displayDiv.style.display = 'block';
            const hpBar = document.getElementById(`${owner}-base-hp-bar`);
            if(hpBar) {
                const percentage = (base.hp / base.maxHp) * 100;
                hpBar.style.width = `${percentage}%`;
            }
        } else {
            displayDiv.style.display = 'none';
        }
    }

    /**
     * 更新显示在UI右下角的选中单位信息。
     */
    updateSelectedUnitInfo() {
        if (!this.selectedUnitInfo) return;
        
        const selectedCount = this.game.selectedUnits.length;

        if (selectedCount === 1) {
            // 显示单个单位的详细信息
            const unit = this.game.selectedUnits[0]; 
            const stats = unit.stats;
            
            let statusText = '待命';
            if (unit.target) statusText = '攻击中';
            else if (unit.path && unit.path.length > 0) statusText = '移动中';
            else if (unit.isLoitering) statusText = '巡逻中';
            else if (unit.isSettingUp) statusText = '部署中';

            this.selectedUnitInfo.innerHTML = `
                <h4>${stats.name}</h4>
                <p>HP: ${unit.hp.toFixed(0)} / ${stats.hp}</p>
                <div class="hp-bar-container small">
                   <div class="hp-bar" style="width: ${(unit.hp / stats.hp) * 100}%; background-color: green;"></div>
                </div>
                <p>攻击: ${stats.attack} | 防御: ${stats.defense}</p>
                <p>射程: ${stats.range / TILE_SIZE}格 | 状态: ${statusText}</p> 
            `;
        } else if (selectedCount > 1) {
            // 显示多个单位的概要信息
            this.selectedUnitInfo.innerHTML = `
                <h4>选中多个单位</h4>
                <p>${selectedCount} 个单位被选中。</p>
            `;
        } else {
            // 没有单位被选中
            this.selectedUnitInfo.innerHTML = '<h4>选中单位信息</h4><p>无</p>';
        }
    }
    
    /**
     * 在游戏结束时显示胜利者信息。
     * @param {string} winnerName - 胜利者的名字。
     */
    showWinner(winnerName) {
        const winnerDiv = document.createElement('div');
        winnerDiv.className = 'winner-announcement';
        winnerDiv.textContent = `${winnerName} 获胜!`;
        document.body.appendChild(winnerDiv);
    }

    /**
     * 在屏幕上显示一条临时游戏消息 (如 "资源不足")。
     * @param {string} message - 要显示的消息文本。
     */
    showGameMessage(message) {
        let messageDiv = document.getElementById('game-message');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'game-message';
            document.body.appendChild(messageDiv);
        }
        
        messageDiv.textContent = message;
        messageDiv.classList.add('show');

        if (this.messageTimeout) clearTimeout(this.messageTimeout);
        
        this.messageTimeout = setTimeout(() => {
            messageDiv.classList.remove('show');
        }, 3000);
    }
}
```

---

### `unit.js`
```javascript
// js/unit.js

import { TILE_SIZE, UNIT_TYPES } from './config.js';
import { getDistance } from './utils.js';
import { Base } from './base.js';
import { Projectile } from './projectile.js';
import { findPath, isLineOfSightClear } from './pathfinding.js';

let nextUnitId = 0;

/**
 * @class Unit
 * @description 游戏中的基础作战单位类。
 */
export class Unit {
    /**
     * @param {string} type - 单位类型ID, 对应 config.js 中的键。
     * @param {string} owner - 所有者 ('player' or 'ai')。
     * @param {number} x - 初始像素X坐标。
     * @param {number} y - 初始像素Y坐标。
     */
    constructor(type, owner, x, y) {
        this.id = nextUnitId++;
        this.type = type;
        this.owner = owner;
        this.stats = { ...UNIT_TYPES[type] }; // 复制单位属性，防止修改全局配置
        this.image = window.assetManager[this.stats.imageSrc];

        // 位置和状态
        this.x = x;
        this.y = y;
        this.hp = this.stats.hp;
        this.angle = Math.random() * Math.PI * 2; // 当前朝向
        this.targetAngle = this.angle; // 目标朝向
        this.rotationSpeed = Math.PI * 2.0; // 每秒旋转速度
        
        // 战斗相关
        this.target = null;
        this.attackCooldown = 0;
        this.findTargetCooldown = Math.random() * 0.5; // 错开AI单位的索敌计算，避免同时计算造成卡顿

        // 移动相关
        this.path = [];
        this.currentPathIndex = 0;
        this.moveTargetPos = null; // 当前平滑路径的目标点
        
        // 特殊行为状态
        this.isLoitering = false; // 是否在巡逻（主要用于飞机）
        this.loiterCenter = null;
        this.loiterRadius = TILE_SIZE * 5;
        this.loiterAngle = 0;
        this.strafeDirection = Math.random() < 0.5 ? 1 : -1; // 飞机绕圈方向
        
        this.isSettingUp = false; // 是否在部署（炮兵）
        this.setupTimer = 0;
    }

    /**
     * 单位的主更新逻辑。
     * @param {number} deltaTime - 帧时间差。
     * @param {Array<Unit>} enemyUnits - 敌方单位数组 (已废弃，改用spatialGrid)。
     * @param {GameMap} map - 地图对象。
     * @param {Base} enemyBase - 敌方基地。
     * @param {Game} game - 游戏主对象。
     * @param {SpatialGrid} spatialGrid - 用于高效索敌的空间网格。
     */
    update(deltaTime, enemyUnits, map, enemyBase, game, spatialGrid) {
        if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;
        if (this.findTargetCooldown > 0) this.findTargetCooldown -= deltaTime;
        
        this.updateRotation(deltaTime);

        // 炮兵等单位部署中不能做任何事
        if (this.isSettingUp) {
            this.setupTimer -= deltaTime;
            if (this.setupTimer <= 0) this.isSettingUp = false;
            return;
        }
        
        // 核心逻辑：攻击或移动
        if (this.target && this.target.hp > 0) {
            this.handleAttack(this.target, game);
        } else {
            this.target = null;
            this.handleMovement(deltaTime, map);
        }

        // 性能优化：使用空间网格进行节流索敌
        // 只有当单位空闲且索敌冷却结束时才执行
        if (!this.target && this.path.length === 0 && !this.moveTargetPos && this.findTargetCooldown <= 0) {
            this.findTarget(enemyBase, spatialGrid);
            this.findTargetCooldown = 0.5 + Math.random() * 0.2; // 无论是否找到都重置计时器
            
            // 如果没找到目标，特定空军单位进入巡逻模式
            if (!this.target && this.stats.moveType === 'air' && (this.type === 'fighter_jet' || this.type === 'recon_drone')) {
                this.handleLoitering(deltaTime);
            }
        }
    }

    /**
     * 处理攻击目标的逻辑。
     * @param {Unit|Base} target - 攻击目标。
     * @param {Game} game - 游戏主对象。
     */
    handleAttack(target, game) {
        const targetPos = { x: target.pixelX || target.x, y: target.pixelY || target.y };
        const distanceToTarget = getDistance(this, targetPos);
        const engageRange = this.stats.range * 0.9; // 进入此范围才开火，避免在最大射程边缘反复横跳

        // 如果距离太远，则向目标移动
        if (distanceToTarget > engageRange) {
            // 只有在没有移动路径时才重新寻路，防止频繁计算
            if (!this.path.length && !this.moveTargetPos) {
                this.issueMoveCommand(targetPos, game.map, true);
            }
        } else {
            // 进入射程，停止移动
            this.path = [];
            this.moveTargetPos = null;
        }
        
        // 转向目标
        this.setTargetAngle(targetPos);
        
        // 在射程内且冷却完毕，则开火
        if (distanceToTarget <= this.stats.range) {
            // 检查是否已对准目标
            let angleDiff = Math.abs(this.angle - this.targetAngle);
            if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
            
            if (this.attackCooldown <= 0 && !this.isSettingUp && angleDiff < 0.2) {
                this.attack(game);
            }
        }
    }
    
    /**
     * 处理移动逻辑，包括路径平滑。
     * @param {number} deltaTime - 帧时间差。
     * @param {GameMap} map - 地图对象。
     */
    handleMovement(deltaTime, map) {
        // 如果有路径但没有平滑目标点，则计算下一个平滑目标点
        if (this.path.length > 0 && !this.moveTargetPos) {
            this.findSmoothedPathTarget(map);
        }
        
        if (this.moveTargetPos) {
            this.setTargetAngle(this.moveTargetPos);
            const distanceToNode = getDistance(this, this.moveTargetPos);
            
            // 到达路径节点
            if (distanceToNode < TILE_SIZE / 2) {
                this.moveTargetPos = null; 
                // 到达最终目的地
                if (this.currentPathIndex >= this.path.length -1) {
                    this.path = [];
                    // 如果是炮兵，到达后需要部署
                    if (this.stats.special === 'SETUP_TO_FIRE') {
                        this.isSettingUp = true;
                        this.setupTimer = 2.0;
                    }
                }
            } else {
                this.move(deltaTime);
            }
        }
    }

    /**
     * 处理空中单位的巡逻（绕圈）行为。
     * @param {number} deltaTime - 帧时间差。
     */
    handleLoitering(deltaTime) {
        if (!this.isLoitering) {
            this.isLoitering = true;
            this.loiterCenter = { x: this.x, y: this.y };
            this.loiterAngle = Math.atan2(this.y - this.loiterCenter.y, this.x - this.loiterCenter.x);
        }
        
        this.loiterAngle += 0.8 * deltaTime;
        
        const targetX = this.loiterCenter.x + Math.cos(this.loiterAngle) * this.loiterRadius;
        const targetY = this.loiterCenter.y + Math.sin(this.loiterAngle) * this.loiterRadius;
        
        this.setTargetAngle({x: targetX, y: targetY});
        this.move(deltaTime);
    }

    /**
     * 根据当前朝向和速度移动单位。
     * @param {number} deltaTime - 帧时间差。
     */
    move(deltaTime) {
        const speed = this.stats.speed * deltaTime;
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;
    }

    /**
     * 下达移动命令，计算路径。
     * @param {{x: number, y: number}} targetPos - 目标像素坐标。
     * @param {GameMap} map - 地图对象。
     * @param {boolean} [isEngaging=false] - 这次移动是否是为了攻击。
     */
    issueMoveCommand(targetPos, map, isEngaging = false) {
        if (!isEngaging) this.target = null; // 普通移动命令会取消攻击目标
        this.isLoitering = false;
        this.isSettingUp = false;
        this.moveTargetPos = null;
        
        const startGrid = { x: Math.floor(this.x / TILE_SIZE), y: Math.floor(this.y / TILE_SIZE) };
        const endGrid = { x: Math.floor(targetPos.x / TILE_SIZE), y: Math.floor(targetPos.y / TILE_SIZE) };
        const path = findPath(map, startGrid, endGrid, this.stats.moveType);
        
        if (path && path.length > 0) {
            this.path = path;
            this.currentPathIndex = 0;
        } else {
            this.path = [];
        }
    }

    /**
     * 平滑地更新单位朝向。
     * @param {number} deltaTime - 帧时间差。
     */
    updateRotation(deltaTime) {
        let diff = this.targetAngle - this.angle;
        // 确保选择最短路径旋转
        while (diff <= -Math.PI) diff += 2 * Math.PI;
        while (diff > Math.PI) diff -= 2 * Math.PI;
        
        const turnStep = this.rotationSpeed * deltaTime;
        if (Math.abs(diff) < turnStep) {
            this.angle = this.targetAngle;
        } else {
            this.angle += Math.sign(diff) * turnStep;
        }
        // 将角度标准化到 [0, 2*PI)
        this.angle = (this.angle + 2 * Math.PI) % (2 * Math.PI);
    }
    
    /**
     * 设置单位的目标朝向角度。
     * @param {{x: number, y: number}} targetPos - 目标点像素坐标。
     */
    setTargetAngle(targetPos) {
        this.targetAngle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
    }

    /**
     * 绘制单位及其UI元素（血条、选择框等）。
     * @param {CanvasRenderingContext2D} ctx - 绘图上下文。
     * @param {boolean} isSelected - 单位当前是否被选中。
     * @param {number} [zoom=1] - 当前镜头缩放。
     * @param {boolean} [showDetails=false] - 是否显示额外信息（射程圈、路径线）。
     */
    draw(ctx, isSelected, zoom = 1, showDetails = false) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI / 2); // 图像资源通常是朝上的，旋转90度
        const size = TILE_SIZE * (this.stats.drawScale || 1.5); 
        
        if (this.image) {
            ctx.drawImage(this.image, -size / 2, -size / 2, size, size);
        }
        ctx.restore();

        // 绘制选中状态和详细信息
        if (isSelected) {
            ctx.strokeStyle = this.owner === 'player' ? 'yellow' : 'orange';
            ctx.lineWidth = 2 / zoom;
            ctx.beginPath();
            ctx.arc(this.x, this.y, TILE_SIZE * this.stats.drawScale / 2, 0, Math.PI * 2);
            ctx.stroke();

            if (showDetails) {
                // 绘制射程圈
                if (this.stats.range > 0) {
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                    ctx.lineWidth = 1 / zoom;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.range, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // 绘制路径线
                if (this.path && this.path.length > 0) {
                    const endNode = this.path[this.path.length - 1];
                    const destX = endNode.x * TILE_SIZE + TILE_SIZE / 2;
                    const destY = endNode.y * TILE_SIZE + TILE_SIZE / 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(destX, destY);
                    ctx.strokeStyle = this.target ? 'rgba(255, 50, 50, 0.7)' : 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 3 / zoom]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        // 绘制血条
        const hpBarWidth = TILE_SIZE;
        const hpBarHeight = 5 / zoom;
        const hpBarYOffset = TILE_SIZE * 0.8;
        ctx.fillStyle = '#333';
        ctx.fillRect(this.x - hpBarWidth / 2, this.y - hpBarYOffset, hpBarWidth, hpBarHeight);
        ctx.fillStyle = this.owner === 'player' ? 'green' : '#c0392b';
        ctx.fillRect(this.x - hpBarWidth / 2, this.y - hpBarYOffset, hpBarWidth * (this.hp / this.stats.hp), hpBarHeight);
    }
    
    /**
     * 核心重构 (性能优化): 使用空间网格进行高效索敌。
     * @param {Base} enemyBase - 敌方基地对象。
     * @param {SpatialGrid} spatialGrid - 空间网格。
     */
    findTarget(enemyBase, spatialGrid) {
        let closestTarget = null;
        let minDistance = this.stats.visionRange; // 只在视野范围内搜索
        const validTargetTypes = this.stats.canTarget || ['ground', 'air', 'sea'];

        // 1. 从空间网格获取视野范围内的所有潜在目标
        const potentialTargets = spatialGrid.getNearbyWithRadius(this, minDistance);
        
        for (const target of potentialTargets) {
            if (target.owner === this.owner || target.hp <= 0) continue;
            
            // 检查单位类型是否可攻击
            if (target instanceof Unit && !validTargetTypes.includes(target.stats.moveType)) continue;

            const distance = getDistance(this, target);
            if (distance < minDistance) {
                minDistance = distance;
                closestTarget = target;
            }
        }

        // 2. 如果没有找到单位，再检查基地
        if (!closestTarget && enemyBase && enemyBase.hp > 0 && validTargetTypes.includes('ground')) {
            const distanceToBase = getDistance(this, {x: enemyBase.pixelX, y: enemyBase.pixelY});
            if (distanceToBase < minDistance) {
                closestTarget = enemyBase;
            }
        }
        
        this.target = closestTarget;
    }
    
    /**
     * 执行攻击，创建一个弹道对象。
     * @param {Game} game - 游戏主对象。
     */
    attack(game) {
        if (!this.target || !this.stats.ammoType) return;
        
        const pStats = {
            damage: this.stats.attack,
            ammoType: this.stats.ammoType,
            ammoSpeed: this.stats.ammoSpeed,
            splashRadius: this.stats.ammoSplashRadius,
        };
        const projectile = new Projectile(this.owner, { x: this.x, y: this.y }, this.target, pStats);
        game.projectiles.push(projectile);
        
        this.attackCooldown = this.stats.attackSpeed;
    }

    /**
     * 单位承受伤害。
     * @param {number} amount - 伤害值。
     */
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) this.hp = 0;
    }

    /**
     * 路径平滑处理：从路径的末端向前查找，找到第一个与当前位置无障碍的节点作为下一个目标点。
     * 这可以避免单位严格按照格子中心点移动，使移动轨迹更自然。
     * @param {GameMap} map - 地图对象。
     */
    findSmoothedPathTarget(map) {
        if (!this.path || this.path.length === 0 || this.currentPathIndex >= this.path.length) return;
        
        // 从路径终点向前搜索
        for (let i = this.path.length - 1; i > this.currentPathIndex; i--) {
            const node = this.path[i];
            const targetPos = { x: node.x * TILE_SIZE + TILE_SIZE / 2, y: node.y * TILE_SIZE + TILE_SIZE / 2 };
            if (isLineOfSightClear(this, targetPos, map, this.stats.moveType)) {
                this.moveTargetPos = targetPos;
                this.currentPathIndex = i;
                return;
            }
        }
        
        // 如果无法拉直路径，则移动到下一个节点
        const nextNode = this.path[this.currentPathIndex];
        if (nextNode) {
            this.moveTargetPos = { x: nextNode.x * TILE_SIZE + TILE_SIZE / 2, y: nextNode.y * TILE_SIZE + TILE_SIZE / 2 };
        }
    }
}
```

---

### `utils.js`
```javascript
// js/utils.js

/**
 * @file 存放通用的辅助函数。
 */

/**
 * 计算两点之间的欧几里得距离。
 * @param {{x: number, y: number}} p1 - 第一个点。
 * @param {{x: number, y: number}} p2 - 第二个点。
 * @returns {number} - 两点间的距离。
 */
export function getDistance(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
}
```