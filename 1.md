å¥½çš„ï¼Œæˆ‘å·²ç»ä»”ç»†å®¡æŸ¥äº†æ‚¨æä¾›çš„æ‰€æœ‰JavaScriptä»£ç ã€‚è¿™æ˜¯ä¸€æ¬¾åŠŸèƒ½ç›¸å½“å®Œå–„çš„RTSæ¸¸æˆåŸå‹ï¼Œå°¤å…¶æ˜¯åœ¨æ€§èƒ½ä¼˜åŒ–æ–¹é¢ï¼ˆå¦‚ç©ºé—´ç½‘æ ¼ï¼‰å’Œè§†è§‰æ•ˆæœæ–¹é¢ï¼ˆå¦‚æ–°çš„çˆ†ç‚¸å’Œåœ°å½¢æ··åˆï¼‰åšå¾—å¾ˆå¥½ã€‚

æ ¹æ®æ‚¨çš„è¦æ±‚ï¼Œæˆ‘å¯¹æ‰€æœ‰ä»£ç è¿›è¡Œäº†é‡æ„å’Œä¼˜åŒ–ï¼Œä¸»è¦ç›®æ ‡æ˜¯**æå‡ä»£ç æ•´æ´åº¦ã€å¯è¯»æ€§ï¼Œå¹¶ç»Ÿä¸€æ³¨é‡Šé£æ ¼**ã€‚ä»¥ä¸‹æ˜¯æˆ‘çš„ä¸»è¦å·¥ä½œï¼š

1.  **ç»Ÿä¸€JSDocæ³¨é‡Š**ï¼šä¸ºå‡ ä¹æ‰€æœ‰çš„ç±»ã€æ–¹æ³•å’Œå¤æ‚å‡½æ•°æ·»åŠ äº†æ ‡å‡†çš„JSDocæ³¨é‡Šã€‚è¿™ä¸ä»…è§£é‡Šäº†ä»£ç çš„åŠŸèƒ½ï¼Œè¿˜æ˜ç¡®äº†å‚æ•°å’Œè¿”å›å€¼ï¼Œéå¸¸æœ‰åˆ©äºæœªæ¥çš„ç»´æŠ¤å’Œå›¢é˜Ÿåä½œã€‚
2.  **ä»£ç æ ¼å¼åŒ–**ï¼šç»Ÿä¸€äº†ç¼©è¿›ã€ç©ºæ ¼å’Œæ¢è¡Œï¼Œä½¿æ•´ä½“ä»£ç é£æ ¼ä¿æŒä¸€è‡´ã€‚ç‰¹åˆ«æ˜¯ä¸€äº›å†—é•¿çš„å•è¡Œä»£ç è¢«é‡æ„ä¸ºæ›´æ˜“è¯»çš„å¤šè¡Œç»“æ„ã€‚
3.  **ä¼˜åŒ–æ³¨é‡Šå†…å®¹**ï¼šå°†åŸæ¥çš„ "æ ¸å¿ƒä¿®å¤"ã€"æ€§èƒ½é©å‘½" ç­‰å¼€å‘è¿‡ç¨‹ä¸­çš„æ ‡è®°ï¼Œè½¬åŒ–ä¸ºå¯¹â€œ**ä¸ºä»€ä¹ˆ**â€å’Œâ€œ**å¦‚ä½•åš**â€çš„æ¸…æ™°è§£é‡Šï¼Œè®©ä»»ä½•æ¥æ‰‹çš„äººéƒ½èƒ½å¿«é€Ÿç†è§£ä»£ç çš„è®¾è®¡æ„å›¾ã€‚
4.  **æå‡ä»£ç å¯è¯»æ€§**ï¼š
    *   åœ¨`game.js`ç­‰æ ¸å¿ƒç±»ä¸­ï¼Œå¯¹æ„é€ å‡½æ•°é‡Œçš„å±æ€§è¿›è¡Œäº†é€»è¾‘åˆ†ç»„ã€‚
    *   å¯¹ä¸€äº›å¤æ‚çš„é€»è¾‘å—ï¼ˆå¦‚`game.js`ä¸­çš„äº‹ä»¶å¤„ç†ï¼‰å¢åŠ äº†ç©ºè¡Œå’Œæ³¨é‡Šï¼Œä½¿å…¶ç»“æ„æ›´æ¸…æ™°ã€‚
    *   ä¿æŒäº†æ‚¨åŸæœ‰çš„ä¼˜ç§€å‘½åå’Œä»£ç ç»“æ„ã€‚

ä»¥ä¸‹æ˜¯ç»è¿‡ä¼˜åŒ–å’Œæ³¨é‡Šåçš„å®Œæ•´ä»£ç ã€‚

---

### `ai.js`
```javascript
// js/ai.js

import { UNIT_TYPES } from './config.js';
import { Unit } from './unit.js';
import { getDistance } from './utils.js';
import { Base } from './base.js';

/**
 * @class AIController
 * @description ç®¡ç†AIç©å®¶çš„å®è§‚æˆ˜ç•¥å’Œå¾®è§‚æ“ä½œã€‚
 */
export class AIController {
    /**
     * @param {Player} player - AIæ‰€å±çš„ç©å®¶å¯¹è±¡ã€‚
     * @param {string} difficulty - AIéš¾åº¦ ('medium', 'hard', 'hell')ã€‚
     */
    constructor(player, difficulty) {
        this.player = player;
        this.difficulty = difficulty;
        
        // å®è§‚å†³ç­–è®¡æ—¶å™¨
        this.macroTimer = 0; 
        this.macroInterval = 2.0; // æ¯2ç§’æ‰§è¡Œä¸€æ¬¡å®è§‚å†³ç­–
        
        // å¾®æ“è®¡æ—¶å™¨ (ä¸»è¦ç”¨äºåœ°ç‹±éš¾åº¦)
        this.microTimer = 0;
        this.microInterval = 0.5; // æ¯0.5ç§’æ‰§è¡Œä¸€æ¬¡å¾®æ“

        this.attackWave = []; // å½“å‰çš„è¿›æ”»æ³¢æ¬¡å•ä½
        this.playerBase = null; // ç©å®¶åŸºåœ°çš„å¼•ç”¨
    }

    /**
     * åœ¨æ¸¸æˆå¼€å§‹æ—¶éƒ¨ç½²åˆå§‹å•ä½ã€‚
     * @param {number} mapWidth - åœ°å›¾å®½åº¦ï¼ˆæ ¼å­æ•°ï¼‰ã€‚
     * @param {number} mapHeight - åœ°å›¾é«˜åº¦ï¼ˆæ ¼å­æ•°ï¼‰ã€‚
     * @param {number} TILE_SIZE - ç“¦ç‰‡å°ºå¯¸ï¼ˆåƒç´ ï¼‰ã€‚
     */
    deployUnits(mapWidth, mapHeight, TILE_SIZE) {
        const deployableUnits = Object.keys(UNIT_TYPES);
        let manpowerToSpend = this.player.manpower;

        // é«˜éš¾åº¦ä¸‹ï¼Œåˆå§‹èµ„æºèŠ±è´¹æ‰“æŠ˜æ‰£ï¼Œä»¥åˆ¶é€ æ›´å¤šå•ä½
        if (this.difficulty === 'hard' || this.difficulty === 'hell') {
            manpowerToSpend *= 0.7;
        }

        let spentManpower = 0;
        let attempts = 0;
        const maxAttempts = deployableUnits.length * 3; // é˜²æ­¢å› ä¹°ä¸èµ·ä»»ä½•å•ä½è€Œæ­»å¾ªç¯

        while (spentManpower < manpowerToSpend && attempts < maxAttempts) {
            const unitType = deployableUnits[Math.floor(Math.random() * deployableUnits.length)];
            const cost = UNIT_TYPES[unitType].cost;

            if (this.player.canAfford(cost)) {
                // åœ¨åœ°å›¾å³ä¾§ä¸‰åˆ†ä¹‹ä¸€åŒºåŸŸéšæœºéƒ¨ç½²
                const x = mapWidth * TILE_SIZE - (Math.random() * mapWidth / 3 * TILE_SIZE);
                const y = Math.random() * mapHeight * TILE_SIZE;
                const newUnit = new Unit(unitType, 'ai', x, y);
                this.player.units.push(newUnit);
                
                this.player.deductManpower(cost);
                spentManpower += cost;
                attempts = 0; // æˆåŠŸéƒ¨ç½²åé‡ç½®å°è¯•æ¬¡æ•°
            } else {
                attempts++;
            }
        }
    }

    /**
     * AIçš„æ ¸å¿ƒæ›´æ–°å¾ªç¯ã€‚
     * @param {Array<Unit>} aiUnits - AIçš„æ‰€æœ‰å•ä½ã€‚
     * @param {Array<Unit>} playerUnits - ç©å®¶çš„æ‰€æœ‰å•ä½ã€‚
     * @param {GameMap} map - æ¸¸æˆåœ°å›¾å¯¹è±¡ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @param {SpatialGrid} spatialGrid - ç”¨äºé«˜æ•ˆç´¢æ•Œçš„ç©ºé—´ç½‘æ ¼ã€‚
     */
    update(aiUnits, playerUnits, map, deltaTime, spatialGrid) {
        if (playerUnits.length === 0 && (!this.playerBase || this.playerBase.hp <= 0)) return;

        this.macroTimer += deltaTime;
        this.microTimer += deltaTime;

        // åŸºç¡€å¾®æ“ï¼šæ‰€æœ‰å•ä½è‡ªä¸»ç´¢æ•Œ (æ‰€æœ‰éš¾åº¦)
        // ä½¿ç”¨ç©ºé—´ç½‘æ ¼å¯ä»¥æå¤§æå‡ç´¢æ•Œæ•ˆç‡
        this.runSimpleLogic(aiUnits, spatialGrid);

        // å®è§‚å†³ç­–ï¼šæ ¹æ®éš¾åº¦å’Œæ—¶é—´é—´éš”æ‰§è¡Œ
        if (this.macroTimer >= this.macroInterval) {
            switch (this.difficulty) {
                case 'medium':
                    this.runMediumLogic(aiUnits, playerUnits, map);
                    break;
                case 'hard':
                case 'hell':
                    this.runHardLogic(aiUnits, playerUnits, map);
                    break;
            }
            this.macroTimer = 0;
        }
        
        // åœ°ç‹±éš¾åº¦ä¸‹çš„é«˜é¢‘é›†ç«å¾®æ“
        if (this.difficulty === 'hell' && this.microTimer >= this.microInterval) {
            this.runHellMicro(aiUnits, playerUnits);
            this.microTimer = 0;
        }
    }

    /**
     * åŸºç¡€AIé€»è¾‘ï¼šè®©ç©ºé—²å•ä½ä½¿ç”¨ç©ºé—´ç½‘æ ¼è‡ªä¸»å¯»æ‰¾æœ€è¿‘çš„æ•Œäººã€‚
     * @param {Array<Unit>} aiUnits - AIçš„æ‰€æœ‰å•ä½ã€‚
     * @param {SpatialGrid} spatialGrid - ç©ºé—´ç½‘æ ¼ã€‚
     */
    runSimpleLogic(aiUnits, spatialGrid) {
        aiUnits.forEach(unit => {
            // å¦‚æœå•ä½ç©ºé—² (æ²¡æœ‰ç›®æ ‡ï¼Œæ²¡æœ‰è·¯å¾„) ä¸”ç´¢æ•Œå†·å´å®Œæ¯•
            if (!unit.target && unit.path.length === 0 && unit.findTargetCooldown <= 0) {
                 // ä½¿ç”¨æ–°çš„ç´¢æ•Œå‡½æ•°ï¼Œå®ƒå†…éƒ¨é€šè¿‡ç©ºé—´ç½‘æ ¼é«˜æ•ˆæŸ¥æ‰¾
                unit.findTarget(this.playerBase, spatialGrid);
            }
        });
    }

    /**
     * ä¸­ç­‰éš¾åº¦é€»è¾‘ï¼šç»„ç»‡å°å‹æ³¢æ¬¡è¿›æ”»ç©å®¶åŸºåœ°ã€‚
     * @param {Array<Unit>} aiUnits - AIçš„æ‰€æœ‰å•ä½ã€‚
     * @param {Array<Unit>} playerUnits - ç©å®¶çš„æ‰€æœ‰å•ä½ã€‚
     * @param {GameMap} map - æ¸¸æˆåœ°å›¾å¯¹è±¡ã€‚
     */
    runMediumLogic(aiUnits, playerUnits, map) {
        if (!this.playerBase || this.playerBase.hp <= 0) return;

        const livingAttackWave = this.attackWave.filter(u => u.hp > 0);

        // å¦‚æœè¿›æ”»æ³¢æ¬¡å•ä½å°‘äº3ä¸ªï¼Œåˆ™ä»ç©ºé—²å•ä½ä¸­è¡¥å……
        if (livingAttackWave.length < 3) {
            this.attackWave = aiUnits.filter(u => !u.target && u.path.length === 0).slice(0, 5); 
        }
        
        // å‘½ä»¤æ³¢æ¬¡ä¸­çš„å•ä½å‘ç©å®¶åŸºåœ°ç§»åŠ¨
        const targetPoint = { x: this.playerBase.pixelX, y: this.playerBase.pixelY };
        this.attackWave.forEach(unit => {
            if (unit.hp > 0 && !unit.target && unit.path.length === 0) {
                 unit.issueMoveCommand(targetPoint, map); 
            }
        });
    }

    /**
     * å›°éš¾/åœ°ç‹±éš¾åº¦é€»è¾‘ï¼šä¼˜å…ˆæ”»å‡»é«˜ä»·å€¼ç›®æ ‡ï¼Œå…¶æ¬¡æ”»å‡»åŸºåœ°ã€‚
     * @param {Array<Unit>} aiUnits - AIçš„æ‰€æœ‰å•ä½ã€‚
     * @param {Array<Unit>} playerUnits - ç©å®¶çš„æ‰€æœ‰å•ä½ã€‚
     * @param {GameMap} map - æ¸¸æˆåœ°å›¾å¯¹è±¡ã€‚
     */
    runHardLogic(aiUnits, playerUnits, map) {
        let priorityTarget = null;
        
        // å®šä¹‰é«˜ä»·å€¼ç›®æ ‡çš„ç±»å‹é¡ºåº
        const targetPriorities = ['howitzer', 'sniper', 'sam_launcher', 'destroyer'];
        for (const type of targetPriorities) {
            priorityTarget = playerUnits.find(pUnit => pUnit.type === type && pUnit.hp > 0);
            if (priorityTarget) break;
        }

        // å¦‚æœæ²¡æœ‰é«˜ä»·å€¼ç›®æ ‡ï¼Œåˆ™ä»¥ç©å®¶åŸºåœ°ä¸ºç›®æ ‡
        if (!priorityTarget && this.playerBase && this.playerBase.hp > 0) {
            priorityTarget = this.playerBase;
        }

        // å¦‚æœæ‰¾åˆ°ç›®æ ‡ï¼Œåˆ™ç»„ç»‡æ³¢æ¬¡è¿›æ”»
        if (priorityTarget) {
            const livingAttackWave = this.attackWave.filter(u => u.hp > 0);
            if (livingAttackWave.length < 4) {
                 this.attackWave = aiUnits.filter(u => !u.target && u.path.length === 0).slice(0, 6);
            }

            this.attackWave.forEach(unit => {
                if (unit.hp > 0) {
                    unit.target = priorityTarget;
                }
            });
        }
    }

    /**
     * åœ°ç‹±éš¾åº¦å¾®æ“ï¼šæ‰€æœ‰å•ä½é›†ç«å½“å‰è¡€é‡æœ€å°‘çš„æ•Œæ–¹å•ä½ã€‚
     * @param {Array<Unit>} aiUnits - AIçš„æ‰€æœ‰å•ä½ã€‚
     * @param {Array<Unit>} playerUnits - ç©å®¶çš„æ‰€æœ‰å•ä½ã€‚
     */
    runHellMicro(aiUnits, playerUnits) {
        if (playerUnits.length === 0) return;

        // æ‰¾åˆ°è¡€é‡æœ€ä½çš„ç©å®¶å•ä½
        const weakestPlayerUnit = playerUnits.reduce((weakest, unit) => {
            return (unit.hp < weakest.hp) ? unit : weakest;
        }, playerUnits[0]);

        // å‘½ä»¤å°„ç¨‹å†…çš„æ‰€æœ‰AIå•ä½æ”»å‡»è¯¥ç›®æ ‡
        if (weakestPlayerUnit) {
            aiUnits.forEach(aiUnit => {
                const dist = getDistance(aiUnit, weakestPlayerUnit);
                if (dist <= aiUnit.stats.range) {
                    aiUnit.target = weakestPlayerUnit;
                }
            });
        }
    }
}
```

---

### `base.js`
```javascript
// js/base.js

import { TILE_SIZE } from './config.js';

/**
 * @class Base
 * @description ä»£è¡¨ç©å®¶æˆ–AIçš„ä¸»åŸºåœ°ã€‚
 */
export class Base {
    /**
     * @param {string} owner - åŸºåœ°æ‰€æœ‰è€… ('player' or 'ai')ã€‚
     * @param {number} gridX - åŸºåœ°å·¦ä¸Šè§’çš„æ ¼å­Xåæ ‡ã€‚
     * @param {number} gridY - åŸºåœ°å·¦ä¸Šè§’çš„æ ¼å­Yåæ ‡ã€‚
     */
    constructor(owner, gridX, gridY) {
        this.owner = owner;
        this.gridX = gridX;
        this.gridY = gridY;
        this.width = 3;  // æ ¼å­å®½åº¦
        this.height = 3; // æ ¼å­é«˜åº¦
        
        this.maxHp = 2500;
        this.hp = this.maxHp;

        // é¢„è®¡ç®—åƒç´ ä¸­å¿ƒç‚¹ï¼Œç”¨äºå•ä½å¯»è·¯å’Œç´¢æ•Œ
        this.pixelX = (gridX + this.width / 2) * TILE_SIZE;
        this.pixelY = (gridY + this.height / 2) * TILE_SIZE;
    }

    /**
     * ä½¿åŸºåœ°æ‰¿å—ä¼¤å®³ã€‚
     * @param {number} amount - ä¼¤å®³é‡ã€‚
     */
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp < 0) {
            this.hp = 0;
        }
        console.log(`${this.owner}'s base took ${amount} damage, remaining HP: ${this.hp}`);
    }

    /**
     * åœ¨Canvasä¸Šç»˜åˆ¶åŸºåœ°çš„ç”Ÿå‘½æ¡ã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {number} [zoom=1] - å½“å‰é•œå¤´ç¼©æ”¾çº§åˆ«ã€‚
     */
    draw(ctx, zoom = 1) {
        const barWidth = this.width * TILE_SIZE;
        const barHeight = 10;
        const barX = this.gridX * TILE_SIZE;
        const barY = this.gridY * TILE_SIZE - barHeight - 5; // åœ¨åŸºåœ°åœ°å—ä¸Šæ–¹æ˜¾ç¤º

        // ç»˜åˆ¶è¡€æ¡èƒŒæ™¯
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // ç»˜åˆ¶å½“å‰è¡€é‡
        ctx.fillStyle = this.owner === 'player' ? 'cyan' : 'red';
        ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight);
        
        // ç»˜åˆ¶è¡€æ¡è¾¹æ¡†
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1 / zoom; // è¾¹æ¡†å®½åº¦ä¸å—ç¼©æ”¾å½±å“
        ctx.strokeRect(barX, barY, barWidth, barHeight);
    }
}
```

---

### `config.js`
```javascript
// js/config.js

/**
 * @file å­˜æ”¾æ¸¸æˆçš„æ ¸å¿ƒé…ç½®å’Œå¸¸é‡ã€‚
 */

// åŸºç¡€å°ºå¯¸å®šä¹‰
export const TILE_SIZE = 32; // æ¯ä¸ªåœ°å›¾æ ¼å­çš„åƒç´ å°ºå¯¸

// æ¸¸æˆé€Ÿåº¦å®šä¹‰
export const GAME_SPEEDS = {
    '0.5': 2,    // æ…¢é€Ÿ
    '1': 1,      // æ­£å¸¸
    '1.5': 0.66  // å¿«é€Ÿ
};

// åœ°å½¢å®šä¹‰
export const TERRAIN_TYPES = {
    // key: åœ°å½¢ID
    // name: æ˜¾ç¤ºåç§°
    // color: åœ°å›¾åŸºç¡€é¢œè‰²
    // traversableBy: å…è®¸é€šè¡Œçš„ç§»åŠ¨ç±»å‹æ•°ç»„ ('ground', 'sea', 'air', 'amphibious')
    // priority: æ¸²æŸ“æ··åˆæ•ˆæœæ—¶çš„ä¼˜å…ˆçº§ï¼Œé«˜ä¼˜å…ˆçº§ä¼šè¦†ç›–ä½ä¼˜å…ˆçº§
    // defenseBonus: (å¯é€‰) æ­¤åœ°å½¢æä¾›çš„é˜²å¾¡åŠ æˆ (æœªä½¿ç”¨)
    grass: { name: 'è‰åœ°', color: '#7CFC00', traversableBy: ['ground', 'amphibious'], priority: 1 },
    forest: { name: 'æ£®æ—', color: '#228B22', defenseBonus: 0.2, traversableBy: ['ground', 'amphibious'], priority: 2 },
    road: { name: 'é©¬è·¯', color: '#696969', traversableBy: ['ground', 'amphibious'], priority: 4 },
    water: { name: 'æµ·æ´‹', color: '#1E90FF', traversableBy: ['air', 'sea', 'amphibious'], priority: 3 },
    building: { name: 'å»ºç­‘', color: '#A9A9A9', defenseBonus: 0.3, traversableBy: [], priority: 0 },
    base: { name: 'åŸºåœ°', color: '#FFD700', defenseBonus: 0.1, traversableBy: ['ground', 'amphibious', 'air'], priority: 0 }
};

// å•ä½å®šä¹‰
export const UNIT_TYPES = {
    // --- æ­¥å…µ ---
    assault_infantry: {
        unitClass: 'æ­¥å…µ', icon: 'ğŸ‘¨â€âœˆï¸', name: 'çªå‡»æ­¥å…µ',
        cost: 1, hp: 100, attack: 15, defense: 5, range: 4 * TILE_SIZE, speed: 1.5 * TILE_SIZE, attackSpeed: 1.2, visionRange: 4 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/assault_infantry.png', drawScale: 1.5,
        ammoType: 'bullet', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0,
        description: 'åŸºç¡€ä½œæˆ˜å•ä½ï¼Œå»‰ä»·ä¸”çµæ´»ã€‚'
    },
    sniper: {
        unitClass: 'æ­¥å…µ', icon: 'ğŸ¯', name: 'ç‹™å‡»æ‰‹',
        cost: 3, hp: 70, attack: 50, defense: 0, range: 9 * TILE_SIZE, speed: 1.2 * TILE_SIZE, attackSpeed: 4.0, visionRange: 9 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/sniper.png', drawScale: 1.5,
        ammoType: 'bullet', ammoSpeed: 30 * TILE_SIZE, ammoSplashRadius: 0, special: 'SETUP_TO_FIRE', 
        description: 'è¶…è¿œå°„ç¨‹ï¼Œå¯¹æ­¥å…µå•ä½é€ æˆå·¨å¤§å¨èƒï¼Œä½†è‡ªèº«è„†å¼±ã€‚'
    },
    anti_tank_trooper: {
        unitClass: 'æ­¥å…µ', icon: 'ğŸš€', name: 'åå¦å…‹å…µ',
        cost: 2, hp: 90, attack: 25, defense: 5, range: 5 * TILE_SIZE, speed: 1.3 * TILE_SIZE, attackSpeed: 2.5, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/anti_tank_trooper.png', drawScale: 1.5,
        ammoType: 'shell', ammoSpeed: 12 * TILE_SIZE, ammoSplashRadius: 0.5 * TILE_SIZE, counters: { armor: 1.8 },
        description: 'æºå¸¦ç«ç®­ç­’ï¼Œèƒ½æœ‰æ•ˆå¯¹æŠ—æ•Œæ–¹è£…ç”²å•ä½ã€‚'
    },
    // --- è£…ç”² ---
    main_battle_tank: {
        unitClass: 'è£…ç”²', icon: 'T', name: 'ä¸»æˆ˜å¦å…‹',
        cost: 5, hp: 400, attack: 50, defense: 35, range: 6 * TILE_SIZE, speed: 1.1 * TILE_SIZE, attackSpeed: 2.2, visionRange: 6 * TILE_SIZE * 1.5,
        moveType: 'ground', unitType: 'armor', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/main_battle_tank.png', drawScale: 3,
        ammoType: 'shell', ammoSpeed: 8 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: 'æˆ˜åœºä¸­åšï¼Œæ”»é˜²å…¼å¤‡ï¼Œæ˜¯åœ°é¢æ¨è¿›çš„æ ¸å¿ƒåŠ›é‡ã€‚'
    },
    light_tank: {
        unitClass: 'è£…ç”²', icon: 't', name: 'è½»å‹å¦å…‹',
        cost: 3, hp: 250, attack: 30, defense: 20, range: 5 * TILE_SIZE, speed: 1.8 * TILE_SIZE, attackSpeed: 1.8, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'ground', unitType: 'armor', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/light_tank.png', drawScale: 3,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0,
        description: 'æœºåŠ¨æ€§æ›´å¼ºï¼Œé€‚åˆä¾¦å¯Ÿå’Œå¿«é€Ÿç©¿æ’ã€‚'
    },
    amphibious_tank: {
        unitClass: 'è£…ç”²', icon: 'A', name: 'ä¸¤æ –å¦å…‹',
        cost: 4, hp: 300, attack: 35, defense: 25, range: 5 * TILE_SIZE, speed: 1.2 * TILE_SIZE, attackSpeed: 2.0, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'amphibious', unitType: 'armor', canTarget: ['ground', 'sea','amphibious','sea'], imageSrc: 'assets/pics/amphibious_tank.png', drawScale: 3,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0,
        description: 'å¯ä»¥ç©¿è¶Šæ°´åŸŸå’Œé™†åœ°ï¼Œç”¨äºç™»é™†ä½œæˆ˜ã€‚'
    },
    // --- é£è¡Œ ---
    fighter_jet: {
        unitClass: 'é£è¡Œ', icon: 'âœˆï¸', name: 'æˆ˜æ–—æœº',
        cost: 6, hp: 200, attack: 60, defense: 10, range: 8 * TILE_SIZE, speed: 5.0 * TILE_SIZE, attackSpeed: 2.0, visionRange: 8 * TILE_SIZE * 1.5,
        moveType: 'air', canTarget: ['air','sea'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0, counters: { air: 1.8 },
        description: 'å¤ºå–åˆ¶ç©ºæƒçš„ç‹è€…ï¼Œä¸“é—¨çŒæ€æ•Œæ–¹é£è¡Œå•ä½ã€‚'
    },
    attack_helicopter: {
        unitClass: 'é£è¡Œ', icon: 'ğŸš', name: 'æ”»å‡»ç›´å‡æœº',
        cost: 5, hp: 250, attack: 40, defense: 15, range: 7 * TILE_SIZE, speed: 3.0 * TILE_SIZE, attackSpeed: 1.8, visionRange: 7 * TILE_SIZE * 1.5,
        moveType: 'air', unitType: 'air', canTarget: ['ground', 'sea','amphibious'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0, counters: { armor: 1.4 },
        description: 'ä½ç©ºç›˜æ—‹çš„å¦å…‹æ€æ‰‹ï¼Œä¸ºåœ°é¢éƒ¨é˜Ÿæä¾›ç«åŠ›æ”¯æ´ã€‚'
    },
    recon_drone: {
        unitClass: 'é£è¡Œ', icon: 'ğŸ›°ï¸', name: 'æ— äººä¾¦å¯Ÿæœº',
        cost: 2, hp: 50, attack: 0, defense: 0, range: 0, speed: 4.0 * TILE_SIZE, attackSpeed: 99, visionRange: 0, // è§†é‡ç”±æˆ˜äº‰è¿·é›¾ç³»ç»Ÿå•ç‹¬å¤„ç†
        moveType: 'air', unitType: 'air', canTarget: [], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: null, ammoSpeed: 0, ammoSplashRadius: 0,
        description: 'å»‰ä»·çš„ç©ºä¸­ä¾¦å¯Ÿå•ä½ï¼Œç§»åŠ¨é€Ÿåº¦å¿«ï¼Œè§†é‡èŒƒå›´å¹¿ã€‚'
    },
    // --- ç‚®å…µ ---
    howitzer: {
        unitClass: 'ç‚®å…µ', icon: 'ğŸ’£', name: 'æ¦´å¼¹ç‚®',
        cost: 6, hp: 120, attack: 100, defense: 5, range: 12 * TILE_SIZE, speed: 0.8 * TILE_SIZE, attackSpeed: 5.0, visionRange: 12 * TILE_SIZE * 1.5,
        moveType: 'ground', special: 'SETUP_TO_FIRE', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/howitzer.png', drawScale: 4,
        ammoType: 'shell', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: 'è¶…è¿œç¨‹åœ°é¢å‹åˆ¶ç«åŠ›ï¼Œä½†éœ€è¦éƒ¨ç½²æ‰èƒ½å¼€ç«ã€‚'
    },
    sam_launcher: {
        unitClass: 'ç‚®å…µ', icon: 'ğŸ—¼', name: 'é˜²ç©ºç‚®',
        cost: 5, hp: 150, attack: 80, defense: 10, range: 10 * TILE_SIZE, speed: 1.0 * TILE_SIZE, attackSpeed: 0.4, visionRange: 10 * TILE_SIZE * 1.5,
        moveType: 'ground', special: 'SETUP_TO_FIRE', canTarget: ['air'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'shell', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0.5 * TILE_SIZE,
        description: 'è¿œç¨‹é˜²ç©ºæ­¦å™¨ï¼Œå¯¹æˆ˜æ–—æœºå’Œè½°ç‚¸æœºæ˜¯è‡´å‘½å¨èƒã€‚'
    },
    // --- æµ·å†› ---
    destroyer: {
        unitClass: 'æµ·å†›', icon: 'ğŸš¢', name: 'é©±é€èˆ°',
        cost: 8, hp: 600, attack: 70, defense: 30, range: 9 * TILE_SIZE, speed: 1.5 * TILE_SIZE, attackSpeed: 2.8, visionRange: 9 * TILE_SIZE * 1.5,
        moveType: 'sea', canTarget: ['ground', 'sea', 'air'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 30 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: 'åŠŸèƒ½å…¨é¢çš„ä¸»åŠ›æˆ˜èˆ°ï¼Œå¯ä»¥æ”»å‡»æ¥è‡ªæµ·é™†ç©ºçš„ä»»ä½•æ•Œäººã€‚'
    },
    submarine: {
        unitClass: 'æµ·å†›', icon: 'ğŸŒŠ', name: 'æ½œè‰‡',
        cost: 7, hp: 400, attack: 90, defense: 15, range: 8 * TILE_SIZE, speed: 1.8 * TILE_SIZE, attackSpeed: 3.5, visionRange: 8 * TILE_SIZE * 1.5,
        moveType: 'undersea', canTarget: ['sea'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0,
        description: 'æ°´ä¸‹æ€æ‰‹ï¼Œæ“…é•¿å¯¹æ•Œæ–¹æ½œè‰‡å’Œæ½œæ°´èˆ¹è¿›è¡Œæ”»å‡»ã€‚'
    },
};
```

---

### `game.js`
```javascript
// js/game.js

import { TILE_SIZE, UNIT_TYPES, GAME_SPEEDS, TERRAIN_TYPES } from './config.js';
import { MAP_DEFINITIONS } from './maps-data.js';
import { GameMap } from './map.js';
import { Unit } from './unit.js';
import { Player } from './player.js';
import { UI } from './ui.js';
import { Base } from './base.js';
import { getDistance } from './utils.js';
import { Projectile, Explosion } from './projectile.js';
import { findPath } from './pathfinding.js';
import { FogOfWar } from './fog-of-war.js';
import { SpatialGrid } from './spatial-grid.js';

/**
 * @class Game
 * @description æ¸¸æˆçš„ä¸»æ§åˆ¶å™¨ï¼Œè´Ÿè´£ç®¡ç†æ¸¸æˆçŠ¶æ€ã€ä¸»å¾ªç¯ã€æ¸²æŸ“å’Œç”¨æˆ·è¾“å…¥ã€‚
 */
export class Game {
    /**
     * @param {HTMLCanvasElement} canvas - æ¸¸æˆæ¸²æŸ“çš„Canvaså…ƒç´ ã€‚
     */
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        // æ¸¸æˆçŠ¶æ€ç®¡ç†
        this.gameState = 'setup'; // 'setup', 'deployment', 'playing', 'gameover'
        this.gameMode = 'annihilation';
        this.lastTime = 0;
        this.gameSpeedModifier = 1;
        this.showDetails = false; // æ˜¯å¦æ˜¾ç¤ºå•ä½è¯¦ç»†ä¿¡æ¯ï¼ˆå¦‚å°„ç¨‹åœˆï¼‰
        
        // æ¸¸æˆä¸–ç•Œå¯¹è±¡
        this.map = null;
        this.player = null;
        this.ai = null;
        this.playerBase = null;
        this.aiBase = null;
        this.fogOfWar = null;
        this.spatialGrid = null; // æ ¸å¿ƒæ€§èƒ½ä¼˜åŒ–ï¼šç©ºé—´ç½‘æ ¼
        
        // åŠ¨æ€å®ä½“æ•°ç»„
        this.projectiles = [];
        this.explosions = [];
        this.selectedUnits = [];
        
        // è¾“å…¥å’Œé•œå¤´æ§åˆ¶
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };
        this.dragEnd = { x: 0, y: 0 };
        this.mousePos = { x: 0, y: 0 };
        this.globalMousePos = { x: 0, y: 0 }; // é¼ æ ‡åœ¨çª—å£ä¸­çš„ä½ç½®ï¼Œç”¨äºè¾¹ç¼˜æ»šåŠ¨
        this.isDraggingMap = false;
        this.lastDragPos = { x: 0, y: 0 };
        this.camera = { x: 0, y: 0, zoom: 1, minZoom: 0.5, maxZoom: 2.5 };
        
        // è§¦æ‘¸æ§åˆ¶
        this.activeTouches = new Map();
        this.lastTouchDistance = 0;
        this.lastTouchCenter = null;
    }

    /**
     * åˆå§‹åŒ–æ¸¸æˆã€‚
     * @param {object} settings - ä»è®¾ç½®ç•Œé¢ä¼ å…¥çš„æ¸¸æˆé…ç½®ã€‚
     */
    init(settings) {
        this.gameMode = settings.gameMode;
        this.showDetails = settings.showDetails;
        this.fromDialogue = settings.fromDialogue || false;
        this.user = settings.user || null;
        
        // åŠ è½½åœ°å›¾
        const selectedMapData = MAP_DEFINITIONS.find(m => m.id === settings.mapId);
        this.map = new GameMap();
        this.map.load(selectedMapData);

        const mapWidthPixels = this.map.width * TILE_SIZE;
        const mapHeightPixels = this.map.height * TILE_SIZE;
        
        // åˆå§‹åŒ–æ€§èƒ½ä¼˜åŒ–æ¨¡å—
        // ç©ºé—´ç½‘æ ¼çš„å•å…ƒæ ¼å°ºå¯¸é€šå¸¸è®¾ç½®ä¸ºæœ€å¤§å•ä½è§†é‡èŒƒå›´å·¦å³ï¼Œä»¥ä¿è¯ä¸€æ¬¡æŸ¥è¯¢å°±èƒ½è¦†ç›–é‚»å±…
        const gridCellSize = TILE_SIZE * 15; 
        this.spatialGrid = new SpatialGrid(mapWidthPixels, mapHeightPixels, gridCellSize);
        this.fogOfWar = new FogOfWar(mapWidthPixels, mapHeightPixels);
        
        // æ ¹æ®æ¸¸æˆæ¨¡å¼åˆ›å»ºåŸºåœ°
        const baseGridY = Math.floor(this.map.height / 2) - 1; 
        if (this.gameMode === 'annihilation' || this.gameMode === 'defend') {
            this.playerBase = new Base('player', 6, baseGridY);
            this.placeBaseOnMap(this.playerBase);
        }
        if (this.gameMode === 'annihilation' || this.gameMode === 'attack') {
            this.aiBase = new Base('ai', this.map.width - 9, baseGridY);
            this.placeBaseOnMap(this.aiBase);
        }

        // åˆ›å»ºç©å®¶å’ŒAI
        const initialManpower = 100;
        this.player = new Player('player', 'ç©å®¶', initialManpower);
        const aiManpower = settings.aiDifficulty === 'hell' ? Math.round(initialManpower * 1.5) : initialManpower;
        this.ai = new Player('ai', 'ç”µè„‘', aiManpower, true, {}, settings.aiDifficulty);
        
        // é“¾æ¥AIæ§åˆ¶å™¨å’Œç©å®¶åŸºåœ°
        this.ai.aiController.playerBase = this.playerBase;
        this.ai.aiController.deployUnits(this.map.width, this.map.height, TILE_SIZE);
        
        this.ui = new UI(this);
        this.gameSpeedModifier = GAME_SPEEDS[settings.gameSpeed];
        this.gameState = 'deployment';
        
        this.addEventListeners();
        this.setupInitialCamera();
        
        window.game = this; // æ–¹ä¾¿è°ƒè¯•
        requestAnimationFrame(this.gameLoop.bind(this));
    }
    
    /**
     * è®¾ç½®åˆå§‹é•œå¤´ä½ç½®ï¼Œèšç„¦äºç©å®¶åŸºåœ°æˆ–åœ°å›¾ä¸­å¿ƒã€‚
     */
    setupInitialCamera() {
        this.camera.zoom = 1.2;
        let focusPoint = this.playerBase 
            ? { x: this.playerBase.pixelX, y: this.playerBase.pixelY }
            : { x: (this.map.width * TILE_SIZE) / 2, y: (this.map.height * TILE_SIZE) / 2 };
        
        this.camera.x = focusPoint.x - (this.canvas.width / 2) / this.camera.zoom;
        this.camera.y = focusPoint.y - (this.canvas.height / 2) / this.camera.zoom;
        
        this.constrainCamera();
    }
    
    /**
     * æ¸¸æˆä¸»å¾ªç¯ã€‚
     * @param {number} currentTime - `requestAnimationFrame` ä¼ å…¥çš„æ—¶é—´æˆ³ã€‚
     */
    gameLoop(currentTime) {
        if (!this.lastTime) this.lastTime = currentTime;
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;
        
        const adjustedDeltaTime = deltaTime / this.gameSpeedModifier;
        
        this.update(adjustedDeltaTime);
        this.draw();
        this.ui.update();
        
        requestAnimationFrame(this.gameLoop.bind(this));
    }

    /**
     * æ›´æ–°æ‰€æœ‰æ¸¸æˆé€»è¾‘ã€‚
     * @param {number} deltaTime - ç»è¿‡æ¸¸æˆé€Ÿåº¦è°ƒæ•´åçš„å¸§æ—¶é—´å·®ã€‚
     */
    update(deltaTime) {
        if (this.gameState === 'gameover' || this.gameState === 'setup') return;

        this.handleEdgeScrolling(deltaTime);
        this.constrainCamera();

        const allPlayerUnits = this.player.units;
        const allAiUnits = this.ai.units;
        const allUnits = [...allPlayerUnits, ...allAiUnits];
        
        // æ€§èƒ½ä¼˜åŒ–ï¼šæ¯å¸§æ¸…ç©ºå¹¶é‡æ–°æ’å…¥æ‰€æœ‰å•ä½åˆ°ç©ºé—´ç½‘æ ¼
        this.spatialGrid.clear();
        allUnits.forEach(unit => this.spatialGrid.insert(unit));
        
        if (this.gameState === 'playing' || this.gameState === 'deployment') {
            // æ›´æ–°å•ä½é€»è¾‘ï¼Œå¹¶ä¼ å…¥ç©ºé—´ç½‘æ ¼ç”¨äºé«˜æ•ˆç´¢æ•Œ
            allPlayerUnits.forEach(unit => unit.update(deltaTime, allAiUnits, this.map, this.aiBase, this, this.spatialGrid));
            allAiUnits.forEach(unit => unit.update(deltaTime, allPlayerUnits, this.map, this.playerBase, this, this.spatialGrid));
            
            // AIç©å®¶çš„å®è§‚æ›´æ–°
            if (this.gameState === 'playing') {
                 this.ai.update(deltaTime, this.player, this.map, this.spatialGrid);
            }
        }
        
        // æ›´æ–°ç‰©ç†ï¼ˆç¢°æ’ï¼‰å’Œå¼¹é“
        this.updatePhysics(deltaTime, allUnits);
        this.updateProjectiles(deltaTime);

        // æ¸…ç†æ­»äº¡å•ä½å’Œè¿‡æœŸçš„ç‰¹æ•ˆ
        this.explosions = this.explosions.filter(e => !e.update(deltaTime));
        this.player.units = this.player.units.filter(u => u.hp > 0);
        this.ai.units = this.ai.units.filter(u => u.hp > 0);
        this.selectedUnits = this.selectedUnits.filter(u => u.hp > 0);
        
        // æ›´æ–°æˆ˜äº‰è¿·é›¾
        const visionSources = [...this.player.units, this.playerBase].filter(Boolean);
        this.fogOfWar.update(visionSources);

        if (this.gameState === 'playing') {
            this.checkWinConditions();
        }
    }

    /**
     * æ¸²æŸ“æ‰€æœ‰å¯è§çš„æ¸¸æˆå…ƒç´ ã€‚
     */
    draw() {
        // æ¸…å±
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.save();
        
        // åº”ç”¨é•œå¤´å˜æ¢
        this.ctx.scale(this.camera.zoom, this.camera.zoom);
        this.ctx.translate(-this.camera.x, -this.camera.y);

        // æ€§èƒ½ä¼˜åŒ–ï¼šè®¡ç®—é•œå¤´å¯è§èŒƒå›´ï¼Œåªç»˜åˆ¶èŒƒå›´å†…çš„ç‰©ä½“ (Culling)
        const viewBounds = {
            left: this.camera.x,
            top: this.camera.y,
            right: this.camera.x + this.canvas.width / this.camera.zoom,
            bottom: this.camera.y + this.canvas.height / this.camera.zoom
        };
        const isVisible = (entity, padding = TILE_SIZE * 2) => {
            const x = entity.pixelX || entity.x;
            const y = entity.pixelY || entity.y;
            return x > viewBounds.left - padding && x < viewBounds.right + padding &&
                   y > viewBounds.top - padding && y < viewBounds.bottom + padding;
        };

        // æŒ‰å±‚çº§ç»˜åˆ¶
        this.map.draw(this.ctx, this.camera);
        if (this.playerBase) this.playerBase.draw(this.ctx, this.camera.zoom);
        if (this.aiBase) this.aiBase.draw(this.ctx, this.camera.zoom);

        const allUnits = [...this.player.units, ...this.ai.units];
        const groundSeaUnits = allUnits.filter(u => u.stats.moveType !== 'air');
        const airUnits = allUnits.filter(u => u.stats.moveType === 'air');

        // 1. ç»˜åˆ¶åœ°é¢/æµ·ä¸Šå•ä½
        groundSeaUnits.forEach(unit => {
            if (isVisible(unit)) {
                unit.draw(this.ctx, this.selectedUnits.includes(unit), this.camera.zoom, this.showDetails);
            }
        });
        
        // 2. ç»˜åˆ¶å¼¹é“å’Œçˆ†ç‚¸
        this.projectiles.forEach(p => { if(isVisible(p)) p.draw(this.ctx); });
        this.explosions.forEach(e => { if(isVisible(e)) e.draw(this.ctx); });
        
        // 3. ç»˜åˆ¶ç©ºä¸­å•ä½ï¼ˆç¡®ä¿åœ¨å¼¹é“ä¹‹ä¸Šï¼‰
        airUnits.forEach(unit => {
             if (isVisible(unit)) {
                unit.draw(this.ctx, this.selectedUnits.includes(unit), this.camera.zoom, this.showDetails);
            }
        });

        // 4. ç»˜åˆ¶æˆ˜äº‰è¿·é›¾
        this.fogOfWar.draw(this.ctx);

        this.ctx.restore();
        
        // ç»˜åˆ¶UIå…ƒç´ ï¼ˆå¦‚é€‰æ‹©æ¡†ï¼‰ï¼Œä¸å—é•œå¤´å½±å“
        if (this.isDragging && !this.isDraggingMap) {
            this.ctx.strokeStyle = 'rgba(100, 255, 100, 0.7)';
            this.ctx.lineWidth = 1;
            const rect = { 
                x: Math.min(this.dragStart.x, this.dragEnd.x), 
                y: Math.min(this.dragStart.y, this.dragEnd.y),
                w: Math.abs(this.dragStart.x - this.dragEnd.x),
                h: Math.abs(this.dragStart.y - this.dragEnd.y)
            };
            this.ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
        }
    }
    
    /**
     * æ›´æ–°å¼¹é“é€»è¾‘ï¼Œå¤„ç†å‘½ä¸­å’Œé”€æ¯ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    updateProjectiles(deltaTime) {
        const remainingProjectiles = [];
        for (const p of this.projectiles) {
            if (!p.update(deltaTime)) { // updateè¿”å›trueè¡¨ç¤ºå¼¹é“ç”Ÿå‘½å‘¨æœŸç»“æŸ
                remainingProjectiles.push(p);
            } else {
                this.handleProjectileHit(p);
            }
        }
        this.projectiles = remainingProjectiles;
    }

    /**
     * æ ¸å¿ƒé‡æ„: ä½¿ç”¨ç©ºé—´ç½‘æ ¼è¿›è¡Œé«˜æ•ˆçš„ç‰©ç†ç¢°æ’æ£€æµ‹ã€‚
     * é¿å…äº† O(n^2) çš„å…¨å±€éå†ï¼Œæ˜¾è‘—æå‡å•ä½å¤šæ—¶çš„æ€§èƒ½ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @param {Array<Unit>} allUnits - åœºæ™¯ä¸­çš„æ‰€æœ‰å•ä½ã€‚
     */
    updatePhysics(deltaTime, allUnits) {
        const PUSH_FORCE = 30;
        const processedPairs = new Set(); // é˜²æ­¢A-Bå’ŒB-Aé‡å¤è®¡ç®—

        for (const unitA of allUnits) {
            // ä»ç©ºé—´ç½‘æ ¼è·å–é™„è¿‘çš„å•ä½ï¼Œè€Œä¸æ˜¯éå†æ‰€æœ‰å•ä½
            const nearbyUnits = this.spatialGrid.getNearby(unitA);
            
            for (const unitB of nearbyUnits) {
                if (unitA.id === unitB.id) continue;

                // ä½¿ç”¨IDç»„åˆæ¥å”¯ä¸€æ ‡è¯†ä¸€å¯¹å•ä½ï¼Œé¿å…é‡å¤å¤„ç†
                const pairKey = unitA.id < unitB.id ? `${unitA.id}-${unitB.id}` : `${unitB.id}-${unitA.id}`;
                if (processedPairs.has(pairKey)) continue;
                processedPairs.add(pairKey);

                // ç©ºä¸­å•ä½å’Œéç©ºä¸­å•ä½ä¹‹é—´ä¸å‘ç”Ÿç¢°æ’
                const isAirA = unitA.stats.moveType === 'air';
                const isAirB = unitB.stats.moveType === 'air';
                if (isAirA !== isAirB) {
                    continue;
                }

                const distance = getDistance(unitA, unitB);
                // ä½¿ç”¨æ›´ç²¾ç¡®çš„åŠå¾„è¿›è¡Œç¢°æ’æ£€æµ‹
                const collisionRadius = (unitA.stats.drawScale + unitB.stats.drawScale) / 2 * (TILE_SIZE / 4);
                
                if (distance > 0 && distance < collisionRadius) {
                    const overlap = collisionRadius - distance;
                    const angle = Math.atan2(unitB.y - unitA.y, unitB.x - unitA.x);
                    
                    // æ ¹æ®é‡å ç¨‹åº¦å’ŒdeltaTimeè®¡ç®—æ¨å¼€çš„é‡
                    const pushAmount = overlap * PUSH_FORCE * deltaTime;
                    const pushX = Math.cos(angle) * pushAmount;
                    const pushY = Math.sin(angle) * pushAmount;
                    
                    // ä¸¤ä¸ªå•ä½å„æ¨å¼€ä¸€åŠ
                    unitA.x -= pushX * 0.5;
                    unitA.y -= pushY * 0.5;
                    unitB.x += pushX * 0.5;
                    unitB.y += pushY * 0.5;
                }
            }
        }
    }

    // --- äº‹ä»¶ç›‘å¬ä¸å¤„ç† ---
    
    addEventListeners() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        window.addEventListener('keydown', (e) => { 
            if (e.key === 'Escape') {
                this.selectedUnits = [];
                this.ui.clearDeploymentSelection();
            }
        });
        
        // è§¦æ‘¸äº‹ä»¶
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
        this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
    }

    handleMouseDown(e) {
        const pos = this.getMousePos(e);
        // å·¦é”®æˆ–ä¸­é”®æ‹–åŠ¨åœ°å›¾
        if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
            this.isDraggingMap = true;
            this.lastDragPos = { x: e.clientX, y: e.clientY };
            this.canvas.style.cursor = 'grabbing';
        } 
        // å·¦é”®å¼€å§‹é€‰æ‹©
        else if (e.button === 0) {
            this.isDragging = true;
            this.dragStart = pos;
            this.dragEnd = pos;
        }
    }

    handleMouseMove(e) {
        this.mousePos = this.getMousePos(e);
        this.globalMousePos = { x: e.clientX, y: e.clientY };
        
        if (this.isDraggingMap) {
            const dx = e.clientX - this.lastDragPos.x;
            const dy = e.clientY - this.lastDragPos.y;
            this.camera.x -= dx / this.camera.zoom;
            this.camera.y -= dy / this.camera.zoom;
            this.lastDragPos = { x: e.clientX, y: e.clientY };
        } else if (this.isDragging) {
            this.dragEnd = this.mousePos;
        }
    }

    handleMouseUp(e) {
        // å³é”®å‘½ä»¤
        if (e.button === 2) {
            const pos = this.getMousePos(e);
            this.handleRightClick(this.screenToWorld(pos.x, pos.y));
            return;
        }

        if (this.isDraggingMap) {
            this.isDraggingMap = false;
            this.canvas.style.cursor = 'default';
        } else if (this.isDragging) {
            this.isDragging = false;
            const pos = this.getMousePos(e);
            
            // å¦‚æœæ‹–åŠ¨è·ç¦»å¾ˆå°ï¼Œè§†ä¸ºå•å‡»
            if (getDistance(this.dragStart, pos) < 10) {
                this.handleLeftClick(this.screenToWorld(pos.x, pos.y));
            } else {
                this.handleBoxSelection();
            }
        }
    }
    
    /**
     * å¤„ç†å·¦é”®å•å‡»äº‹ä»¶ã€‚
     * @param {{x: number, y: number}} worldPos - ç‚¹å‡»ä½ç½®çš„ä¸–ç•Œåæ ‡ã€‚
     */
    handleLeftClick(worldPos) {
        // å¦‚æœUIä¸­é€‰æ‹©äº†å¾…éƒ¨ç½²å•ä½ï¼Œåˆ™å°è¯•éƒ¨ç½²
        if (this.ui.selectedUnitToDeploy) {
            this.tryDeployUnit(worldPos, this.ui.selectedUnitToDeploy);
            return;
        }
        
        // å¦‚æœå½“å‰æœ‰å•ä½è¢«é€‰ä¸­ï¼Œåˆ™æ¸…é™¤é€‰æ‹©
        if (this.selectedUnits.length > 0) {
            this.issueCommandForSelectedUnits(worldPos);
            return;
        }

        // å°è¯•é€‰ä¸­ä¸€ä¸ªå•ä½
        const clickedUnit = this.player.units.find(unit => getDistance(worldPos, unit) < TILE_SIZE / 2);
        this.selectedUnits = clickedUnit ? [clickedUnit] : [];
    }

    /**
     * å¤„ç†å³é”®å•å‡»äº‹ä»¶ï¼Œä¸ºé€‰ä¸­çš„å•ä½ä¸‹è¾¾å‘½ä»¤ã€‚
     * @param {{x: number, y: number}} worldPos - ç‚¹å‡»ä½ç½®çš„ä¸–ç•Œåæ ‡ã€‚
     */
    handleRightClick(worldPos) {
        if (this.selectedUnits.length > 0) {
            this.issueCommandForSelectedUnits(worldPos);
        }
    }

    /**
     * ä¸ºå½“å‰é€‰ä¸­çš„å•ä½ä¸‹è¾¾ç§»åŠ¨æˆ–æ”»å‡»å‘½ä»¤ã€‚
     * @param {{x: number, y: number}} worldPos - ç›®æ ‡ä¸–ç•Œåæ ‡ã€‚
     */
    issueCommandForSelectedUnits(worldPos) {
        let targetEnemy = null;
        const allEnemies = [...this.ai.units, this.aiBase].filter(Boolean);
        
        // æ£€æŸ¥æ˜¯å¦ç‚¹ä¸­äº†æ•Œäºº
        for (const enemy of allEnemies) {
            const enemyPos = { x: enemy.pixelX || enemy.x, y: enemy.pixelY || enemy.y };
            const clickRadius = (enemy instanceof Base) ? (enemy.width * TILE_SIZE / 2) : (TILE_SIZE / 2);
            if (getDistance(worldPos, enemyPos) < clickRadius) {
                targetEnemy = enemy;
                break;
            }
        }
        
        // å¦‚æœç‚¹ä¸­äº†æ•Œäººï¼Œåˆ™ä¸‹è¾¾æ”»å‡»å‘½ä»¤
        if (targetEnemy) {
            this.selectedUnits.forEach(unit => unit.target = targetEnemy);
        } 
        // å¦åˆ™ï¼Œä¸‹è¾¾ç§»åŠ¨å‘½ä»¤
        else {
            this.selectedUnits.forEach(unit => unit.target = null);
            if (this.selectedUnits.length === 1) {
                this.selectedUnits[0].issueMoveCommand(worldPos, this.map);
            } else {
                this.issueGroupMoveCommand(worldPos, this.map);
            }
        }
    }

    /**
     * åœ¨æŒ‡å®šä½ç½®éƒ¨ç½²ä¸€ä¸ªå•ä½ã€‚
     * @param {{x: number, y: number}} worldPos - éƒ¨ç½²ä½ç½®çš„ä¸–ç•Œåæ ‡ã€‚
     * @param {string} unitType - è¦éƒ¨ç½²çš„å•ä½ç±»å‹IDã€‚
     */
    tryDeployUnit(worldPos, unitType) {
        const cost = UNIT_TYPES[unitType].cost;
        
        // æ£€æŸ¥èµ„æºå’Œéƒ¨ç½²åŒºåŸŸ
        if (this.player.canAfford(cost) && worldPos.x < (this.map.width * TILE_SIZE) / 3) {
            const gridX = Math.floor(worldPos.x / TILE_SIZE);
            const gridY = Math.floor(worldPos.y / TILE_SIZE);
            const tile = this.map.getTile(gridX, gridY);
            const unitStats = UNIT_TYPES[unitType];

            // æ£€æŸ¥åœ°å½¢æ˜¯å¦å¯é€šè¡Œ
            const isTraversable = tile && TERRAIN_TYPES[tile.type].traversableBy.includes(unitStats.moveType);
            if (unitStats.moveType === 'air' || isTraversable) {
                this.player.units.push(new Unit(unitType, 'player', worldPos.x, worldPos.y));
                this.player.deductManpower(cost);
                this.ui.update();
            } else {
                this.ui.showGameMessage("è¯¥å•ä½æ— æ³•éƒ¨ç½²åœ¨æ­¤åœ°å½¢ä¸Šï¼");
            }
        } else {
            if (!this.player.canAfford(cost)) {
                this.ui.showGameMessage("èµ„æºä¸è¶³ï¼");
            } else {
                this.ui.showGameMessage("åªèƒ½åœ¨åœ°å›¾å·¦ä¾§1/3åŒºåŸŸéƒ¨ç½²ï¼");
            }
        }
    }

    /**
     * å¤„ç†é¼ æ ‡æ‹–æ‹½ç»“æŸåçš„æ¡†é€‰é€»è¾‘ã€‚
     */
    handleBoxSelection() {
        this.ui.clearDeploymentSelection();
        this.selectedUnits = [];
        
        const rect = { 
            x: Math.min(this.dragStart.x, this.dragEnd.x), 
            y: Math.min(this.dragStart.y, this.dragEnd.y),
            w: Math.abs(this.dragStart.x - this.dragEnd.x),
            h: Math.abs(this.dragStart.y - this.dragEnd.y)
        };
        
        this.player.units.forEach(unit => {
            const screenPos = this.worldToScreen(unit.x, unit.y);
            if (screenPos.x > rect.x && screenPos.x < rect.x + rect.w && 
                screenPos.y > rect.y && screenPos.y < rect.y + rect.h) {
                this.selectedUnits.push(unit);
            }
        });
    }

    /**
     * ä¸ºå¤šä¸ªå•ä½ä¸‹è¾¾ç§»åŠ¨å‘½ä»¤ï¼Œå¹¶ä¿æŒå…¶ç›¸å¯¹é˜µå‹ã€‚
     * @param {{x: number, y: number}} targetPos - ç›®æ ‡ç‚¹çš„ä¸–ç•Œåæ ‡ã€‚
     * @param {GameMap} map - æ¸¸æˆåœ°å›¾ã€‚
     */
    issueGroupMoveCommand(targetPos, map) {
        if (this.selectedUnits.length === 0) return;
        
        // è®¡ç®—é€‰ä¸­å•ä½çš„å‡ ä½•ä¸­å¿ƒ
        const centroid = this.selectedUnits.reduce((acc, unit) => ({ x: acc.x + unit.x, y: acc.y + unit.y }), { x: 0, y: 0 });
        centroid.x /= this.selectedUnits.length;
        centroid.y /= this.selectedUnits.length;
        
        // è®¡ç®—æ¯ä¸ªå•ä½ç›¸å¯¹äºä¸­å¿ƒçš„åç§»é‡
        const offsets = this.selectedUnits.map(unit => ({ dx: unit.x - centroid.x, dy: unit.y - centroid.y }));
        
        // ä¸ºæ¯ä¸ªå•ä½è®¾ç½®å¸¦æœ‰åç§»é‡çš„ç›®æ ‡ç‚¹
        this.selectedUnits.forEach((unit, index) => {
            const unitTargetPos = { 
                x: targetPos.x + offsets[index].dx,
                y: targetPos.y + offsets[index].dy 
            };
            unit.issueMoveCommand(unitTargetPos, map);
        });
    }

    // --- åæ ‡è½¬æ¢ä¸é•œå¤´ ---
    
    getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        return { 
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY 
        };
    }
    
    worldToScreen(worldX, worldY) {
        return { 
            x: (worldX - this.camera.x) * this.camera.zoom,
            y: (worldY - this.camera.y) * this.camera.zoom 
        };
    }

    screenToWorld(screenX, screenY) {
        return {
            x: screenX / this.camera.zoom + this.camera.x,
            y: screenY / this.camera.zoom + this.camera.y 
        };
    }
    
    constrainCamera() {
        if (!this.map) return;
        const mapWidthPixels = this.map.width * TILE_SIZE;
        const mapHeightPixels = this.map.height * TILE_SIZE;
        const viewWidth = this.canvas.width / this.camera.zoom;
        const viewHeight = this.canvas.height / this.camera.zoom;
        
        this.camera.x = Math.max(0, Math.min(this.camera.x, mapWidthPixels - viewWidth));
        this.camera.y = Math.max(0, Math.min(this.camera.y, mapHeightPixels - viewHeight));
    }
    
    handleWheel(e) {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 1.05 : 0.95;
        this.zoomAtPoint(zoomFactor, this.getMousePos(e));
    }

    zoomAtPoint(factor, point) {
        const oldZoom = this.camera.zoom;
        const newZoom = Math.max(this.camera.minZoom, Math.min(this.camera.maxZoom, oldZoom / factor));
        if (newZoom === oldZoom) return;
        
        const worldMouseX = point.x / oldZoom + this.camera.x;
        const worldMouseY = point.y / oldZoom + this.camera.y;
        
        this.camera.zoom = newZoom;
        this.camera.x = worldMouseX - point.x / newZoom;
        this.camera.y = worldMouseY - point.y / newZoom;
    }

    // --- è§¦æ‘¸æ§åˆ¶ ---

    handleTouchStart(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            this.activeTouches.set(touch.identifier, this.getTouchPos(touch));
        }
        this.updateTouchState();
    }
    
    handleTouchMove(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            this.activeTouches.set(touch.identifier, this.getTouchPos(touch));
        }
        
        const touches = Array.from(this.activeTouches.values());
        // åŒæŒ‡ç¼©æ”¾å’Œæ‹–åŠ¨
        if (touches.length === 2) {
            const currentCenter = { x: (touches[0].x + touches[1].x) / 2, y: (touches[0].y + touches[1].y) / 2 };
            const currentDistance = getDistance(touches[0], touches[1]);
            
            if (this.lastTouchCenter) {
                const dx = currentCenter.x - this.lastTouchCenter.x;
                const dy = currentCenter.y - this.lastTouchCenter.y;
                this.camera.x -= dx / this.camera.zoom;
                this.camera.y -= dy / this.camera.zoom;
            }
            if (this.lastTouchDistance > 0) {
                const zoomFactor = this.lastTouchDistance / currentDistance;
                this.zoomAtPoint(zoomFactor, currentCenter);
            }
            
            this.lastTouchCenter = currentCenter;
            this.lastTouchDistance = currentDistance;
        }
    }
    
    handleTouchEnd(e) {
        for (const touch of e.changedTouches) {
            this.activeTouches.delete(touch.identifier);
        }
        this.updateTouchState();
    }
    
    updateTouchState() {
        if (this.activeTouches.size < 2) {
            this.lastTouchDistance = 0;
            this.lastTouchCenter = null;
        }
    }
    
    getTouchPos(touch) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        return { 
            x: (touch.clientX - rect.left) * scaleX,
            y: (touch.clientY - rect.top) * scaleY 
        };
    }
    
    // --- æ¸¸æˆæµç¨‹ ---

    /**
     * é¼ æ ‡é è¿‘å±å¹•è¾¹ç¼˜æ—¶æ»šåŠ¨åœ°å›¾ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    handleEdgeScrolling(deltaTime) {
        if (this.isDraggingMap || this.isDragging || this.activeTouches.size > 0) return;
        
        const edgeMargin = 20;
        const scrollSpeed = 600 / this.camera.zoom;
        
        if (this.globalMousePos.x < edgeMargin) this.camera.x -= scrollSpeed * deltaTime;
        if (this.globalMousePos.x > window.innerWidth - edgeMargin) this.camera.x += scrollSpeed * deltaTime;
        if (this.globalMousePos.y < edgeMargin) this.camera.y -= scrollSpeed * deltaTime;
        if (this.globalMousePos.y > window.innerHeight - edgeMargin) this.camera.y += scrollSpeed * deltaTime;
    }
    
    /**
     * å¤„ç†å¼¹é“å‘½ä¸­é€»è¾‘ï¼ŒåŒ…æ‹¬ç›´æ¥ä¼¤å®³å’Œæº…å°„ä¼¤å®³ã€‚
     * @param {Projectile} p - å‘½ä¸­çš„å¼¹é“å¯¹è±¡ã€‚
     */
    handleProjectileHit(p) {
        this.explosions.push(new Explosion(p.x, p.y, p.stats.splashRadius || 10));

        // å¯¹ä¸»ç›®æ ‡é€ æˆä¼¤å®³
        if (p.target && p.target.hp > 0) {
            p.target.takeDamage(p.stats.damage);
        }

        // å¤„ç†æº…å°„ä¼¤å®³
        if (p.stats.splashRadius > 0) {
            const allTargets = [...this.player.units, ...this.ai.units, this.playerBase, this.aiBase].filter(Boolean);
            allTargets.forEach(entity => {
                if (entity.owner !== p.owner && entity.id !== p.target?.id && entity.hp > 0) {
                    const entityPos = { x: entity.pixelX || entity.x, y: entity.pixelY || entity.y };
                    const distance = getDistance(entityPos, p);
                    if (distance < p.stats.splashRadius) {
                        // ä¼¤å®³éšè·ç¦»è¡°å‡
                        const splashDamage = p.stats.damage * (1 - distance / p.stats.splashRadius);
                        entity.takeDamage(splashDamage);
                    }
                }
            });
        }
    }

    /**
     * å¼€å§‹æˆ˜æ–—ï¼Œå°†æ¸¸æˆçŠ¶æ€ä» 'deployment' åˆ‡æ¢åˆ° 'playing'ã€‚
     */
    startGame() {
        if (this.gameState === 'deployment') {
            this.gameState = 'playing';
        }
    }
    
    /**
     * æ£€æŸ¥èƒœåˆ©æˆ–å¤±è´¥æ¡ä»¶ã€‚
     */
    checkWinConditions() {
        if (this.gameState !== 'playing') return;
        
        const minCost = Math.min(...Object.values(UNIT_TYPES).map(u => u.cost));
        const pCanDeploy = this.player.manpower >= minCost;
        const pOutOfForces = this.player.units.length === 0 && !pCanDeploy;

        switch (this.gameMode) {
            case 'annihilation': // æ­¼ç­æ¨¡å¼
                if (this.playerBase?.hp <= 0) this.endGame(this.ai);
                else if (this.aiBase?.hp <= 0) this.endGame(this.player);
                break;
            case 'attack': // è¿›æ”»æ¨¡å¼
                if (this.aiBase?.hp <= 0) this.endGame(this.player);
                else if (pOutOfForces) this.endGame(this.ai);
                break;
            case 'defend': // é˜²å®ˆæ¨¡å¼
                if (this.playerBase?.hp <= 0) this.endGame(this.ai);
                else if (this.ai.units.length === 0 && this.ai.manpower < minCost) this.endGame(this.player);
                break;
        }
    }

    /**
     * ç»“æŸæ¸¸æˆå¹¶å®£å¸ƒèƒœåˆ©è€…ã€‚
     * @param {Player} winner - èƒœåˆ©çš„ç©å®¶å¯¹è±¡ã€‚
     */
    endGame(winner) {
        if (this.gameState === 'gameover') return;
        this.gameState = 'gameover';
        console.log(`${winner.name} è·èƒœ!`);
        this.ui.showWinner(winner.name);
        
        if (this.returnToDialogue()) {
            return;
        }
    }
    
    returnToDialogue() {
        const urlParams = new URLSearchParams(window.location.search);
        const fromDialogue = urlParams.get('fromDialogue');
        const user = urlParams.get('user');
        
        if (fromDialogue === 'true') {
            window.location.href = `./loading.html?target=dialogue.html&returnFromGame=true&user=${user}`;
            return true;
        }
        return false;
    }
    
    /**
     * åœ¨åœ°å›¾ä¸Šæ”¾ç½®åŸºåœ°ï¼Œå¹¶å°†å…¶åœ°å—ç±»å‹è®¾ä¸º'base'ã€‚
     * @param {Base} base - è¦æ”¾ç½®çš„åŸºåœ°å¯¹è±¡ã€‚
     */
    placeBaseOnMap(base) {
        for (let y = 0; y < base.height; y++) {
            for (let x = 0; x < base.width; x++) {
                this.map.setTileType(base.gridX + x, base.gridY + y, 'base');
            }
        }
    }
}
```

---

### `fog-of-war.js`
```javascript
// js/fog-of-war.js

import { TILE_SIZE } from './config.js';

/**
 * @class FogOfWar
 * @description ç®¡ç†æˆ˜äº‰è¿·é›¾æ•ˆæœã€‚
 * ä½¿ç”¨ä¸€ä¸ªç¦»å±Canvasè¿›è¡Œé¢„æ¸²æŸ“ä»¥æå‡æ€§èƒ½ã€‚
 */
export class FogOfWar {
    /**
     * @param {number} mapWidth - åœ°å›¾æ€»åƒç´ å®½åº¦ã€‚
     * @param {number} mapHeight - åœ°å›¾æ€»åƒç´ é«˜åº¦ã€‚
     */
    constructor(mapWidth, mapHeight) {
        this.mapWidth = mapWidth;
        this.mapHeight = mapHeight;

        // åˆ›å»ºç¦»å±Canvasç”¨äºç»˜åˆ¶è¿·é›¾
        this.fogCanvas = document.createElement('canvas');
        this.fogCanvas.width = this.mapWidth;
        this.fogCanvas.height = this.mapHeight;
        this.fogCtx = this.fogCanvas.getContext('2d');
    }

    /**
     * æ ¹æ®ç©å®¶å•ä½å’Œå»ºç­‘çš„ä½ç½®æ›´æ–°è¿·é›¾çº¹ç†ã€‚
     * è¿™æ˜¯ä¸€ä¸ªè®¡ç®—å¯†é›†å‹æ“ä½œï¼Œä½†ç”±äºåœ¨ç¦»å±Canvasä¸Šè¿›è¡Œï¼Œä¸ä¼šé˜»å¡ä¸»æ¸²æŸ“çº¿ç¨‹ã€‚
     * @param {Array<Unit|Base>} visibleEntities - ç©å®¶çš„æ‰€æœ‰å•ä½å’ŒåŸºåœ°æ•°ç»„ï¼Œç”¨äºæä¾›è§†é‡ã€‚
     */
    update(visibleEntities) {
        const ctx = this.fogCtx;

        // 1. å…ˆç”¨çº¯é»‘ fog è¦†ç›–æ•´ä¸ªåœ°å›¾
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, this.mapWidth, this.mapHeight);

        // 2. ä½¿ç”¨ 'destination-out' æ¨¡å¼åœ¨ fog ä¸Šâ€œå‡¿å¼€â€è§†é‡åŒºåŸŸ
        ctx.globalCompositeOperation = 'destination-out';

        visibleEntities.forEach(entity => {
            // ä¸ºå•ä½æˆ–åŸºåœ°è®¾ç½®è§†é‡èŒƒå›´
            const vision = entity.stats ? entity.stats.visionRange : 10 * TILE_SIZE; // åŸºåœ°é»˜è®¤è§†é‡
            const entityX = entity.pixelX || entity.x;
            const entityY = entity.pixelY || entity.y;
            
            // åˆ›å»ºä¸€ä¸ªå¾„å‘æ¸å˜ï¼Œå®ç°è§†é‡è¾¹ç¼˜çš„å¹³æ»‘è¿‡æ¸¡æ•ˆæœ
            const gradient = ctx.createRadialGradient(entityX, entityY, vision * 0.7, entityX, entityY, vision);
            gradient.addColorStop(0, 'rgba(0,0,0,1)'); // ä¸­å¿ƒå®Œå…¨é€æ˜
            gradient.addColorStop(1, 'rgba(0,0,0,0)'); // è¾¹ç¼˜æ¸å˜ä¸ºä¸é€æ˜

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(entityX, entityY, vision, 0, Math.PI * 2);
            ctx.fill();
        });

        // é‡ç½®æ··åˆæ¨¡å¼ï¼Œä»¥å¤‡ä¸‹æ¬¡æ›´æ–°
        ctx.globalCompositeOperation = 'source-over';
    }

    /**
     * å°†é¢„æ¸²æŸ“å¥½çš„è¿·é›¾Canvasç»˜åˆ¶åˆ°ä¸»æ¸¸æˆCanvasä¸Šã€‚
     * è¿™æ˜¯ä¸€ä¸ªéå¸¸å¿«é€Ÿçš„å›¾åƒç»˜åˆ¶æ“ä½œã€‚
     * @param {CanvasRenderingContext2D} mainCtx - ä¸»æ¸¸æˆçš„æ¸²æŸ“ä¸Šä¸‹æ–‡ã€‚
     */
    draw(mainCtx) {
        mainCtx.drawImage(this.fogCanvas, 0, 0);
    }
}
```

---

### `main.js`
```javascript
// js/main.js

import { Game } from './game.js';
import { MAP_DEFINITIONS } from './maps-data.js';
import { UNIT_TYPES } from './config.js';

/**
 * @class AssetManager
 * @description ä¸€ä¸ªç®€å•çš„èµ„æºç®¡ç†å™¨ï¼Œç”¨äºé¢„åŠ è½½å›¾ç‰‡ã€‚
 */
class AssetManager {
    constructor() {
        this.assets = {};
        this.downloadQueue = [];
        this.successCount = 0;
        this.errorCount = 0;
    }

    /**
     * å°†ä¸€ä¸ªå›¾ç‰‡è·¯å¾„æ·»åŠ åˆ°ä¸‹è½½é˜Ÿåˆ—ã€‚
     * @param {string} path - å›¾ç‰‡çš„URLã€‚
     */
    queueDownload(path) {
        if (path && !this.downloadQueue.includes(path)) {
            this.downloadQueue.push(path);
        }
    }

    /**
     * æ£€æŸ¥æ˜¯å¦æ‰€æœ‰èµ„æºéƒ½å·²åŠ è½½å®Œæˆï¼ˆæ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼‰ã€‚
     * @returns {boolean}
     */
    isDone() {
        return this.downloadQueue.length === this.successCount + this.errorCount;
    }

    /**
     * å¼€å§‹ä¸‹è½½é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èµ„æºã€‚
     * @param {function} callback - æ‰€æœ‰èµ„æºåŠ è½½å®Œæˆåè°ƒç”¨çš„å›è°ƒå‡½æ•°ã€‚
     */
    downloadAll(callback) {
        if (this.downloadQueue.length === 0) {
            callback();
            return;
        }
        
        this.downloadQueue.forEach(path => {
            const img = new Image();
            img.onload = () => {
                this.successCount++;
                if (this.isDone()) {
                    callback();
                }
            };
            img.onerror = () => {
                this.errorCount++;
                console.error("Error loading image: " + path);
                if (this.isDone()) {
                    callback();
                }
            };
            img.src = path;
            this.assets[path] = img;
        });
    }
}

// DOMåŠ è½½å®Œæˆåæ‰§è¡Œ
window.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('game-canvas');
    const setupScreen = document.getElementById('setup-screen');
    const startNewGameBtn = document.getElementById('start-new-game-btn');
    const mapSelect = document.getElementById('map-select');
    
    // åŠ¨æ€å¡«å……åœ°å›¾é€‰æ‹©ä¸‹æ‹‰æ¡†
    MAP_DEFINITIONS.forEach(map => {
        const option = document.createElement('option');
        option.value = map.id;
        option.textContent = map.name;
        mapSelect.appendChild(option);
    });

    // é¢„åŠ è½½æ‰€æœ‰å•ä½å›¾ç‰‡
    const assetManager = new AssetManager();
    Object.values(UNIT_TYPES).forEach(unit => {
        assetManager.queueDownload(unit.imageSrc);
    });
    
    // å°†åŠ è½½å¥½çš„å›¾ç‰‡å­˜æ”¾åœ¨å…¨å±€ï¼Œæ–¹ä¾¿æ¸¸æˆå†…å…¶ä»–æ¨¡å—è®¿é—®
    window.assetManager = assetManager.assets; 
    
    startNewGameBtn.disabled = true;
    startNewGameBtn.textContent = 'æ­£åœ¨åŠ è½½èµ„æº...';
    assetManager.downloadAll(() => {
        startNewGameBtn.disabled = false;
        startNewGameBtn.textContent = 'åˆ›å»ºæ¸¸æˆ';
    });
    
    /**
     * è°ƒæ•´æ¸¸æˆCanvaså°ºå¯¸ä»¥é€‚åº”çª—å£å˜åŒ–ã€‚
     */
    function resizeGame() {
        const sidebar = document.getElementById('sidebar');
        const sidebarWidth = sidebar ? sidebar.offsetWidth : 0;
        canvas.width = window.innerWidth - sidebarWidth;
        canvas.height = window.innerHeight;
        
        // å¦‚æœæ¸¸æˆå·²ç»å¼€å§‹ï¼Œåˆ™çº¦æŸé•œå¤´èŒƒå›´
        if (window.game && window.game.constrainCamera) {
            window.game.constrainCamera();
        }
    }

    resizeGame();
    window.addEventListener('resize', resizeGame);

    // "åˆ›å»ºæ¸¸æˆ" æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    startNewGameBtn.addEventListener('click', () => {
        const urlParams = new URLSearchParams(window.location.search);
        
        const showDetailsCheckbox = document.getElementById('show-details-checkbox');
        
        // ä»UIæ”¶é›†æ¸¸æˆè®¾ç½®
        const settings = {
            gameMode: document.getElementById('game-mode-select').value,
            mapId: mapSelect.value,
            gameSpeed: document.getElementById('game-speed-select').value,
            aiDifficulty: document.getElementById('ai-difficulty-select').value,
            showDetails: showDetailsCheckbox.checked, // è¯»å–å¤é€‰æ¡†çŠ¶æ€
            fromDialogue: urlParams.get('fromDialogue') === 'true',
            user: urlParams.get('user')
        };
        
        setupScreen.style.display = 'none';
        
        const game = new Game(canvas);
        game.init(settings);
    });
});
```

---

### `map.js`
```javascript
// js/map.js

import { TILE_SIZE, TERRAIN_TYPES } from './config.js';

/**
 * ç”Ÿæˆä¸€ä¸ªåŸºäºç§å­çš„ä¼ªéšæœºæ•°ã€‚
 * @param {number} seed - ç§å­ã€‚
 * @returns {number} - è¿”å›ä¸€ä¸ªåœ¨ [0, 1) åŒºé—´å†…çš„æµ®ç‚¹æ•°ã€‚
 */
function seededRandom(seed) {
    let x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
}

/**
 * @class GameMap
 * @description ç®¡ç†æ¸¸æˆåœ°å›¾æ•°æ®å’Œæ¸²æŸ“ã€‚
 */
export class GameMap {
    constructor() {
        this.width = 0;
        this.height = 0;
        this.grid = []; // äºŒç»´æ•°ç»„ï¼Œå­˜å‚¨æ¯ä¸ªæ ¼å­çš„åœ°å½¢ä¿¡æ¯
        this.terrainDetails = new Map(); // ç¼“å­˜åœ°å½¢ç»†èŠ‚ï¼Œé¿å…é‡å¤è®¡ç®—
    }

    /**
     * ä»åœ°å›¾æ•°æ®åŠ è½½åœ°å›¾ã€‚
     * @param {object} mapData - æ¥è‡ª maps-data.js çš„åœ°å›¾å®šä¹‰å¯¹è±¡ã€‚
     */
    load(mapData) {
        this.width = mapData.width;
        this.height = mapData.height;
        const terrainMap = { 'g': 'grass', 'f': 'forest', 'r': 'road', 'w': 'water', 'b': 'building' };
        
        this.grid = Array(this.height).fill(null).map(() => Array(this.width).fill(null));
        
        for (let y = 0; y < this.height; y++) {
            const rowString = mapData.grid[y] || '';
            for (let x = 0; x < this.width; x++) {
                const char = rowString[x] || 'g'; // é»˜è®¤ä¸ºè‰åœ°
                const type = terrainMap[char];
                this.grid[y][x] = { type };
            }
        }
    }

    /**
     * ç»˜åˆ¶åœ°å›¾ï¼ŒåŒ…å«åœ°å½¢æ··åˆå’Œç»†èŠ‚æ¸²æŸ“ã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {object} camera - é•œå¤´å¯¹è±¡ï¼Œç”¨äºè§†å£å‰”é™¤ã€‚
     */
    draw(ctx, camera) {
        // è®¡ç®—éœ€è¦æ¸²æŸ“çš„æ ¼å­èŒƒå›´ (è§†å£å‰”é™¤)
        const startX = Math.floor(camera.x / TILE_SIZE);
        const startY = Math.floor(camera.y / TILE_SIZE);
        const endX = Math.ceil((camera.x + ctx.canvas.width / camera.zoom) / TILE_SIZE);
        const endY = Math.ceil((camera.y + ctx.canvas.height / camera.zoom) / TILE_SIZE);

        for (let y = startY; y < endY; y++) {
            for (let x = startX; x < endX; x++) {
                if (x < 0 || y < 0 || x >= this.width || y >= this.height) continue;
                
                const tile = this.getTile(x, y);
                if (!tile) continue;
                
                // 1. ç»˜åˆ¶åŸºç¡€åœ°å½¢é¢œè‰²
                const baseColor = TERRAIN_TYPES[tile.type].color;
                ctx.fillStyle = baseColor;
                ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE + 1, TILE_SIZE + 1); // +1 ä¿®å¤æ ¼å­é—´ç¼éš™

                // 2. ç»˜åˆ¶åœ°å½¢è¾¹ç¼˜æ··åˆæ•ˆæœ
                this.drawTerrainBlend(ctx, x, y);

                // 3. ç»˜åˆ¶åœ°å½¢ç»†èŠ‚ (å°æ‚è‰²ç‚¹)
                this.drawTerrainDetails(ctx, x, y, baseColor);
            }
        }
    }

    /**
     * æ£€æŸ¥é‚»å±…å¹¶ç»˜åˆ¶åœ°å½¢æ··åˆæ•ˆæœã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {number} x - æ ¼å­Xåæ ‡ã€‚
     * @param {number} y - æ ¼å­Yåæ ‡ã€‚
     */
    drawTerrainBlend(ctx, x, y) {
        const neighbors = [
            { dx: 0, dy: -1, dir: 'top' }, 
            { dx: 1, dy: 0, dir: 'right' }, 
            { dx: 0, dy: 1, dir: 'bottom' }, 
            { dx: -1, dy: 0, dir: 'left' }
        ];
        
        const currentType = TERRAIN_TYPES[this.getTile(x, y).type];

        for (const neighbor of neighbors) {
            const nx = x + neighbor.dx;
            const ny = y + neighbor.dy;

            const neighborTile = this.getTile(nx, ny);
            if (neighborTile) {
                const neighborType = TERRAIN_TYPES[neighborTile.type];

                // å¦‚æœé‚»å±…åœ°å½¢çš„æ¸²æŸ“ä¼˜å…ˆçº§æ›´é«˜ï¼Œåˆ™åœ¨æ­¤æ ¼å­çš„è¾¹ç¼˜ç»˜åˆ¶é‚»å±…åœ°å½¢çš„é¢œè‰²ï¼Œå½¢æˆæ··åˆæ•ˆæœ
                if (neighborType.priority > currentType.priority && currentType.priority > 0) {
                    this._drawBlendPattern(ctx, x, y, neighbor.dir, neighborType.color);
                }
            }
        }
    }

    /**
     * ç»˜åˆ¶åœ°å½¢ä¸Šçš„éšæœºç»†èŠ‚ï¼Œå¢åŠ è§†è§‰ä¸°å¯Œåº¦ã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {number} x - æ ¼å­Xåæ ‡ã€‚
     * @param {number} y - æ ¼å­Yåæ ‡ã€‚
     * @param {string} baseColor - æ ¼å­çš„åŸºç¡€é¢œè‰²ã€‚
     */
    drawTerrainDetails(ctx, x, y, baseColor) {
        const detailKey = `${x},${y}`;
        if (!this.terrainDetails.has(detailKey)) {
            const details = [];
            const numDetails = Math.floor(seededRandom(y * this.width + x + 1) * 5);
            for (let i = 0; i < numDetails; i++) {
                details.push({
                    x: seededRandom(i + x * y + 2) * TILE_SIZE,
                    y: seededRandom(i * 2 + x * y + 3) * TILE_SIZE,
                    size: seededRandom(i * 3 + x * y + 4) * (TILE_SIZE / 4) + 2,
                    color: this.adjustColor(baseColor, (seededRandom(i * 4 + x * y + 5) - 0.5) * 0.2)
                });
            }
            this.terrainDetails.set(detailKey, details);
        }

        const cachedDetails = this.terrainDetails.get(detailKey);
        for(const detail of cachedDetails) {
            ctx.fillStyle = detail.color;
            ctx.fillRect(x * TILE_SIZE + detail.x, y * TILE_SIZE + detail.y, detail.size, detail.size);
        }
    }

    /**
     * æ ¹æ®æ–¹å‘ç»˜åˆ¶ç¡®å®šçš„éšæœºæ··åˆå›¾æ¡ˆï¼Œå®ç°è‡ªç„¶çš„è¿‡æ¸¡æ•ˆæœã€‚
     * @private
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {number} x - å½“å‰ç“¦ç‰‡çš„æ ¼å­Xåæ ‡ã€‚
     * @param {number} y - å½“å‰ç“¦ç‰‡çš„æ ¼å­Yåæ ‡ã€‚
     * @param {string} direction - é‚»å±…çš„æ–¹å‘ ('top', 'right', 'bottom', 'left')ã€‚
     * @param {string} blendColor - é‚»å±…ï¼ˆé«˜ä¼˜å…ˆçº§åœ°å½¢ï¼‰çš„é¢œè‰²ã€‚
     */
    _drawBlendPattern(ctx, x, y, direction, blendColor) {
        ctx.fillStyle = blendColor;
        const subTileCount = 4; // å°†ç“¦ç‰‡è¾¹ç¼˜åˆ†ä¸º4ä¸ªå°å—è¿›è¡Œå¤„ç†
        const subTileSize = TILE_SIZE / subTileCount; 
        const pixelX = x * TILE_SIZE;
        const pixelY = y * TILE_SIZE;

        for (let i = 0; i < subTileCount; i++) {
            // ä½¿ç”¨ç“¦ç‰‡åæ ‡å’Œå—ç´¢å¼•ä½œä¸ºç§å­ï¼Œç¡®ä¿æ¯æ¬¡æ¸²æŸ“çš„å›¾æ¡ˆéƒ½ç›¸åŒ
            const seed = x * 13 + y * 31 + i * 7 + direction.charCodeAt(0);
            const randomVal = seededRandom(seed);
            
            if (randomVal < 0.6) { // çº¦60%çš„æ¦‚ç‡ç»˜åˆ¶æ··åˆå—
                // æ··åˆæ·±åº¦éšæœºï¼Œä½†ç¡®å®š
                const blendDepth = Math.ceil(seededRandom(seed * 2) * 2) * (subTileSize / 2);
                
                let rectX, rectY, rectW, rectH;

                switch (direction) {
                    case 'top':
                        rectX = pixelX + i * subTileSize; rectY = pixelY;
                        rectW = subTileSize; rectH = blendDepth;
                        break;
                    case 'bottom':
                        rectX = pixelX + i * subTileSize; rectY = pixelY + TILE_SIZE - blendDepth;
                        rectW = subTileSize; rectH = blendDepth;
                        break;
                    case 'left':
                        rectX = pixelX; rectY = pixelY + i * subTileSize;
                        rectW = blendDepth; rectH = subTileSize;
                        break;
                    case 'right':
                        rectX = pixelX + TILE_SIZE - blendDepth; rectY = pixelY + i * subTileSize;
                        rectW = blendDepth; rectH = subTileSize;
                        break;
                }
                 ctx.fillRect(rectX, rectY, rectW + 1, rectH + 1); // +1 ä¿®å¤ç¼éš™
            }
        }
    }

    /**
     * å¾®è°ƒé¢œè‰²ï¼Œç”¨äºç”Ÿæˆåœ°å½¢ç»†èŠ‚ã€‚
     * @param {string} hex - 16è¿›åˆ¶é¢œè‰²å­—ç¬¦ä¸² (e.g., '#FF0000')ã€‚
     * @param {number} percent - è°ƒæ•´ç™¾åˆ†æ¯” (e.g., -0.2 to 0.2)ã€‚
     * @returns {string} - è°ƒæ•´åçš„16è¿›åˆ¶é¢œè‰²å­—ç¬¦ä¸²ã€‚
     */
    adjustColor(hex, percent) {
        let r = parseInt(hex.substring(1, 3), 16);
        let g = parseInt(hex.substring(3, 5), 16);
        let b = parseInt(hex.substring(5, 7), 16);
        const amount = Math.floor(255 * percent);
        r = Math.max(0, Math.min(255, r + amount));
        g = Math.max(0, Math.min(255, g + amount));
        b = Math.max(0, Math.min(255, b + amount));
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    /**
     * è·å–æŒ‡å®šåæ ‡çš„æ ¼å­ä¿¡æ¯ã€‚
     * @param {number} x - æ ¼å­Xåæ ‡ã€‚
     * @param {number} y - æ ¼å­Yåæ ‡ã€‚
     * @returns {object|null} - è¿”å›æ ¼å­å¯¹è±¡ï¼Œå¦‚æœè¶Šç•Œåˆ™è¿”å›nullã€‚
     */
    getTile(x, y) {
        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
            return this.grid[y][x];
        }
        return null;
    }

    /**
     * è®¾ç½®æŒ‡å®šåæ ‡æ ¼å­çš„åœ°å½¢ç±»å‹ã€‚
     * @param {number} x - æ ¼å­Xåæ ‡ã€‚
     * @param {number} y - æ ¼å­Yåæ ‡ã€‚
     * @param {string} newType - æ–°çš„åœ°å½¢ç±»å‹IDã€‚
     */
    setTileType(x, y, newType) {
        const tile = this.getTile(x, y);
        if (tile && TERRAIN_TYPES[newType]) {
            tile.type = newType;
        }
    }
}```

---

### `maps-data.js`
```javascript
// js/maps-data.js

/**
 * @file å­˜æ”¾æ‰€æœ‰åœ°å›¾çš„å®šä¹‰æ•°æ®ã€‚
 * åœ°å›¾æ ¼å­å­—ç¬¦ä»£è¡¨:
 * 'g': è‰åœ° (grass)
 * 'f': æ£®æ— (forest)
 * 'r': é©¬è·¯ (road)
 * 'w': æµ·æ´‹ (water)
 * 'b': å»ºç­‘ (building)
 */
export const MAP_DEFINITIONS = [
    {
        id: 'map_new_01',
        name: 'åå­—è·¯å£å†²çª (Crossroads Clash)',
        description: 'ä¸­å¿ƒé“è·¯æ˜¯å…µå®¶å¿…äº‰ä¹‹åœ°ï¼Œä¸¤ä¾§çš„æ£®æ—ä¸ºä¼å‡»æä¾›äº†å¯èƒ½ã€‚',
        width: 80, 
        height: 60,
        grid: (() => {
            const w = 80, h = 60;
            let grid = Array(h).fill(null).map(() => Array(w).fill('g'));
            
            // ä¸»å¹²é“
            for (let y = 0; y < h; y++) {
                grid[y][Math.floor(w/2) -1] = 'r';
                grid[y][Math.floor(w/2)] = 'r';
            }
             for (let x = 0; x < w; x++) {
                grid[Math.floor(h/2) -1][x] = 'r';
                grid[Math.floor(h/2)][x] = 'r';
            }
            
            // å››è§’çš„æ£®æ—åŒºåŸŸ
            for (let y = 10; y < 22; y++) {
                for(let x = 10; x < 25; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
                for(let x = w - 25; x < w - 10; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
            }
             for (let y = h - 22; y < h - 10; y++) {
                for(let x = 10; x < 25; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
                for(let x = w - 25; x < w - 10; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
            }

            // ä¸Šä¸‹çš„æ²³æµï¼ˆå¸¦æ¡¥ï¼‰
            for (let x = 28; x < 52; x++) {
                 if (x > 38 && x < 42) continue; // æ¡¥çš„ä½ç½®ç•™ç©º
                 grid[5][x] = 'w';
                 grid[h-6][x] = 'w';
            }
            return grid.map(row => row.join(''));
        })()
    },
    {
        id: 'map01',
        name: 'åŒå­æ¡¥ (Twin Bridges)',
        description: 'ä¸€æ¡æ²³æµå°†åœ°å›¾ä¸€åˆ†ä¸ºäºŒï¼Œåªæœ‰ä¸¤åº§æ¡¥æ¢å¯ä¾›åœ°é¢éƒ¨é˜Ÿé€šè¿‡ã€‚',
        width: 100, 
        height: 60,
        grid: (() => {
            const w = 100, h = 60;
            let grid = Array(h).fill(null).map(() => Array(w).fill('g'));
            
            // æ²³æµ
            for (let y = 28; y < 32; y++) {
                for (let x = 0; x < w; x++) grid[y][x] = 'w';
            }
            
            // æ¡¥æ¢ (ç”¨é©¬è·¯ä»£æ›¿)
            for (let y = 28; y < 32; y++) {
                for(let x = 20; x < 28; x++) grid[y][x] = 'r';
                for(let x = 72; x < 80; x++) grid[y][x] = 'r';
            }

            // æ·»åŠ ä¸€äº›éšæœºæ£®æ—
            for (let i = 0; i < 200; i++) {
                const randX = Math.floor(Math.random() * w);
                const randY = Math.floor(Math.random() * h);
                if (grid[randY][randX] === 'g') grid[randY][randX] = 'f';
            }
            return grid.map(row => row.join(''));
        })()
    },
];
```

---

### `pathfinding.js`
```javascript
// js/pathfinding.js

import { TILE_SIZE, TERRAIN_TYPES } from './config.js';

/**
 * @class Node
 * @description A* å¯»è·¯ç®—æ³•ä¸­ä½¿ç”¨çš„èŠ‚ç‚¹ã€‚
 */
class Node {
    constructor(parent = null, position = null) {
        this.parent = parent;
        this.position = position; // {x, y} æ ¼å­åæ ‡
        this.g = 0; // ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„ä»£ä»·
        this.h = 0; // ä»å½“å‰èŠ‚ç‚¹åˆ°ç»ˆç‚¹çš„é¢„ä¼°ä»£ä»· (å¯å‘å¼)
        this.f = 0; // æ€»ä»£ä»· (g + h)
    }

    /**
     * æ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦ä¸å¦ä¸€ä¸ªèŠ‚ç‚¹ä½ç½®ç›¸åŒã€‚
     * @param {Node} other - å¦ä¸€ä¸ªèŠ‚ç‚¹ã€‚
     * @returns {boolean}
     */
    equals(other) {
        return this.position.x === other.position.x && this.position.y === other.position.y;
    }
}

/**
 * ä½¿ç”¨ A* ç®—æ³•åœ¨åœ°å›¾ä¸Šå¯»æ‰¾è·¯å¾„ã€‚
 * @param {GameMap} map - æ¸¸æˆåœ°å›¾å¯¹è±¡ã€‚
 * @param {{x: number, y: number}} start - èµ·ç‚¹æ ¼å­åæ ‡ã€‚
 * @param {{x: number, y: number}} end - ç»ˆç‚¹æ ¼å­åæ ‡ã€‚
 * @param {string} moveType - ç§»åŠ¨å•ä½çš„ç±»å‹ ('ground', 'air', etc.)ã€‚
 * @returns {Array<{x: number, y: number}>|null} - è¿”å›ä¸€ä¸ªåŒ…å«è·¯å¾„èŠ‚ç‚¹åæ ‡çš„æ•°ç»„ï¼Œå¦‚æœæ‰¾ä¸åˆ°è·¯å¾„åˆ™è¿”å›nullã€‚
 */
export function findPath(map, start, end, moveType) {
    // å¯¹äºç©ºä¸­å•ä½ï¼Œè·¯å¾„å°±æ˜¯ä¸€æ¡ç›´çº¿ï¼Œæ— éœ€å¯»è·¯
    if (moveType === 'air') {
        return [start, end];
    }
    
    const startNode = new Node(null, start);
    const endNode = new Node(null, end);

    let openList = []; // å¾…è¯„ä¼°çš„èŠ‚ç‚¹
    let closedList = []; // å·²è¯„ä¼°çš„èŠ‚ç‚¹

    openList.push(startNode);
    
    // è®¾ç½®æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œé˜²æ­¢å› åœ°å›¾è¿‡å¤§æˆ–æ— è§£å¯¼è‡´çš„æ€§èƒ½é—®é¢˜
    const maxIterations = map.width * map.height * 1.5;
    let iterations = 0;

    while (openList.length > 0 && iterations < maxIterations) {
        iterations++;
        
        // ä» openList ä¸­æ‰¾åˆ° f å€¼æœ€å°çš„èŠ‚ç‚¹
        let currentNode = openList[0];
        let currentIndex = 0;
        for (let i = 1; i < openList.length; i++) {
            if (openList[i].f < currentNode.f) {
                currentNode = openList[i];
                currentIndex = i;
            }
        }

        // å°†å½“å‰èŠ‚ç‚¹ä» openList ç§»åˆ° closedList
        openList.splice(currentIndex, 1);
        closedList.push(currentNode);

        // å¦‚æœåˆ°è¾¾ç»ˆç‚¹ï¼Œåˆ™å›æº¯è·¯å¾„å¹¶è¿”å›
        if (currentNode.equals(endNode)) {
            let path = [];
            let current = currentNode;
            while (current !== null) {
                path.push(current.position);
                current = current.parent;
            }
            return path.reverse();
        }

        // æ£€æŸ¥æ‰€æœ‰ç›¸é‚»çš„æ ¼å­
        const adjacentSquares = [
            { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
            { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 }
        ];

        for (const newPosition of adjacentSquares) {
            const nodePosition = {
                x: currentNode.position.x + newPosition.x,
                y: currentNode.position.y + newPosition.y,
            };

            const tile = map.getTile(nodePosition.x, nodePosition.y);
            // å¦‚æœé‚»å±…èŠ‚ç‚¹ä¸å¯é€šè¡Œï¼Œåˆ™è·³è¿‡
            if (!tile || !TERRAIN_TYPES[tile.type].traversableBy.includes(moveType)) {
                continue;
            }
            
            const childNode = new Node(currentNode, nodePosition);
            
            // å¦‚æœé‚»å±…èŠ‚ç‚¹å·²åœ¨ closedList ä¸­ï¼Œåˆ™è·³è¿‡
            if (closedList.find(node => node.equals(childNode))) {
                 continue;
            }

            // è®¡ç®— g, h, f å€¼
            const moveCost = (newPosition.x !== 0 && newPosition.y !== 0) ? 1.414 : 1; // å¯¹è§’çº¿ç§»åŠ¨ä»£ä»·æ›´é«˜
            childNode.g = currentNode.g + moveCost;
            childNode.h = Math.sqrt(((childNode.position.x - endNode.position.x) ** 2) + ((childNode.position.y - endNode.position.y) ** 2));
            childNode.f = childNode.g + childNode.h;

            // å¦‚æœé‚»å±…èŠ‚ç‚¹å·²åœ¨ openList ä¸­ï¼Œä¸”æ–°çš„è·¯å¾„ä»£ä»·æ›´é«˜ï¼Œåˆ™è·³è¿‡
            const existingNode = openList.find(node => node.equals(childNode));
            if (existingNode && childNode.g >= existingNode.g) {
                continue;
            }
            
            // æ›´æ–°æˆ–æ·»åŠ èŠ‚ç‚¹åˆ° openList
            if (existingNode) {
                existingNode.parent = currentNode;
                existingNode.g = childNode.g;
                existingNode.f = childNode.f;
            } else {
                openList.push(childNode);
            }
        }
    }

    return null; // æ‰¾ä¸åˆ°è·¯å¾„
}


/**
 * æ£€æŸ¥ä¸¤ç‚¹ä¹‹é—´æ˜¯å¦æœ‰åœ°å½¢éšœç¢ï¼Œç”¨äºè·¯å¾„å¹³æ»‘å¤„ç†ï¼ˆæ‹‰ç›´è·¯å¾„ï¼‰ã€‚
 * @param {{x: number, y: number}} startPos - èµ·ç‚¹åƒç´ åæ ‡ã€‚
 * @param {{x: number, y: number}} endPos - ç»ˆç‚¹åƒç´ åæ ‡ã€‚
 * @param {GameMap} map - æ¸¸æˆåœ°å›¾å¯¹è±¡ã€‚
 * @param {string} moveType - ç§»åŠ¨å•ä½çš„ç±»å‹ã€‚
 * @returns {boolean} - å¦‚æœæ²¡æœ‰éšœç¢åˆ™è¿”å›trueã€‚
 */
export function isLineOfSightClear(startPos, endPos, map, moveType) {
    // ç©ºä¸­å•ä½æ°¸è¿œè§†é‡æ¸…æ™°ï¼Œæ— è§†åœ°å½¢éšœç¢
    if (moveType === 'air') {
        return true;
    }

    const dx = endPos.x - startPos.x;
    const dy = endPos.y - startPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const step = TILE_SIZE / 2; // æ£€æŸ¥æ­¥é•¿ï¼ŒåŠä¸ªæ ¼å­å¤§å°
    const steps = Math.ceil(distance / step);

    // æ²¿ç›´çº¿æ­¥è¿›æ£€æŸ¥æ¯ä¸ªç‚¹æ‰€åœ¨çš„åœ°å½¢æ˜¯å¦å¯é€šè¡Œ
    for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const checkX = startPos.x + dx * t;
        const checkY = startPos.y + dy * t;

        const gridX = Math.floor(checkX / TILE_SIZE);
        const gridY = Math.floor(checkY / TILE_SIZE);

        const tile = map.getTile(gridX, gridY);
        if (!tile || !TERRAIN_TYPES[tile.type].traversableBy.includes(moveType)) {
            return false; // é‡åˆ°éšœç¢
        }
    }
    
    return true; // è·¯å¾„æ¸…æ™°
}
```

---

### `player.js`
```javascript
// js/player.js

import { AIController } from './ai.js';

/**
 * @class Player
 * @description ä»£è¡¨ä¸€ä¸ªç©å®¶ï¼Œå¯ä»¥æ˜¯äººç±»æˆ–AIã€‚
 */
export class Player {
    /**
     * @param {string} id - ç©å®¶ID ('player' or 'ai')ã€‚
     * @param {string} name - ç©å®¶åç§°ã€‚
     * @param {number} manpower - åˆå§‹èµ„æºã€‚
     * @param {boolean} [isAI=false] - æ˜¯å¦ä¸ºAIç©å®¶ã€‚
     * @param {object} [baseArea] - åŸºåœ°èŒƒå›´ (æœªä½¿ç”¨)ã€‚
     * @param {string} [aiDifficulty='medium'] - AIéš¾åº¦ã€‚
     */
    constructor(id, name, manpower, isAI = false, baseArea, aiDifficulty = 'medium') {
        this.id = id;
        this.name = name;
        this.manpower = manpower;
        this.isAI = isAI;
        this.units = [];
        this.baseArea = baseArea; 
        this.baseCaptureTimer = 0; // for capture mechanics (not implemented)

        if (isAI) {
            this.aiController = new AIController(this, aiDifficulty);
        }
    }

    /**
     * æ›´æ–°ç©å®¶é€»è¾‘ï¼Œä¸»è¦ç”¨äºé©±åŠ¨AIã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @param {Player} enemyPlayer - æ•Œæ–¹ç©å®¶å¯¹è±¡ã€‚
     * @param {GameMap} map - æ¸¸æˆåœ°å›¾ã€‚
     * @param {SpatialGrid} spatialGrid - ç©ºé—´ç½‘æ ¼ï¼Œä¼ é€’ç»™AIæ§åˆ¶å™¨ç”¨äºç´¢æ•Œã€‚
     */
    update(deltaTime, enemyPlayer, map, spatialGrid) {
        if (this.isAI) {
            this.aiController.update(this.units, enemyPlayer.units, map, deltaTime, spatialGrid);
        }
    }
    
    /**
     * æ£€æŸ¥èµ„æºæ˜¯å¦è¶³å¤Ÿã€‚
     * @param {number} unitCost - å•ä½èŠ±è´¹ã€‚
     * @returns {boolean}
     */
    canAfford(unitCost) {
        return this.manpower >= unitCost;
    }
    
    /**
     * æ‰£é™¤èµ„æºã€‚
     * @param {number} amount - æ‰£é™¤æ•°é‡ã€‚
     */
    deductManpower(amount) {
        this.manpower -= amount;
    }
}
```

---

### `projectile.js`
```javascript
// js/projectile.js

import { getDistance } from './utils.js';

let nextProjectileId = 0;

/**
 * @class Projectile
 * @description ä»£è¡¨ä¸€ä¸ªé£è¡Œä¸­çš„å¼¹é“ç‰©ä½“ï¼Œå¦‚å­å¼¹ã€ç‚®å¼¹æˆ–å¯¼å¼¹ã€‚
 */
export class Projectile {
    /**
     * @param {string} owner - å‘å°„è€…çš„owner ID ('player' or 'ai')ã€‚
     * @param {{x: number, y: number}} startPos - å‘å°„ä½ç½®ã€‚
     * @param {Unit|Base} target - ç›®æ ‡å¯¹è±¡ã€‚
     * @param {object} stats - å¼¹é“å±æ€§ (ä¼¤å®³, é€Ÿåº¦, ç±»å‹ç­‰)ã€‚
     */
    constructor(owner, startPos, target, stats) {
        this.id = nextProjectileId++;
        this.owner = owner;
        this.x = startPos.x;
        this.y = startPos.y;
        this.target = target;
        this.stats = stats;

        const targetPos = { x: target.pixelX || target.x, y: target.pixelY || target.y };
        const angle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
        this.vx = Math.cos(angle) * this.stats.ammoSpeed;
        this.vy = Math.sin(angle) * this.stats.ammoSpeed;
        
        this.trail = []; // ç”¨äºæ‹–å°¾æ•ˆæœçš„ç²’å­æ•°ç»„
        this.life = 0; // å¼¹é“çš„ç”Ÿå‘½å‘¨æœŸè®¡æ—¶
    }

    /**
     * æ›´æ–°å¼¹é“ä½ç½®å’ŒçŠ¶æ€ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @returns {boolean} - å¦‚æœå¼¹é“åº”è¯¥è¢«é”€æ¯ï¼ˆå‘½ä¸­æˆ–è¶…æ—¶ï¼‰ï¼Œåˆ™è¿”å›trueã€‚
     */
    update(deltaTime) {
        const targetPos = this.target ? { x: this.target.pixelX || this.target.x, y: this.target.pixelY || this.target.y } : {x: this.x + this.vx, y: this.y + this.vy};

        // å¯¼å¼¹çš„ç®€å•è¿½è¸ªé€»è¾‘
        if (this.stats.ammoType === 'missile' && this.target && this.target.hp > 0) {
            const angle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
            const targetVx = Math.cos(angle) * this.stats.ammoSpeed;
            const targetVy = Math.sin(angle) * this.stats.ammoSpeed;
            // ä½¿ç”¨çº¿æ€§æ’å€¼ä½¿å¯¼å¼¹è½¬å‘æ›´å¹³æ»‘
            this.vx = this.vx * 0.98 + targetVx * 0.02;
            this.vy = this.vy * 0.98 + targetVy * 0.02;
        }

        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        this.life += deltaTime;

        // æ›´æ–°æ‹–å°¾æ•ˆæœ
        this.updateTrail(deltaTime);

        const dist = getDistance(this, targetPos);
        // å‘½ä¸­åˆ¤å®šï¼ˆè·ç¦»è¶³å¤Ÿè¿‘ï¼‰æˆ–è¶…æ—¶ï¼ˆé£è¡Œæ—¶é—´è¿‡é•¿ï¼‰
        return dist < 10 || this.life > 5;
    }
    
    /**
     * æ›´æ–°æ‹–å°¾ç²’å­æ•ˆæœã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    updateTrail(deltaTime) {
        if (this.stats.ammoType === 'missile' || this.stats.ammoType === 'shell') {
            // æ¯éš”ä¸€å°æ®µè·ç¦»æ·»åŠ ä¸€ä¸ªæ–°çš„æ‹–å°¾ç²’å­
            if (this.trail.length === 0 || getDistance(this.trail[this.trail.length-1], this) > 5) {
                this.trail.push({ x: this.x, y: this.y, life: 1.0 });
            }
        }
        
        // æ›´æ–°å¹¶ç§»é™¤ç”Ÿå‘½å‘¨æœŸç»“æŸçš„æ‹–å°¾ç²’å­
        for (let i = this.trail.length - 1; i >= 0; i--) {
            this.trail[i].life -= deltaTime * 2.5;
            if (this.trail[i].life <= 0) {
                this.trail.splice(i, 1);
            }
        }
    }

    /**
     * ç»˜åˆ¶å¼¹é“å’Œå…¶æ‹–å°¾ã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     */
    draw(ctx) {
        // ç»˜åˆ¶æ‹–å°¾ï¼ˆçƒŸé›¾ï¼‰
        if (this.stats.ammoType === 'missile' || this.stats.ammoType === 'shell') {
             ctx.fillStyle = `rgba(180, 180, 180, 0.4)`;
             this.trail.forEach(p => {
                ctx.beginPath();
                // ç²’å­å¤§å°éšç”Ÿå‘½å‘¨æœŸå‡å°
                const radius = p.life * (this.stats.ammoType === 'missile' ? 4 : 2.5);
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ç»˜åˆ¶å¼¹å¤´
        switch (this.stats.ammoType) {
            case 'missile':
                ctx.fillStyle = `rgba(255, 200, 100, 1)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 'bullet':
                 ctx.fillStyle = 'yellow';
                 ctx.fillRect(this.x - 1, this.y - 1, 3, 3);
                 break;
            case 'shell':
                 ctx.fillStyle = '#ddd';
                 ctx.beginPath();
                 ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                 ctx.fill();
                 break;
        }
    }
}


/**
 * @class Explosion
 * @description ç®¡ç†ä¸€ä¸ªçˆ†ç‚¸çš„è§†è§‰æ•ˆæœï¼ŒåŒ…æ‹¬ç«å…‰å’ŒçƒŸé›¾ç²’å­ã€‚
 */
export class Explosion {
    /**
     * @param {number} x - çˆ†ç‚¸ä¸­å¿ƒXåæ ‡ã€‚
     * @param {number} y - çˆ†ç‚¸ä¸­å¿ƒYåæ ‡ã€‚
     * @param {number} radius - çˆ†ç‚¸çš„æœ€å¤§åŠå¾„ã€‚
     */
    constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius < 10 ? 10 : radius; // æœ€å°çˆ†ç‚¸åŠå¾„
        this.maxLife = 0.6; // çˆ†ç‚¸æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
        this.life = this.maxLife;
        
        // åˆ›å»ºçƒŸé›¾ç²’å­
        this.particles = [];
        const particleCount = 15 + Math.floor(this.radius / 5);
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * this.radius * 0.5;
            this.particles.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                size: Math.random() * 5 + 2,
                alpha: Math.random() * 0.3 + 0.1,
            });
        }
    }

    /**
     * æ›´æ–°çˆ†ç‚¸æ•ˆæœçš„ç”Ÿå‘½å‘¨æœŸå’Œç²’å­çŠ¶æ€ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @returns {boolean} - å¦‚æœçˆ†ç‚¸æ•ˆæœåº”è¯¥è¢«é”€æ¯ï¼Œåˆ™è¿”å›trueã€‚
     */
    update(deltaTime) {
        this.life -= deltaTime;
        
        // æ›´æ–°æ¯ä¸ªçƒŸé›¾ç²’å­çš„çŠ¶æ€
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.life -= deltaTime * 0.8;
             if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
        
        return this.life <= 0 && this.particles.length === 0;
    }

    /**
     * ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     */
    draw(ctx) {
        const progress = 1 - (this.life / this.maxLife);
        
        // ç»˜åˆ¶çƒŸé›¾ç²’å­
        this.particles.forEach(p => {
            ctx.fillStyle = `rgba(80, 80, 80, ${p.alpha * p.life})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (1 + progress), 0, Math.PI * 2);
            ctx.fill();
        });

        // ç»˜åˆ¶ç«å…‰ (å¤šå±‚å åŠ ï¼Œå®ç°ä½“ç§¯æ„Ÿ)
        if (this.life > 0) {
            // ä½¿ç”¨sinå‡½æ•°å®ç°å¹³æ»‘çš„æ·¡å…¥æ·¡å‡ºæ•ˆæœ
            const alpha = Math.sin(Math.PI * progress);
            
            // 1. å¤–å±‚æ©™çº¢è‰²ç«ç„°
            let currentRadius = this.radius * progress;
            ctx.fillStyle = `rgba(255, 120, 0, ${alpha * 0.7})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // 2. ä¸­å±‚é»„è‰²ç«ç„°
            currentRadius *= 0.7;
            ctx.fillStyle = `rgba(255, 220, 100, ${alpha * 0.9})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();

            // 3. æ ¸å¿ƒç™½çƒ­åŒ–ç«ç„°
            currentRadius *= 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}
```

---

### `spatial-grid.js`
```javascript
// js/spatial-grid.js

/**
 * @file ç©ºé—´ç½‘æ ¼æ•°æ®ç»“æ„ï¼Œç”¨äºRTSæ¸¸æˆä¸­çš„æ ¸å¿ƒæ€§èƒ½ä¼˜åŒ–ã€‚
 * å®ƒå°†æ¸¸æˆä¸–ç•Œåˆ’åˆ†ä¸ºä¸€ä¸ªç½‘æ ¼ï¼Œæ¯ä¸ªå•ä½è¢«æ”¾ç½®åœ¨å¯¹åº”çš„æ ¼å­é‡Œã€‚
 * å½“éœ€è¦æŸ¥è¯¢ä¸€ä¸ªå•ä½é™„è¿‘çš„å…¶å®ƒå•ä½æ—¶ï¼Œåªéœ€æ£€æŸ¥å…¶æ‰€åœ¨æ ¼å­åŠå‘¨å›´çš„æ ¼å­å³å¯ï¼Œ
 * é¿å…äº†å…¨å±€éå†æ‰€æœ‰å•ä½ï¼Œä»è€Œå°†ç¢°æ’æ£€æµ‹ã€ç´¢æ•Œç­‰æ“ä½œçš„å¤æ‚åº¦ä» O(n^2) é™ä½åˆ°æ¥è¿‘ O(n)ã€‚
 */

/**
 * @class SpatialGrid
 */
export class SpatialGrid {
    /**
     * @param {number} mapWidth - åœ°å›¾çš„æ€»åƒç´ å®½åº¦ã€‚
     * @param {number} mapHeight - åœ°å›¾çš„æ€»åƒç´ é«˜åº¦ã€‚
     * @param {number} cellSize - æ¯ä¸ªç©ºé—´æ ¼å­çš„åƒç´ å°ºå¯¸ã€‚è¿™ä¸ªå€¼é€šå¸¸åº”å¤§äºæˆ–ç­‰äºæœ€å¤§å•ä½çš„äº¤äº’åŠå¾„ï¼ˆå¦‚è§†é‡ã€å°„ç¨‹ï¼‰ã€‚
     */
    constructor(mapWidth, mapHeight, cellSize) {
        this.cellSize = cellSize;
        this.gridWidth = Math.ceil(mapWidth / cellSize);
        this.gridHeight = Math.ceil(mapHeight / cellSize);
        // ä½¿ç”¨Mapæ¥å­˜å‚¨æ ¼å­ï¼Œkeyæ˜¯ "x,y" æ ¼å¼çš„å­—ç¬¦ä¸²ï¼Œvalueæ˜¯è¯¥æ ¼å­å†…çš„å•ä½æ•°ç»„ã€‚
        // Mapæ¯”æ™®é€šå¯¹è±¡åœ¨é¢‘ç¹å¢åˆ é”®æ—¶æ€§èƒ½æ›´å¥½ã€‚
        this.grid = new Map(); 
    }

    /**
     * å°†ç½‘æ ¼åæ ‡è½¬æ¢ä¸ºå”¯ä¸€çš„å­—ç¬¦ä¸²é”®ã€‚
     * @private
     * @param {number} gridX - ç½‘æ ¼çš„Xåæ ‡ã€‚
     * @param {number} gridY - ç½‘æ ¼çš„Yåæ ‡ã€‚
     * @returns {string} - "x,y" æ ¼å¼çš„é”®ã€‚
     */
    _getKey(gridX, gridY) {
        return `${gridX},${gridY}`;
    }

    /**
     * æ¸…ç©ºæ‰€æœ‰æ ¼å­ã€‚æ­¤æ–¹æ³•åº”åœ¨æ¯å¸§æ›´æ–°å¼€å§‹æ—¶è°ƒç”¨ã€‚
     */
    clear() {
        this.grid.clear();
    }

    /**
     * å°†ä¸€ä¸ªå•ä½æ’å…¥åˆ°å…¶å½“å‰ä½ç½®å¯¹åº”çš„æ ¼å­ä¸­ã€‚
     * @param {Unit} unit - è¦æ’å…¥çš„å•ä½ã€‚
     */
    insert(unit) {
        const gridX = Math.floor(unit.x / this.cellSize);
        const gridY = Math.floor(unit.y / this.cellSize);
        const key = this._getKey(gridX, gridY);

        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(unit);
    }

    /**
     * è·å–ä¸€ä¸ªå•ä½é™„è¿‘ï¼ˆå…¶è‡ªèº«æ ¼å­ + å‘¨å›´8ä¸ªæ ¼å­ï¼‰çš„æ‰€æœ‰å•ä½ã€‚
     * è¿™æ˜¯æœ€å¸¸ç”¨çš„æŸ¥è¯¢æ–¹æ³•ï¼Œç”¨äºç¢°æ’æ£€æµ‹ç­‰ã€‚
     * @param {Unit} unit - è¦æŸ¥è¯¢çš„ä¸­å¿ƒå•ä½ã€‚
     * @returns {Array<Unit>} - é™„è¿‘å•ä½çš„æ•°ç»„ã€‚
     */
    getNearby(unit) {
        const nearbyUnits = [];
        const centralGridX = Math.floor(unit.x / this.cellSize);
        const centralGridY = Math.floor(unit.y / this.cellSize);

        // éå†ä¸­å¿ƒæ ¼å­åŠå…¶å‘¨å›´çš„8ä¸ªæ ¼å­ (3x3åŒºåŸŸ)
        for (let y = -1; y <= 1; y++) {
            for (let x = -1; x <= 1; x++) {
                const checkGridX = centralGridX + x;
                const checkGridY = centralGridY + y;
                const key = this._getKey(checkGridX, checkGridY);

                if (this.grid.has(key)) {
                    nearbyUnits.push(...this.grid.get(key));
                }
            }
        }
        return nearbyUnits;
    }
    
    /**
     * è·å–ä¸€ä¸ªç‚¹å‘¨å›´æŒ‡å®šåŠå¾„å†…çš„æ‰€æœ‰å•ä½ã€‚
     * è¿™ä¸ªæ–¹æ³•æ¯” getNearby æ›´ç²¾ç¡®ï¼Œä½†å¯èƒ½éœ€è¦æ£€æŸ¥æ›´å¤šçš„æ ¼å­ã€‚
     * @param {{x: number, y: number}} position - æŸ¥è¯¢çš„ä¸­å¿ƒç‚¹ã€‚
     * @param {number} radius - æŸ¥è¯¢åŠå¾„ã€‚
     * @returns {Array<Unit>} - åŠå¾„èŒƒå›´å†…çš„å•ä½æ•°ç»„ã€‚
     */
    getNearbyWithRadius(position, radius) {
        const nearbyUnits = new Set(); // ä½¿ç”¨Seté¿å…é‡å¤æ·»åŠ å•ä½
        const minGridX = Math.floor((position.x - radius) / this.cellSize);
        const maxGridX = Math.floor((position.x + radius) / this.cellSize);
        const minGridY = Math.floor((position.y - radius) / this.cellSize);
        const maxGridY = Math.floor((position.y + radius) / this.cellSize);

        for (let y = minGridY; y <= maxGridY; y++) {
            for (let x = minGridX; x <= maxGridX; x++) {
                const key = this._getKey(x, y);
                 if (this.grid.has(key)) {
                    this.grid.get(key).forEach(unit => nearbyUnits.add(unit));
                }
            }
        }
        return Array.from(nearbyUnits);
    }
}
```

---

### `ui.js`
```javascript
// js/ui.js

import { UNIT_TYPES, TERRAIN_TYPES, TILE_SIZE } from './config.js';

/**
 * @class UI
 * @description ç®¡ç†æ¸¸æˆçš„ç”¨æˆ·ç•Œé¢ï¼ŒåŒ…æ‹¬å•ä½é€‰æ‹©ã€ä¿¡æ¯æ˜¾ç¤ºå’Œç©å®¶äº¤äº’ã€‚
 */
export class UI {
    /**
     * @param {Game} game - æ¸¸æˆä¸»å¯¹è±¡çš„å¼•ç”¨ã€‚
     */
    constructor(game) {
        this.game = game;
        
        // DOMå…ƒç´ å¼•ç”¨
        this.unitListContainer = document.getElementById('unit-selection');
        this.playerManpower = document.getElementById('player-manpower');
        this.gameStatus = document.getElementById('game-status');
        this.startBattleBtn = document.getElementById('start-battle-btn');
        this.selectedUnitInfo = document.getElementById('selected-unit-info');
        
        this.selectedUnitToDeploy = null; // å½“å‰åœ¨éƒ¨ç½²åˆ—è¡¨ä¸­é€‰ä¸­çš„å•ä½ç±»å‹
        this.messageTimeout = null; // æ¸¸æˆæ¶ˆæ¯çš„è®¡æ—¶å™¨

        this.init();
    }

    /**
     * åˆå§‹åŒ–UIï¼Œå¡«å……å•ä½åˆ—è¡¨å¹¶ç»‘å®šäº‹ä»¶ã€‚
     */
    init() {
        this.populateUnitList();
        
        if (this.startBattleBtn) {
            this.startBattleBtn.addEventListener('click', () => this.game.startGame());
        }
    }

    /**
     * æ ¹æ®config.jsä¸­çš„å•ä½å®šä¹‰ï¼ŒåŠ¨æ€ç”Ÿæˆå¯éƒ¨ç½²å•ä½çš„åˆ—è¡¨ã€‚
     */
    populateUnitList() {
        if (!this.unitListContainer) return;
        
        this.unitListContainer.innerHTML = `
            <h3>å¯éƒ¨ç½²å…µç§</h3>
            <div id="unit-list-wrapper"></div>
        `;
        const listWrapper = this.unitListContainer.querySelector('#unit-list-wrapper');

        // æŒ‰å•ä½ç±»åˆ«è¿›è¡Œåˆ†ç»„
        const groupedUnits = {};
        for (const type in UNIT_TYPES) {
            const unit = UNIT_TYPES[type];
            if (!groupedUnits[unit.unitClass]) {
                groupedUnits[unit.unitClass] = [];
            }
            groupedUnits[unit.unitClass].push({ id: type, ...unit });
        }

        // æŒ‰é¢„è®¾é¡ºåºæ¸²æŸ“ç±»åˆ«
        const categoryOrder = ['æ­¥å…µ', 'è£…ç”²', 'é£è¡Œ', 'ç‚®å…µ', 'æµ·å†›'];
        for (const category of categoryOrder) {
            if (!groupedUnits[category]) continue;

            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'unit-category';
            categoryDiv.innerHTML = `<h4>${category}</h4>`;
            
            const ul = document.createElement('ul');
            ul.className = 'unit-list';

            groupedUnits[category].forEach(unit => {
                const li = document.createElement('li');
                li.dataset.unitType = unit.id;
                li.title = unit.description;

                li.innerHTML = `
                    <div class="unit-icon">${unit.icon}</div>
                    <div class="unit-details">
                        <strong>${unit.name}</strong>
                        <div class="unit-stats">è´¹ç”¨: ${unit.cost} | HP: ${unit.hp} | æ”»å‡»: ${unit.attack}</div>
                    </div>
                `;
                
                li.addEventListener('click', () => {
                    const wasSelected = li.classList.contains('selected');
                    this.clearAllSelectionsInList();
                    
                    if (!wasSelected) {
                        li.classList.add('selected');
                        this.selectedUnitToDeploy = unit.id;
                        // äº¤äº’ä¼˜åŒ–: é€‰æ‹©éƒ¨ç½²å•ä½æ—¶ï¼Œè‡ªåŠ¨å–æ¶ˆåœ°å›¾ä¸Šå·²é€‰ä¸­çš„å•ä½
                        this.game.selectedUnits = [];
                    } else {
                        this.selectedUnitToDeploy = null;
                    }
                });
                ul.appendChild(li);
            });

            categoryDiv.appendChild(ul);
            listWrapper.appendChild(categoryDiv);
        }
    }

    /**
     * æ¸…é™¤éƒ¨ç½²åˆ—è¡¨ä¸­æ‰€æœ‰å•ä½çš„é€‰ä¸­çŠ¶æ€ã€‚
     */
    clearAllSelectionsInList() {
        if (!this.unitListContainer) return;
        this.unitListContainer.querySelectorAll('li.selected').forEach(item => item.classList.remove('selected'));
    }

    /**
     * æ¸…é™¤å¾…éƒ¨ç½²å•ä½çš„é€‰æ‹©çŠ¶æ€ã€‚é€šå¸¸ç”±Gameç±»åœ¨å…¶ä»–æ“ä½œï¼ˆå¦‚æ¡†é€‰ï¼‰åè°ƒç”¨ã€‚
     */
    clearDeploymentSelection() {
        if (this.selectedUnitToDeploy) {
            this.selectedUnitToDeploy = null;
            this.clearAllSelectionsInList();
        }
    }

    /**
     * æ¯å¸§æ›´æ–°UIæ˜¾ç¤ºï¼Œå¦‚èµ„æºã€æ¸¸æˆçŠ¶æ€å’ŒåŸºåœ°è¡€é‡ã€‚
     */
    update() {
        if (this.playerManpower) this.playerManpower.textContent = this.game.player.manpower;
        if (this.gameStatus) this.gameStatus.textContent = `çŠ¶æ€: ${this.game.gameState}`;
        if (this.startBattleBtn) this.startBattleBtn.disabled = this.game.gameState !== 'deployment';
        
        // æ›´æ–°åŸºåœ°è¡€æ¡
        this.updateBaseHP('player');
        this.updateBaseHP('ai');

        // æ›´æ–°é€‰ä¸­å•ä½çš„ä¿¡æ¯é¢æ¿
        this.updateSelectedUnitInfo();
    }
    
    /**
     * æ›´æ–°æŒ‡å®šç©å®¶çš„åŸºåœ°HPæ¡ã€‚
     * @param {string} owner - 'player' or 'ai'.
     */
    updateBaseHP(owner) {
        const base = this.game[`${owner}Base`];
        const displayDiv = document.getElementById(`${owner}-base-hp-display`);
        if (!displayDiv) return;

        if (base) {
            displayDiv.style.display = 'block';
            const hpBar = document.getElementById(`${owner}-base-hp-bar`);
            if(hpBar) {
                const percentage = (base.hp / base.maxHp) * 100;
                hpBar.style.width = `${percentage}%`;
            }
        } else {
            displayDiv.style.display = 'none';
        }
    }

    /**
     * æ›´æ–°æ˜¾ç¤ºåœ¨UIå³ä¸‹è§’çš„é€‰ä¸­å•ä½ä¿¡æ¯ã€‚
     */
    updateSelectedUnitInfo() {
        if (!this.selectedUnitInfo) return;
        
        const selectedCount = this.game.selectedUnits.length;

        if (selectedCount === 1) {
            // æ˜¾ç¤ºå•ä¸ªå•ä½çš„è¯¦ç»†ä¿¡æ¯
            const unit = this.game.selectedUnits[0]; 
            const stats = unit.stats;
            
            let statusText = 'å¾…å‘½';
            if (unit.target) statusText = 'æ”»å‡»ä¸­';
            else if (unit.path && unit.path.length > 0) statusText = 'ç§»åŠ¨ä¸­';
            else if (unit.isLoitering) statusText = 'å·¡é€»ä¸­';
            else if (unit.isSettingUp) statusText = 'éƒ¨ç½²ä¸­';

            this.selectedUnitInfo.innerHTML = `
                <h4>${stats.name}</h4>
                <p>HP: ${unit.hp.toFixed(0)} / ${stats.hp}</p>
                <div class="hp-bar-container small">
                   <div class="hp-bar" style="width: ${(unit.hp / stats.hp) * 100}%; background-color: green;"></div>
                </div>
                <p>æ”»å‡»: ${stats.attack} | é˜²å¾¡: ${stats.defense}</p>
                <p>å°„ç¨‹: ${stats.range / TILE_SIZE}æ ¼ | çŠ¶æ€: ${statusText}</p> 
            `;
        } else if (selectedCount > 1) {
            // æ˜¾ç¤ºå¤šä¸ªå•ä½çš„æ¦‚è¦ä¿¡æ¯
            this.selectedUnitInfo.innerHTML = `
                <h4>é€‰ä¸­å¤šä¸ªå•ä½</h4>
                <p>${selectedCount} ä¸ªå•ä½è¢«é€‰ä¸­ã€‚</p>
            `;
        } else {
            // æ²¡æœ‰å•ä½è¢«é€‰ä¸­
            this.selectedUnitInfo.innerHTML = '<h4>é€‰ä¸­å•ä½ä¿¡æ¯</h4><p>æ— </p>';
        }
    }
    
    /**
     * åœ¨æ¸¸æˆç»“æŸæ—¶æ˜¾ç¤ºèƒœåˆ©è€…ä¿¡æ¯ã€‚
     * @param {string} winnerName - èƒœåˆ©è€…çš„åå­—ã€‚
     */
    showWinner(winnerName) {
        const winnerDiv = document.createElement('div');
        winnerDiv.className = 'winner-announcement';
        winnerDiv.textContent = `${winnerName} è·èƒœ!`;
        document.body.appendChild(winnerDiv);
    }

    /**
     * åœ¨å±å¹•ä¸Šæ˜¾ç¤ºä¸€æ¡ä¸´æ—¶æ¸¸æˆæ¶ˆæ¯ (å¦‚ "èµ„æºä¸è¶³")ã€‚
     * @param {string} message - è¦æ˜¾ç¤ºçš„æ¶ˆæ¯æ–‡æœ¬ã€‚
     */
    showGameMessage(message) {
        let messageDiv = document.getElementById('game-message');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'game-message';
            document.body.appendChild(messageDiv);
        }
        
        messageDiv.textContent = message;
        messageDiv.classList.add('show');

        if (this.messageTimeout) clearTimeout(this.messageTimeout);
        
        this.messageTimeout = setTimeout(() => {
            messageDiv.classList.remove('show');
        }, 3000);
    }
}
```

---

### `unit.js`
```javascript
// js/unit.js

import { TILE_SIZE, UNIT_TYPES } from './config.js';
import { getDistance } from './utils.js';
import { Base } from './base.js';
import { Projectile } from './projectile.js';
import { findPath, isLineOfSightClear } from './pathfinding.js';

let nextUnitId = 0;

/**
 * @class Unit
 * @description æ¸¸æˆä¸­çš„åŸºç¡€ä½œæˆ˜å•ä½ç±»ã€‚
 */
export class Unit {
    /**
     * @param {string} type - å•ä½ç±»å‹ID, å¯¹åº” config.js ä¸­çš„é”®ã€‚
     * @param {string} owner - æ‰€æœ‰è€… ('player' or 'ai')ã€‚
     * @param {number} x - åˆå§‹åƒç´ Xåæ ‡ã€‚
     * @param {number} y - åˆå§‹åƒç´ Yåæ ‡ã€‚
     */
    constructor(type, owner, x, y) {
        this.id = nextUnitId++;
        this.type = type;
        this.owner = owner;
        this.stats = { ...UNIT_TYPES[type] }; // å¤åˆ¶å•ä½å±æ€§ï¼Œé˜²æ­¢ä¿®æ”¹å…¨å±€é…ç½®
        this.image = window.assetManager[this.stats.imageSrc];

        // ä½ç½®å’ŒçŠ¶æ€
        this.x = x;
        this.y = y;
        this.hp = this.stats.hp;
        this.angle = Math.random() * Math.PI * 2; // å½“å‰æœå‘
        this.targetAngle = this.angle; // ç›®æ ‡æœå‘
        this.rotationSpeed = Math.PI * 2.0; // æ¯ç§’æ—‹è½¬é€Ÿåº¦
        
        // æˆ˜æ–—ç›¸å…³
        this.target = null;
        this.attackCooldown = 0;
        this.findTargetCooldown = Math.random() * 0.5; // é”™å¼€AIå•ä½çš„ç´¢æ•Œè®¡ç®—ï¼Œé¿å…åŒæ—¶è®¡ç®—é€ æˆå¡é¡¿

        // ç§»åŠ¨ç›¸å…³
        this.path = [];
        this.currentPathIndex = 0;
        this.moveTargetPos = null; // å½“å‰å¹³æ»‘è·¯å¾„çš„ç›®æ ‡ç‚¹
        
        // ç‰¹æ®Šè¡Œä¸ºçŠ¶æ€
        this.isLoitering = false; // æ˜¯å¦åœ¨å·¡é€»ï¼ˆä¸»è¦ç”¨äºé£æœºï¼‰
        this.loiterCenter = null;
        this.loiterRadius = TILE_SIZE * 5;
        this.loiterAngle = 0;
        this.strafeDirection = Math.random() < 0.5 ? 1 : -1; // é£æœºç»•åœˆæ–¹å‘
        
        this.isSettingUp = false; // æ˜¯å¦åœ¨éƒ¨ç½²ï¼ˆç‚®å…µï¼‰
        this.setupTimer = 0;
    }

    /**
     * å•ä½çš„ä¸»æ›´æ–°é€»è¾‘ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @param {Array<Unit>} enemyUnits - æ•Œæ–¹å•ä½æ•°ç»„ (å·²åºŸå¼ƒï¼Œæ”¹ç”¨spatialGrid)ã€‚
     * @param {GameMap} map - åœ°å›¾å¯¹è±¡ã€‚
     * @param {Base} enemyBase - æ•Œæ–¹åŸºåœ°ã€‚
     * @param {Game} game - æ¸¸æˆä¸»å¯¹è±¡ã€‚
     * @param {SpatialGrid} spatialGrid - ç”¨äºé«˜æ•ˆç´¢æ•Œçš„ç©ºé—´ç½‘æ ¼ã€‚
     */
    update(deltaTime, enemyUnits, map, enemyBase, game, spatialGrid) {
        if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;
        if (this.findTargetCooldown > 0) this.findTargetCooldown -= deltaTime;
        
        this.updateRotation(deltaTime);

        // ç‚®å…µç­‰å•ä½éƒ¨ç½²ä¸­ä¸èƒ½åšä»»ä½•äº‹
        if (this.isSettingUp) {
            this.setupTimer -= deltaTime;
            if (this.setupTimer <= 0) this.isSettingUp = false;
            return;
        }
        
        // æ ¸å¿ƒé€»è¾‘ï¼šæ”»å‡»æˆ–ç§»åŠ¨
        if (this.target && this.target.hp > 0) {
            this.handleAttack(this.target, game);
        } else {
            this.target = null;
            this.handleMovement(deltaTime, map);
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ç©ºé—´ç½‘æ ¼è¿›è¡ŒèŠ‚æµç´¢æ•Œ
        // åªæœ‰å½“å•ä½ç©ºé—²ä¸”ç´¢æ•Œå†·å´ç»“æŸæ—¶æ‰æ‰§è¡Œ
        if (!this.target && this.path.length === 0 && !this.moveTargetPos && this.findTargetCooldown <= 0) {
            this.findTarget(enemyBase, spatialGrid);
            this.findTargetCooldown = 0.5 + Math.random() * 0.2; // æ— è®ºæ˜¯å¦æ‰¾åˆ°éƒ½é‡ç½®è®¡æ—¶å™¨
            
            // å¦‚æœæ²¡æ‰¾åˆ°ç›®æ ‡ï¼Œç‰¹å®šç©ºå†›å•ä½è¿›å…¥å·¡é€»æ¨¡å¼
            if (!this.target && this.stats.moveType === 'air' && (this.type === 'fighter_jet' || this.type === 'recon_drone')) {
                this.handleLoitering(deltaTime);
            }
        }
    }

    /**
     * å¤„ç†æ”»å‡»ç›®æ ‡çš„é€»è¾‘ã€‚
     * @param {Unit|Base} target - æ”»å‡»ç›®æ ‡ã€‚
     * @param {Game} game - æ¸¸æˆä¸»å¯¹è±¡ã€‚
     */
    handleAttack(target, game) {
        const targetPos = { x: target.pixelX || target.x, y: target.pixelY || target.y };
        const distanceToTarget = getDistance(this, targetPos);
        const engageRange = this.stats.range * 0.9; // è¿›å…¥æ­¤èŒƒå›´æ‰å¼€ç«ï¼Œé¿å…åœ¨æœ€å¤§å°„ç¨‹è¾¹ç¼˜åå¤æ¨ªè·³

        // å¦‚æœè·ç¦»å¤ªè¿œï¼Œåˆ™å‘ç›®æ ‡ç§»åŠ¨
        if (distanceToTarget > engageRange) {
            // åªæœ‰åœ¨æ²¡æœ‰ç§»åŠ¨è·¯å¾„æ—¶æ‰é‡æ–°å¯»è·¯ï¼Œé˜²æ­¢é¢‘ç¹è®¡ç®—
            if (!this.path.length && !this.moveTargetPos) {
                this.issueMoveCommand(targetPos, game.map, true);
            }
        } else {
            // è¿›å…¥å°„ç¨‹ï¼Œåœæ­¢ç§»åŠ¨
            this.path = [];
            this.moveTargetPos = null;
        }
        
        // è½¬å‘ç›®æ ‡
        this.setTargetAngle(targetPos);
        
        // åœ¨å°„ç¨‹å†…ä¸”å†·å´å®Œæ¯•ï¼Œåˆ™å¼€ç«
        if (distanceToTarget <= this.stats.range) {
            // æ£€æŸ¥æ˜¯å¦å·²å¯¹å‡†ç›®æ ‡
            let angleDiff = Math.abs(this.angle - this.targetAngle);
            if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
            
            if (this.attackCooldown <= 0 && !this.isSettingUp && angleDiff < 0.2) {
                this.attack(game);
            }
        }
    }
    
    /**
     * å¤„ç†ç§»åŠ¨é€»è¾‘ï¼ŒåŒ…æ‹¬è·¯å¾„å¹³æ»‘ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @param {GameMap} map - åœ°å›¾å¯¹è±¡ã€‚
     */
    handleMovement(deltaTime, map) {
        // å¦‚æœæœ‰è·¯å¾„ä½†æ²¡æœ‰å¹³æ»‘ç›®æ ‡ç‚¹ï¼Œåˆ™è®¡ç®—ä¸‹ä¸€ä¸ªå¹³æ»‘ç›®æ ‡ç‚¹
        if (this.path.length > 0 && !this.moveTargetPos) {
            this.findSmoothedPathTarget(map);
        }
        
        if (this.moveTargetPos) {
            this.setTargetAngle(this.moveTargetPos);
            const distanceToNode = getDistance(this, this.moveTargetPos);
            
            // åˆ°è¾¾è·¯å¾„èŠ‚ç‚¹
            if (distanceToNode < TILE_SIZE / 2) {
                this.moveTargetPos = null; 
                // åˆ°è¾¾æœ€ç»ˆç›®çš„åœ°
                if (this.currentPathIndex >= this.path.length -1) {
                    this.path = [];
                    // å¦‚æœæ˜¯ç‚®å…µï¼Œåˆ°è¾¾åéœ€è¦éƒ¨ç½²
                    if (this.stats.special === 'SETUP_TO_FIRE') {
                        this.isSettingUp = true;
                        this.setupTimer = 2.0;
                    }
                }
            } else {
                this.move(deltaTime);
            }
        }
    }

    /**
     * å¤„ç†ç©ºä¸­å•ä½çš„å·¡é€»ï¼ˆç»•åœˆï¼‰è¡Œä¸ºã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    handleLoitering(deltaTime) {
        if (!this.isLoitering) {
            this.isLoitering = true;
            this.loiterCenter = { x: this.x, y: this.y };
            this.loiterAngle = Math.atan2(this.y - this.loiterCenter.y, this.x - this.loiterCenter.x);
        }
        
        this.loiterAngle += 0.8 * deltaTime;
        
        const targetX = this.loiterCenter.x + Math.cos(this.loiterAngle) * this.loiterRadius;
        const targetY = this.loiterCenter.y + Math.sin(this.loiterAngle) * this.loiterRadius;
        
        this.setTargetAngle({x: targetX, y: targetY});
        this.move(deltaTime);
    }

    /**
     * æ ¹æ®å½“å‰æœå‘å’Œé€Ÿåº¦ç§»åŠ¨å•ä½ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    move(deltaTime) {
        const speed = this.stats.speed * deltaTime;
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;
    }

    /**
     * ä¸‹è¾¾ç§»åŠ¨å‘½ä»¤ï¼Œè®¡ç®—è·¯å¾„ã€‚
     * @param {{x: number, y: number}} targetPos - ç›®æ ‡åƒç´ åæ ‡ã€‚
     * @param {GameMap} map - åœ°å›¾å¯¹è±¡ã€‚
     * @param {boolean} [isEngaging=false] - è¿™æ¬¡ç§»åŠ¨æ˜¯å¦æ˜¯ä¸ºäº†æ”»å‡»ã€‚
     */
    issueMoveCommand(targetPos, map, isEngaging = false) {
        if (!isEngaging) this.target = null; // æ™®é€šç§»åŠ¨å‘½ä»¤ä¼šå–æ¶ˆæ”»å‡»ç›®æ ‡
        this.isLoitering = false;
        this.isSettingUp = false;
        this.moveTargetPos = null;
        
        const startGrid = { x: Math.floor(this.x / TILE_SIZE), y: Math.floor(this.y / TILE_SIZE) };
        const endGrid = { x: Math.floor(targetPos.x / TILE_SIZE), y: Math.floor(targetPos.y / TILE_SIZE) };
        const path = findPath(map, startGrid, endGrid, this.stats.moveType);
        
        if (path && path.length > 0) {
            this.path = path;
            this.currentPathIndex = 0;
        } else {
            this.path = [];
        }
    }

    /**
     * å¹³æ»‘åœ°æ›´æ–°å•ä½æœå‘ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    updateRotation(deltaTime) {
        let diff = this.targetAngle - this.angle;
        // ç¡®ä¿é€‰æ‹©æœ€çŸ­è·¯å¾„æ—‹è½¬
        while (diff <= -Math.PI) diff += 2 * Math.PI;
        while (diff > Math.PI) diff -= 2 * Math.PI;
        
        const turnStep = this.rotationSpeed * deltaTime;
        if (Math.abs(diff) < turnStep) {
            this.angle = this.targetAngle;
        } else {
            this.angle += Math.sign(diff) * turnStep;
        }
        // å°†è§’åº¦æ ‡å‡†åŒ–åˆ° [0, 2*PI)
        this.angle = (this.angle + 2 * Math.PI) % (2 * Math.PI);
    }
    
    /**
     * è®¾ç½®å•ä½çš„ç›®æ ‡æœå‘è§’åº¦ã€‚
     * @param {{x: number, y: number}} targetPos - ç›®æ ‡ç‚¹åƒç´ åæ ‡ã€‚
     */
    setTargetAngle(targetPos) {
        this.targetAngle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
    }

    /**
     * ç»˜åˆ¶å•ä½åŠå…¶UIå…ƒç´ ï¼ˆè¡€æ¡ã€é€‰æ‹©æ¡†ç­‰ï¼‰ã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {boolean} isSelected - å•ä½å½“å‰æ˜¯å¦è¢«é€‰ä¸­ã€‚
     * @param {number} [zoom=1] - å½“å‰é•œå¤´ç¼©æ”¾ã€‚
     * @param {boolean} [showDetails=false] - æ˜¯å¦æ˜¾ç¤ºé¢å¤–ä¿¡æ¯ï¼ˆå°„ç¨‹åœˆã€è·¯å¾„çº¿ï¼‰ã€‚
     */
    draw(ctx, isSelected, zoom = 1, showDetails = false) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI / 2); // å›¾åƒèµ„æºé€šå¸¸æ˜¯æœä¸Šçš„ï¼Œæ—‹è½¬90åº¦
        const size = TILE_SIZE * (this.stats.drawScale || 1.5); 
        
        if (this.image) {
            ctx.drawImage(this.image, -size / 2, -size / 2, size, size);
        }
        ctx.restore();

        // ç»˜åˆ¶é€‰ä¸­çŠ¶æ€å’Œè¯¦ç»†ä¿¡æ¯
        if (isSelected) {
            ctx.strokeStyle = this.owner === 'player' ? 'yellow' : 'orange';
            ctx.lineWidth = 2 / zoom;
            ctx.beginPath();
            ctx.arc(this.x, this.y, TILE_SIZE * this.stats.drawScale / 2, 0, Math.PI * 2);
            ctx.stroke();

            if (showDetails) {
                // ç»˜åˆ¶å°„ç¨‹åœˆ
                if (this.stats.range > 0) {
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                    ctx.lineWidth = 1 / zoom;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.range, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // ç»˜åˆ¶è·¯å¾„çº¿
                if (this.path && this.path.length > 0) {
                    const endNode = this.path[this.path.length - 1];
                    const destX = endNode.x * TILE_SIZE + TILE_SIZE / 2;
                    const destY = endNode.y * TILE_SIZE + TILE_SIZE / 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(destX, destY);
                    ctx.strokeStyle = this.target ? 'rgba(255, 50, 50, 0.7)' : 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 3 / zoom]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        // ç»˜åˆ¶è¡€æ¡
        const hpBarWidth = TILE_SIZE;
        const hpBarHeight = 5 / zoom;
        const hpBarYOffset = TILE_SIZE * 0.8;
        ctx.fillStyle = '#333';
        ctx.fillRect(this.x - hpBarWidth / 2, this.y - hpBarYOffset, hpBarWidth, hpBarHeight);
        ctx.fillStyle = this.owner === 'player' ? 'green' : '#c0392b';
        ctx.fillRect(this.x - hpBarWidth / 2, this.y - hpBarYOffset, hpBarWidth * (this.hp / this.stats.hp), hpBarHeight);
    }
    
    /**
     * æ ¸å¿ƒé‡æ„ (æ€§èƒ½ä¼˜åŒ–): ä½¿ç”¨ç©ºé—´ç½‘æ ¼è¿›è¡Œé«˜æ•ˆç´¢æ•Œã€‚
     * @param {Base} enemyBase - æ•Œæ–¹åŸºåœ°å¯¹è±¡ã€‚
     * @param {SpatialGrid} spatialGrid - ç©ºé—´ç½‘æ ¼ã€‚
     */
    findTarget(enemyBase, spatialGrid) {
        let closestTarget = null;
        let minDistance = this.stats.visionRange; // åªåœ¨è§†é‡èŒƒå›´å†…æœç´¢
        const validTargetTypes = this.stats.canTarget || ['ground', 'air', 'sea'];

        // 1. ä»ç©ºé—´ç½‘æ ¼è·å–è§†é‡èŒƒå›´å†…çš„æ‰€æœ‰æ½œåœ¨ç›®æ ‡
        const potentialTargets = spatialGrid.getNearbyWithRadius(this, minDistance);
        
        for (const target of potentialTargets) {
            if (target.owner === this.owner || target.hp <= 0) continue;
            
            // æ£€æŸ¥å•ä½ç±»å‹æ˜¯å¦å¯æ”»å‡»
            if (target instanceof Unit && !validTargetTypes.includes(target.stats.moveType)) continue;

            const distance = getDistance(this, target);
            if (distance < minDistance) {
                minDistance = distance;
                closestTarget = target;
            }
        }

        // 2. å¦‚æœæ²¡æœ‰æ‰¾åˆ°å•ä½ï¼Œå†æ£€æŸ¥åŸºåœ°
        if (!closestTarget && enemyBase && enemyBase.hp > 0 && validTargetTypes.includes('ground')) {
            const distanceToBase = getDistance(this, {x: enemyBase.pixelX, y: enemyBase.pixelY});
            if (distanceToBase < minDistance) {
                closestTarget = enemyBase;
            }
        }
        
        this.target = closestTarget;
    }
    
    /**
     * æ‰§è¡Œæ”»å‡»ï¼Œåˆ›å»ºä¸€ä¸ªå¼¹é“å¯¹è±¡ã€‚
     * @param {Game} game - æ¸¸æˆä¸»å¯¹è±¡ã€‚
     */
    attack(game) {
        if (!this.target || !this.stats.ammoType) return;
        
        const pStats = {
            damage: this.stats.attack,
            ammoType: this.stats.ammoType,
            ammoSpeed: this.stats.ammoSpeed,
            splashRadius: this.stats.ammoSplashRadius,
        };
        const projectile = new Projectile(this.owner, { x: this.x, y: this.y }, this.target, pStats);
        game.projectiles.push(projectile);
        
        this.attackCooldown = this.stats.attackSpeed;
    }

    /**
     * å•ä½æ‰¿å—ä¼¤å®³ã€‚
     * @param {number} amount - ä¼¤å®³å€¼ã€‚
     */
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) this.hp = 0;
    }

    /**
     * è·¯å¾„å¹³æ»‘å¤„ç†ï¼šä»è·¯å¾„çš„æœ«ç«¯å‘å‰æŸ¥æ‰¾ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸å½“å‰ä½ç½®æ— éšœç¢çš„èŠ‚ç‚¹ä½œä¸ºä¸‹ä¸€ä¸ªç›®æ ‡ç‚¹ã€‚
     * è¿™å¯ä»¥é¿å…å•ä½ä¸¥æ ¼æŒ‰ç…§æ ¼å­ä¸­å¿ƒç‚¹ç§»åŠ¨ï¼Œä½¿ç§»åŠ¨è½¨è¿¹æ›´è‡ªç„¶ã€‚
     * @param {GameMap} map - åœ°å›¾å¯¹è±¡ã€‚
     */
    findSmoothedPathTarget(map) {
        if (!this.path || this.path.length === 0 || this.currentPathIndex >= this.path.length) return;
        
        // ä»è·¯å¾„ç»ˆç‚¹å‘å‰æœç´¢
        for (let i = this.path.length - 1; i > this.currentPathIndex; i--) {
            const node = this.path[i];
            const targetPos = { x: node.x * TILE_SIZE + TILE_SIZE / 2, y: node.y * TILE_SIZE + TILE_SIZE / 2 };
            if (isLineOfSightClear(this, targetPos, map, this.stats.moveType)) {
                this.moveTargetPos = targetPos;
                this.currentPathIndex = i;
                return;
            }
        }
        
        // å¦‚æœæ— æ³•æ‹‰ç›´è·¯å¾„ï¼Œåˆ™ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        const nextNode = this.path[this.currentPathIndex];
        if (nextNode) {
            this.moveTargetPos = { x: nextNode.x * TILE_SIZE + TILE_SIZE / 2, y: nextNode.y * TILE_SIZE + TILE_SIZE / 2 };
        }
    }
}
```

---

### `utils.js`
```javascript
// js/utils.js

/**
 * @file å­˜æ”¾é€šç”¨çš„è¾…åŠ©å‡½æ•°ã€‚
 */

/**
 * è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚
 * @param {{x: number, y: number}} p1 - ç¬¬ä¸€ä¸ªç‚¹ã€‚
 * @param {{x: number, y: number}} p2 - ç¬¬äºŒä¸ªç‚¹ã€‚
 * @returns {number} - ä¸¤ç‚¹é—´çš„è·ç¦»ã€‚
 */
export function getDistance(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
}
```å¥½çš„ï¼Œæˆ‘å·²ç»ä»”ç»†å®¡æŸ¥äº†æ‚¨æä¾›çš„æ‰€æœ‰JavaScriptä»£ç ã€‚è¿™æ˜¯ä¸€æ¬¾åŠŸèƒ½ç›¸å½“å®Œå–„çš„RTSæ¸¸æˆåŸå‹ï¼Œå°¤å…¶æ˜¯åœ¨æ€§èƒ½ä¼˜åŒ–æ–¹é¢ï¼ˆå¦‚ç©ºé—´ç½‘æ ¼ï¼‰å’Œè§†è§‰æ•ˆæœæ–¹é¢ï¼ˆå¦‚æ–°çš„çˆ†ç‚¸å’Œåœ°å½¢æ··åˆï¼‰åšå¾—å¾ˆå¥½ã€‚

æ ¹æ®æ‚¨çš„è¦æ±‚ï¼Œæˆ‘å¯¹æ‰€æœ‰ä»£ç è¿›è¡Œäº†é‡æ„å’Œä¼˜åŒ–ï¼Œä¸»è¦ç›®æ ‡æ˜¯**æå‡ä»£ç æ•´æ´åº¦ã€å¯è¯»æ€§ï¼Œå¹¶ç»Ÿä¸€æ³¨é‡Šé£æ ¼**ã€‚ä»¥ä¸‹æ˜¯æˆ‘çš„ä¸»è¦å·¥ä½œï¼š

1.  **ç»Ÿä¸€JSDocæ³¨é‡Š**ï¼šä¸ºå‡ ä¹æ‰€æœ‰çš„ç±»ã€æ–¹æ³•å’Œå¤æ‚å‡½æ•°æ·»åŠ äº†æ ‡å‡†çš„JSDocæ³¨é‡Šã€‚è¿™ä¸ä»…è§£é‡Šäº†ä»£ç çš„åŠŸèƒ½ï¼Œè¿˜æ˜ç¡®äº†å‚æ•°å’Œè¿”å›å€¼ï¼Œéå¸¸æœ‰åˆ©äºæœªæ¥çš„ç»´æŠ¤å’Œå›¢é˜Ÿåä½œã€‚
2.  **ä»£ç æ ¼å¼åŒ–**ï¼šç»Ÿä¸€äº†ç¼©è¿›ã€ç©ºæ ¼å’Œæ¢è¡Œï¼Œä½¿æ•´ä½“ä»£ç é£æ ¼ä¿æŒä¸€è‡´ã€‚ç‰¹åˆ«æ˜¯ä¸€äº›å†—é•¿çš„å•è¡Œä»£ç è¢«é‡æ„ä¸ºæ›´æ˜“è¯»çš„å¤šè¡Œç»“æ„ã€‚
3.  **ä¼˜åŒ–æ³¨é‡Šå†…å®¹**ï¼šå°†åŸæ¥çš„ "æ ¸å¿ƒä¿®å¤"ã€"æ€§èƒ½é©å‘½" ç­‰å¼€å‘è¿‡ç¨‹ä¸­çš„æ ‡è®°ï¼Œè½¬åŒ–ä¸ºå¯¹â€œ**ä¸ºä»€ä¹ˆ**â€å’Œâ€œ**å¦‚ä½•åš**â€çš„æ¸…æ™°è§£é‡Šï¼Œè®©ä»»ä½•æ¥æ‰‹çš„äººéƒ½èƒ½å¿«é€Ÿç†è§£ä»£ç çš„è®¾è®¡æ„å›¾ã€‚
4.  **æå‡ä»£ç å¯è¯»æ€§**ï¼š
    *   åœ¨`game.js`ç­‰æ ¸å¿ƒç±»ä¸­ï¼Œå¯¹æ„é€ å‡½æ•°é‡Œçš„å±æ€§è¿›è¡Œäº†é€»è¾‘åˆ†ç»„ã€‚
    *   å¯¹ä¸€äº›å¤æ‚çš„é€»è¾‘å—ï¼ˆå¦‚`game.js`ä¸­çš„äº‹ä»¶å¤„ç†ï¼‰å¢åŠ äº†ç©ºè¡Œå’Œæ³¨é‡Šï¼Œä½¿å…¶ç»“æ„æ›´æ¸…æ™°ã€‚
    *   ä¿æŒäº†æ‚¨åŸæœ‰çš„ä¼˜ç§€å‘½åå’Œä»£ç ç»“æ„ã€‚

ä»¥ä¸‹æ˜¯ç»è¿‡ä¼˜åŒ–å’Œæ³¨é‡Šåçš„å®Œæ•´ä»£ç ã€‚

---

### `ai.js`
```javascript
// js/ai.js

import { UNIT_TYPES } from './config.js';
import { Unit } from './unit.js';
import { getDistance } from './utils.js';
import { Base } from './base.js';

/**
 * @class AIController
 * @description ç®¡ç†AIç©å®¶çš„å®è§‚æˆ˜ç•¥å’Œå¾®è§‚æ“ä½œã€‚
 */
export class AIController {
    /**
     * @param {Player} player - AIæ‰€å±çš„ç©å®¶å¯¹è±¡ã€‚
     * @param {string} difficulty - AIéš¾åº¦ ('medium', 'hard', 'hell')ã€‚
     */
    constructor(player, difficulty) {
        this.player = player;
        this.difficulty = difficulty;
        
        // å®è§‚å†³ç­–è®¡æ—¶å™¨
        this.macroTimer = 0; 
        this.macroInterval = 2.0; // æ¯2ç§’æ‰§è¡Œä¸€æ¬¡å®è§‚å†³ç­–
        
        // å¾®æ“è®¡æ—¶å™¨ (ä¸»è¦ç”¨äºåœ°ç‹±éš¾åº¦)
        this.microTimer = 0;
        this.microInterval = 0.5; // æ¯0.5ç§’æ‰§è¡Œä¸€æ¬¡å¾®æ“

        this.attackWave = []; // å½“å‰çš„è¿›æ”»æ³¢æ¬¡å•ä½
        this.playerBase = null; // ç©å®¶åŸºåœ°çš„å¼•ç”¨
    }

    /**
     * åœ¨æ¸¸æˆå¼€å§‹æ—¶éƒ¨ç½²åˆå§‹å•ä½ã€‚
     * @param {number} mapWidth - åœ°å›¾å®½åº¦ï¼ˆæ ¼å­æ•°ï¼‰ã€‚
     * @param {number} mapHeight - åœ°å›¾é«˜åº¦ï¼ˆæ ¼å­æ•°ï¼‰ã€‚
     * @param {number} TILE_SIZE - ç“¦ç‰‡å°ºå¯¸ï¼ˆåƒç´ ï¼‰ã€‚
     */
    deployUnits(mapWidth, mapHeight, TILE_SIZE) {
        const deployableUnits = Object.keys(UNIT_TYPES);
        let manpowerToSpend = this.player.manpower;

        // é«˜éš¾åº¦ä¸‹ï¼Œåˆå§‹èµ„æºèŠ±è´¹æ‰“æŠ˜æ‰£ï¼Œä»¥åˆ¶é€ æ›´å¤šå•ä½
        if (this.difficulty === 'hard' || this.difficulty === 'hell') {
            manpowerToSpend *= 0.7;
        }

        let spentManpower = 0;
        let attempts = 0;
        const maxAttempts = deployableUnits.length * 3; // é˜²æ­¢å› ä¹°ä¸èµ·ä»»ä½•å•ä½è€Œæ­»å¾ªç¯

        while (spentManpower < manpowerToSpend && attempts < maxAttempts) {
            const unitType = deployableUnits[Math.floor(Math.random() * deployableUnits.length)];
            const cost = UNIT_TYPES[unitType].cost;

            if (this.player.canAfford(cost)) {
                // åœ¨åœ°å›¾å³ä¾§ä¸‰åˆ†ä¹‹ä¸€åŒºåŸŸéšæœºéƒ¨ç½²
                const x = mapWidth * TILE_SIZE - (Math.random() * mapWidth / 3 * TILE_SIZE);
                const y = Math.random() * mapHeight * TILE_SIZE;
                const newUnit = new Unit(unitType, 'ai', x, y);
                this.player.units.push(newUnit);
                
                this.player.deductManpower(cost);
                spentManpower += cost;
                attempts = 0; // æˆåŠŸéƒ¨ç½²åé‡ç½®å°è¯•æ¬¡æ•°
            } else {
                attempts++;
            }
        }
    }

    /**
     * AIçš„æ ¸å¿ƒæ›´æ–°å¾ªç¯ã€‚
     * @param {Array<Unit>} aiUnits - AIçš„æ‰€æœ‰å•ä½ã€‚
     * @param {Array<Unit>} playerUnits - ç©å®¶çš„æ‰€æœ‰å•ä½ã€‚
     * @param {GameMap} map - æ¸¸æˆåœ°å›¾å¯¹è±¡ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @param {SpatialGrid} spatialGrid - ç”¨äºé«˜æ•ˆç´¢æ•Œçš„ç©ºé—´ç½‘æ ¼ã€‚
     */
    update(aiUnits, playerUnits, map, deltaTime, spatialGrid) {
        if (playerUnits.length === 0 && (!this.playerBase || this.playerBase.hp <= 0)) return;

        this.macroTimer += deltaTime;
        this.microTimer += deltaTime;

        // åŸºç¡€å¾®æ“ï¼šæ‰€æœ‰å•ä½è‡ªä¸»ç´¢æ•Œ (æ‰€æœ‰éš¾åº¦)
        // ä½¿ç”¨ç©ºé—´ç½‘æ ¼å¯ä»¥æå¤§æå‡ç´¢æ•Œæ•ˆç‡
        this.runSimpleLogic(aiUnits, spatialGrid);

        // å®è§‚å†³ç­–ï¼šæ ¹æ®éš¾åº¦å’Œæ—¶é—´é—´éš”æ‰§è¡Œ
        if (this.macroTimer >= this.macroInterval) {
            switch (this.difficulty) {
                case 'medium':
                    this.runMediumLogic(aiUnits, playerUnits, map);
                    break;
                case 'hard':
                case 'hell':
                    this.runHardLogic(aiUnits, playerUnits, map);
                    break;
            }
            this.macroTimer = 0;
        }
        
        // åœ°ç‹±éš¾åº¦ä¸‹çš„é«˜é¢‘é›†ç«å¾®æ“
        if (this.difficulty === 'hell' && this.microTimer >= this.microInterval) {
            this.runHellMicro(aiUnits, playerUnits);
            this.microTimer = 0;
        }
    }

    /**
     * åŸºç¡€AIé€»è¾‘ï¼šè®©ç©ºé—²å•ä½ä½¿ç”¨ç©ºé—´ç½‘æ ¼è‡ªä¸»å¯»æ‰¾æœ€è¿‘çš„æ•Œäººã€‚
     * @param {Array<Unit>} aiUnits - AIçš„æ‰€æœ‰å•ä½ã€‚
     * @param {SpatialGrid} spatialGrid - ç©ºé—´ç½‘æ ¼ã€‚
     */
    runSimpleLogic(aiUnits, spatialGrid) {
        aiUnits.forEach(unit => {
            // å¦‚æœå•ä½ç©ºé—² (æ²¡æœ‰ç›®æ ‡ï¼Œæ²¡æœ‰è·¯å¾„) ä¸”ç´¢æ•Œå†·å´å®Œæ¯•
            if (!unit.target && unit.path.length === 0 && unit.findTargetCooldown <= 0) {
                 // ä½¿ç”¨æ–°çš„ç´¢æ•Œå‡½æ•°ï¼Œå®ƒå†…éƒ¨é€šè¿‡ç©ºé—´ç½‘æ ¼é«˜æ•ˆæŸ¥æ‰¾
                unit.findTarget(this.playerBase, spatialGrid);
            }
        });
    }

    /**
     * ä¸­ç­‰éš¾åº¦é€»è¾‘ï¼šç»„ç»‡å°å‹æ³¢æ¬¡è¿›æ”»ç©å®¶åŸºåœ°ã€‚
     * @param {Array<Unit>} aiUnits - AIçš„æ‰€æœ‰å•ä½ã€‚
     * @param {Array<Unit>} playerUnits - ç©å®¶çš„æ‰€æœ‰å•ä½ã€‚
     * @param {GameMap} map - æ¸¸æˆåœ°å›¾å¯¹è±¡ã€‚
     */
    runMediumLogic(aiUnits, playerUnits, map) {
        if (!this.playerBase || this.playerBase.hp <= 0) return;

        const livingAttackWave = this.attackWave.filter(u => u.hp > 0);

        // å¦‚æœè¿›æ”»æ³¢æ¬¡å•ä½å°‘äº3ä¸ªï¼Œåˆ™ä»ç©ºé—²å•ä½ä¸­è¡¥å……
        if (livingAttackWave.length < 3) {
            this.attackWave = aiUnits.filter(u => !u.target && u.path.length === 0).slice(0, 5); 
        }
        
        // å‘½ä»¤æ³¢æ¬¡ä¸­çš„å•ä½å‘ç©å®¶åŸºåœ°ç§»åŠ¨
        const targetPoint = { x: this.playerBase.pixelX, y: this.playerBase.pixelY };
        this.attackWave.forEach(unit => {
            if (unit.hp > 0 && !unit.target && unit.path.length === 0) {
                 unit.issueMoveCommand(targetPoint, map); 
            }
        });
    }

    /**
     * å›°éš¾/åœ°ç‹±éš¾åº¦é€»è¾‘ï¼šä¼˜å…ˆæ”»å‡»é«˜ä»·å€¼ç›®æ ‡ï¼Œå…¶æ¬¡æ”»å‡»åŸºåœ°ã€‚
     * @param {Array<Unit>} aiUnits - AIçš„æ‰€æœ‰å•ä½ã€‚
     * @param {Array<Unit>} playerUnits - ç©å®¶çš„æ‰€æœ‰å•ä½ã€‚
     * @param {GameMap} map - æ¸¸æˆåœ°å›¾å¯¹è±¡ã€‚
     */
    runHardLogic(aiUnits, playerUnits, map) {
        let priorityTarget = null;
        
        // å®šä¹‰é«˜ä»·å€¼ç›®æ ‡çš„ç±»å‹é¡ºåº
        const targetPriorities = ['howitzer', 'sniper', 'sam_launcher', 'destroyer'];
        for (const type of targetPriorities) {
            priorityTarget = playerUnits.find(pUnit => pUnit.type === type && pUnit.hp > 0);
            if (priorityTarget) break;
        }

        // å¦‚æœæ²¡æœ‰é«˜ä»·å€¼ç›®æ ‡ï¼Œåˆ™ä»¥ç©å®¶åŸºåœ°ä¸ºç›®æ ‡
        if (!priorityTarget && this.playerBase && this.playerBase.hp > 0) {
            priorityTarget = this.playerBase;
        }

        // å¦‚æœæ‰¾åˆ°ç›®æ ‡ï¼Œåˆ™ç»„ç»‡æ³¢æ¬¡è¿›æ”»
        if (priorityTarget) {
            const livingAttackWave = this.attackWave.filter(u => u.hp > 0);
            if (livingAttackWave.length < 4) {
                 this.attackWave = aiUnits.filter(u => !u.target && u.path.length === 0).slice(0, 6);
            }

            this.attackWave.forEach(unit => {
                if (unit.hp > 0) {
                    unit.target = priorityTarget;
                }
            });
        }
    }

    /**
     * åœ°ç‹±éš¾åº¦å¾®æ“ï¼šæ‰€æœ‰å•ä½é›†ç«å½“å‰è¡€é‡æœ€å°‘çš„æ•Œæ–¹å•ä½ã€‚
     * @param {Array<Unit>} aiUnits - AIçš„æ‰€æœ‰å•ä½ã€‚
     * @param {Array<Unit>} playerUnits - ç©å®¶çš„æ‰€æœ‰å•ä½ã€‚
     */
    runHellMicro(aiUnits, playerUnits) {
        if (playerUnits.length === 0) return;

        // æ‰¾åˆ°è¡€é‡æœ€ä½çš„ç©å®¶å•ä½
        const weakestPlayerUnit = playerUnits.reduce((weakest, unit) => {
            return (unit.hp < weakest.hp) ? unit : weakest;
        }, playerUnits[0]);

        // å‘½ä»¤å°„ç¨‹å†…çš„æ‰€æœ‰AIå•ä½æ”»å‡»è¯¥ç›®æ ‡
        if (weakestPlayerUnit) {
            aiUnits.forEach(aiUnit => {
                const dist = getDistance(aiUnit, weakestPlayerUnit);
                if (dist <= aiUnit.stats.range) {
                    aiUnit.target = weakestPlayerUnit;
                }
            });
        }
    }
}
```

---

### `base.js`
```javascript
// js/base.js

import { TILE_SIZE } from './config.js';

/**
 * @class Base
 * @description ä»£è¡¨ç©å®¶æˆ–AIçš„ä¸»åŸºåœ°ã€‚
 */
export class Base {
    /**
     * @param {string} owner - åŸºåœ°æ‰€æœ‰è€… ('player' or 'ai')ã€‚
     * @param {number} gridX - åŸºåœ°å·¦ä¸Šè§’çš„æ ¼å­Xåæ ‡ã€‚
     * @param {number} gridY - åŸºåœ°å·¦ä¸Šè§’çš„æ ¼å­Yåæ ‡ã€‚
     */
    constructor(owner, gridX, gridY) {
        this.owner = owner;
        this.gridX = gridX;
        this.gridY = gridY;
        this.width = 3;  // æ ¼å­å®½åº¦
        this.height = 3; // æ ¼å­é«˜åº¦
        
        this.maxHp = 2500;
        this.hp = this.maxHp;

        // é¢„è®¡ç®—åƒç´ ä¸­å¿ƒç‚¹ï¼Œç”¨äºå•ä½å¯»è·¯å’Œç´¢æ•Œ
        this.pixelX = (gridX + this.width / 2) * TILE_SIZE;
        this.pixelY = (gridY + this.height / 2) * TILE_SIZE;
    }

    /**
     * ä½¿åŸºåœ°æ‰¿å—ä¼¤å®³ã€‚
     * @param {number} amount - ä¼¤å®³é‡ã€‚
     */
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp < 0) {
            this.hp = 0;
        }
        console.log(`${this.owner}'s base took ${amount} damage, remaining HP: ${this.hp}`);
    }

    /**
     * åœ¨Canvasä¸Šç»˜åˆ¶åŸºåœ°çš„ç”Ÿå‘½æ¡ã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {number} [zoom=1] - å½“å‰é•œå¤´ç¼©æ”¾çº§åˆ«ã€‚
     */
    draw(ctx, zoom = 1) {
        const barWidth = this.width * TILE_SIZE;
        const barHeight = 10;
        const barX = this.gridX * TILE_SIZE;
        const barY = this.gridY * TILE_SIZE - barHeight - 5; // åœ¨åŸºåœ°åœ°å—ä¸Šæ–¹æ˜¾ç¤º

        // ç»˜åˆ¶è¡€æ¡èƒŒæ™¯
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // ç»˜åˆ¶å½“å‰è¡€é‡
        ctx.fillStyle = this.owner === 'player' ? 'cyan' : 'red';
        ctx.fillRect(barX, barY, barWidth * (this.hp / this.maxHp), barHeight);
        
        // ç»˜åˆ¶è¡€æ¡è¾¹æ¡†
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1 / zoom; // è¾¹æ¡†å®½åº¦ä¸å—ç¼©æ”¾å½±å“
        ctx.strokeRect(barX, barY, barWidth, barHeight);
    }
}
```

---

### `config.js`
```javascript
// js/config.js

/**
 * @file å­˜æ”¾æ¸¸æˆçš„æ ¸å¿ƒé…ç½®å’Œå¸¸é‡ã€‚
 */

// åŸºç¡€å°ºå¯¸å®šä¹‰
export const TILE_SIZE = 32; // æ¯ä¸ªåœ°å›¾æ ¼å­çš„åƒç´ å°ºå¯¸

// æ¸¸æˆé€Ÿåº¦å®šä¹‰
export const GAME_SPEEDS = {
    '0.5': 2,    // æ…¢é€Ÿ
    '1': 1,      // æ­£å¸¸
    '1.5': 0.66  // å¿«é€Ÿ
};

// åœ°å½¢å®šä¹‰
export const TERRAIN_TYPES = {
    // key: åœ°å½¢ID
    // name: æ˜¾ç¤ºåç§°
    // color: åœ°å›¾åŸºç¡€é¢œè‰²
    // traversableBy: å…è®¸é€šè¡Œçš„ç§»åŠ¨ç±»å‹æ•°ç»„ ('ground', 'sea', 'air', 'amphibious')
    // priority: æ¸²æŸ“æ··åˆæ•ˆæœæ—¶çš„ä¼˜å…ˆçº§ï¼Œé«˜ä¼˜å…ˆçº§ä¼šè¦†ç›–ä½ä¼˜å…ˆçº§
    // defenseBonus: (å¯é€‰) æ­¤åœ°å½¢æä¾›çš„é˜²å¾¡åŠ æˆ (æœªä½¿ç”¨)
    grass: { name: 'è‰åœ°', color: '#7CFC00', traversableBy: ['ground', 'amphibious'], priority: 1 },
    forest: { name: 'æ£®æ—', color: '#228B22', defenseBonus: 0.2, traversableBy: ['ground', 'amphibious'], priority: 2 },
    road: { name: 'é©¬è·¯', color: '#696969', traversableBy: ['ground', 'amphibious'], priority: 4 },
    water: { name: 'æµ·æ´‹', color: '#1E90FF', traversableBy: ['air', 'sea', 'amphibious'], priority: 3 },
    building: { name: 'å»ºç­‘', color: '#A9A9A9', defenseBonus: 0.3, traversableBy: [], priority: 0 },
    base: { name: 'åŸºåœ°', color: '#FFD700', defenseBonus: 0.1, traversableBy: ['ground', 'amphibious', 'air'], priority: 0 }
};

// å•ä½å®šä¹‰
export const UNIT_TYPES = {
    // --- æ­¥å…µ ---
    assault_infantry: {
        unitClass: 'æ­¥å…µ', icon: 'ğŸ‘¨â€âœˆï¸', name: 'çªå‡»æ­¥å…µ',
        cost: 1, hp: 100, attack: 15, defense: 5, range: 4 * TILE_SIZE, speed: 1.5 * TILE_SIZE, attackSpeed: 1.2, visionRange: 4 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/assault_infantry.png', drawScale: 1.5,
        ammoType: 'bullet', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0,
        description: 'åŸºç¡€ä½œæˆ˜å•ä½ï¼Œå»‰ä»·ä¸”çµæ´»ã€‚'
    },
    sniper: {
        unitClass: 'æ­¥å…µ', icon: 'ğŸ¯', name: 'ç‹™å‡»æ‰‹',
        cost: 3, hp: 70, attack: 50, defense: 0, range: 9 * TILE_SIZE, speed: 1.2 * TILE_SIZE, attackSpeed: 4.0, visionRange: 9 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/sniper.png', drawScale: 1.5,
        ammoType: 'bullet', ammoSpeed: 30 * TILE_SIZE, ammoSplashRadius: 0, special: 'SETUP_TO_FIRE', 
        description: 'è¶…è¿œå°„ç¨‹ï¼Œå¯¹æ­¥å…µå•ä½é€ æˆå·¨å¤§å¨èƒï¼Œä½†è‡ªèº«è„†å¼±ã€‚'
    },
    anti_tank_trooper: {
        unitClass: 'æ­¥å…µ', icon: 'ğŸš€', name: 'åå¦å…‹å…µ',
        cost: 2, hp: 90, attack: 25, defense: 5, range: 5 * TILE_SIZE, speed: 1.3 * TILE_SIZE, attackSpeed: 2.5, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'ground', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/anti_tank_trooper.png', drawScale: 1.5,
        ammoType: 'shell', ammoSpeed: 12 * TILE_SIZE, ammoSplashRadius: 0.5 * TILE_SIZE, counters: { armor: 1.8 },
        description: 'æºå¸¦ç«ç®­ç­’ï¼Œèƒ½æœ‰æ•ˆå¯¹æŠ—æ•Œæ–¹è£…ç”²å•ä½ã€‚'
    },
    // --- è£…ç”² ---
    main_battle_tank: {
        unitClass: 'è£…ç”²', icon: 'T', name: 'ä¸»æˆ˜å¦å…‹',
        cost: 5, hp: 400, attack: 50, defense: 35, range: 6 * TILE_SIZE, speed: 1.1 * TILE_SIZE, attackSpeed: 2.2, visionRange: 6 * TILE_SIZE * 1.5,
        moveType: 'ground', unitType: 'armor', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/main_battle_tank.png', drawScale: 3,
        ammoType: 'shell', ammoSpeed: 8 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: 'æˆ˜åœºä¸­åšï¼Œæ”»é˜²å…¼å¤‡ï¼Œæ˜¯åœ°é¢æ¨è¿›çš„æ ¸å¿ƒåŠ›é‡ã€‚'
    },
    light_tank: {
        unitClass: 'è£…ç”²', icon: 't', name: 'è½»å‹å¦å…‹',
        cost: 3, hp: 250, attack: 30, defense: 20, range: 5 * TILE_SIZE, speed: 1.8 * TILE_SIZE, attackSpeed: 1.8, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'ground', unitType: 'armor', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/light_tank.png', drawScale: 3,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0,
        description: 'æœºåŠ¨æ€§æ›´å¼ºï¼Œé€‚åˆä¾¦å¯Ÿå’Œå¿«é€Ÿç©¿æ’ã€‚'
    },
    amphibious_tank: {
        unitClass: 'è£…ç”²', icon: 'A', name: 'ä¸¤æ –å¦å…‹',
        cost: 4, hp: 300, attack: 35, defense: 25, range: 5 * TILE_SIZE, speed: 1.2 * TILE_SIZE, attackSpeed: 2.0, visionRange: 5 * TILE_SIZE * 1.5,
        moveType: 'amphibious', unitType: 'armor', canTarget: ['ground', 'sea','amphibious','sea'], imageSrc: 'assets/pics/amphibious_tank.png', drawScale: 3,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0,
        description: 'å¯ä»¥ç©¿è¶Šæ°´åŸŸå’Œé™†åœ°ï¼Œç”¨äºç™»é™†ä½œæˆ˜ã€‚'
    },
    // --- é£è¡Œ ---
    fighter_jet: {
        unitClass: 'é£è¡Œ', icon: 'âœˆï¸', name: 'æˆ˜æ–—æœº',
        cost: 6, hp: 200, attack: 60, defense: 10, range: 8 * TILE_SIZE, speed: 5.0 * TILE_SIZE, attackSpeed: 2.0, visionRange: 8 * TILE_SIZE * 1.5,
        moveType: 'air', canTarget: ['air','sea'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0, counters: { air: 1.8 },
        description: 'å¤ºå–åˆ¶ç©ºæƒçš„ç‹è€…ï¼Œä¸“é—¨çŒæ€æ•Œæ–¹é£è¡Œå•ä½ã€‚'
    },
    attack_helicopter: {
        unitClass: 'é£è¡Œ', icon: 'ğŸš', name: 'æ”»å‡»ç›´å‡æœº',
        cost: 5, hp: 250, attack: 40, defense: 15, range: 7 * TILE_SIZE, speed: 3.0 * TILE_SIZE, attackSpeed: 1.8, visionRange: 7 * TILE_SIZE * 1.5,
        moveType: 'air', unitType: 'air', canTarget: ['ground', 'sea','amphibious'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 0, counters: { armor: 1.4 },
        description: 'ä½ç©ºç›˜æ—‹çš„å¦å…‹æ€æ‰‹ï¼Œä¸ºåœ°é¢éƒ¨é˜Ÿæä¾›ç«åŠ›æ”¯æ´ã€‚'
    },
    recon_drone: {
        unitClass: 'é£è¡Œ', icon: 'ğŸ›°ï¸', name: 'æ— äººä¾¦å¯Ÿæœº',
        cost: 2, hp: 50, attack: 0, defense: 0, range: 0, speed: 4.0 * TILE_SIZE, attackSpeed: 99, visionRange: 0, // è§†é‡ç”±æˆ˜äº‰è¿·é›¾ç³»ç»Ÿå•ç‹¬å¤„ç†
        moveType: 'air', unitType: 'air', canTarget: [], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: null, ammoSpeed: 0, ammoSplashRadius: 0,
        description: 'å»‰ä»·çš„ç©ºä¸­ä¾¦å¯Ÿå•ä½ï¼Œç§»åŠ¨é€Ÿåº¦å¿«ï¼Œè§†é‡èŒƒå›´å¹¿ã€‚'
    },
    // --- ç‚®å…µ ---
    howitzer: {
        unitClass: 'ç‚®å…µ', icon: 'ğŸ’£', name: 'æ¦´å¼¹ç‚®',
        cost: 6, hp: 120, attack: 100, defense: 5, range: 12 * TILE_SIZE, speed: 0.8 * TILE_SIZE, attackSpeed: 5.0, visionRange: 12 * TILE_SIZE * 1.5,
        moveType: 'ground', special: 'SETUP_TO_FIRE', canTarget: ['ground','amphibious','sea'], imageSrc: 'assets/pics/howitzer.png', drawScale: 4,
        ammoType: 'shell', ammoSpeed: 15 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: 'è¶…è¿œç¨‹åœ°é¢å‹åˆ¶ç«åŠ›ï¼Œä½†éœ€è¦éƒ¨ç½²æ‰èƒ½å¼€ç«ã€‚'
    },
    sam_launcher: {
        unitClass: 'ç‚®å…µ', icon: 'ğŸ—¼', name: 'é˜²ç©ºç‚®',
        cost: 5, hp: 150, attack: 80, defense: 10, range: 10 * TILE_SIZE, speed: 1.0 * TILE_SIZE, attackSpeed: 0.4, visionRange: 10 * TILE_SIZE * 1.5,
        moveType: 'ground', special: 'SETUP_TO_FIRE', canTarget: ['air'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'shell', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0.5 * TILE_SIZE,
        description: 'è¿œç¨‹é˜²ç©ºæ­¦å™¨ï¼Œå¯¹æˆ˜æ–—æœºå’Œè½°ç‚¸æœºæ˜¯è‡´å‘½å¨èƒã€‚'
    },
    // --- æµ·å†› ---
    destroyer: {
        unitClass: 'æµ·å†›', icon: 'ğŸš¢', name: 'é©±é€èˆ°',
        cost: 8, hp: 600, attack: 70, defense: 30, range: 9 * TILE_SIZE, speed: 1.5 * TILE_SIZE, attackSpeed: 2.8, visionRange: 9 * TILE_SIZE * 1.5,
        moveType: 'sea', canTarget: ['ground', 'sea', 'air'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 30 * TILE_SIZE, ammoSplashRadius: 1.5 * TILE_SIZE,
        description: 'åŠŸèƒ½å…¨é¢çš„ä¸»åŠ›æˆ˜èˆ°ï¼Œå¯ä»¥æ”»å‡»æ¥è‡ªæµ·é™†ç©ºçš„ä»»ä½•æ•Œäººã€‚'
    },
    submarine: {
        unitClass: 'æµ·å†›', icon: 'ğŸŒŠ', name: 'æ½œè‰‡',
        cost: 7, hp: 400, attack: 90, defense: 15, range: 8 * TILE_SIZE, speed: 1.8 * TILE_SIZE, attackSpeed: 3.5, visionRange: 8 * TILE_SIZE * 1.5,
        moveType: 'undersea', canTarget: ['sea'], imageSrc: 'assets/assault_infantry.jpeg', drawScale: 1.5,
        ammoType: 'missile', ammoSpeed: 20 * TILE_SIZE, ammoSplashRadius: 0,
        description: 'æ°´ä¸‹æ€æ‰‹ï¼Œæ“…é•¿å¯¹æ•Œæ–¹æ½œè‰‡å’Œæ½œæ°´èˆ¹è¿›è¡Œæ”»å‡»ã€‚'
    },
};
```

---

### `game.js`
```javascript
// js/game.js

import { TILE_SIZE, UNIT_TYPES, GAME_SPEEDS, TERRAIN_TYPES } from './config.js';
import { MAP_DEFINITIONS } from './maps-data.js';
import { GameMap } from './map.js';
import { Unit } from './unit.js';
import { Player } from './player.js';
import { UI } from './ui.js';
import { Base } from './base.js';
import { getDistance } from './utils.js';
import { Projectile, Explosion } from './projectile.js';
import { findPath } from './pathfinding.js';
import { FogOfWar } from './fog-of-war.js';
import { SpatialGrid } from './spatial-grid.js';

/**
 * @class Game
 * @description æ¸¸æˆçš„ä¸»æ§åˆ¶å™¨ï¼Œè´Ÿè´£ç®¡ç†æ¸¸æˆçŠ¶æ€ã€ä¸»å¾ªç¯ã€æ¸²æŸ“å’Œç”¨æˆ·è¾“å…¥ã€‚
 */
export class Game {
    /**
     * @param {HTMLCanvasElement} canvas - æ¸¸æˆæ¸²æŸ“çš„Canvaså…ƒç´ ã€‚
     */
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        // æ¸¸æˆçŠ¶æ€ç®¡ç†
        this.gameState = 'setup'; // 'setup', 'deployment', 'playing', 'gameover'
        this.gameMode = 'annihilation';
        this.lastTime = 0;
        this.gameSpeedModifier = 1;
        this.showDetails = false; // æ˜¯å¦æ˜¾ç¤ºå•ä½è¯¦ç»†ä¿¡æ¯ï¼ˆå¦‚å°„ç¨‹åœˆï¼‰
        
        // æ¸¸æˆä¸–ç•Œå¯¹è±¡
        this.map = null;
        this.player = null;
        this.ai = null;
        this.playerBase = null;
        this.aiBase = null;
        this.fogOfWar = null;
        this.spatialGrid = null; // æ ¸å¿ƒæ€§èƒ½ä¼˜åŒ–ï¼šç©ºé—´ç½‘æ ¼
        
        // åŠ¨æ€å®ä½“æ•°ç»„
        this.projectiles = [];
        this.explosions = [];
        this.selectedUnits = [];
        
        // è¾“å…¥å’Œé•œå¤´æ§åˆ¶
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };
        this.dragEnd = { x: 0, y: 0 };
        this.mousePos = { x: 0, y: 0 };
        this.globalMousePos = { x: 0, y: 0 }; // é¼ æ ‡åœ¨çª—å£ä¸­çš„ä½ç½®ï¼Œç”¨äºè¾¹ç¼˜æ»šåŠ¨
        this.isDraggingMap = false;
        this.lastDragPos = { x: 0, y: 0 };
        this.camera = { x: 0, y: 0, zoom: 1, minZoom: 0.5, maxZoom: 2.5 };
        
        // è§¦æ‘¸æ§åˆ¶
        this.activeTouches = new Map();
        this.lastTouchDistance = 0;
        this.lastTouchCenter = null;
    }

    /**
     * åˆå§‹åŒ–æ¸¸æˆã€‚
     * @param {object} settings - ä»è®¾ç½®ç•Œé¢ä¼ å…¥çš„æ¸¸æˆé…ç½®ã€‚
     */
    init(settings) {
        this.gameMode = settings.gameMode;
        this.showDetails = settings.showDetails;
        this.fromDialogue = settings.fromDialogue || false;
        this.user = settings.user || null;
        
        // åŠ è½½åœ°å›¾
        const selectedMapData = MAP_DEFINITIONS.find(m => m.id === settings.mapId);
        this.map = new GameMap();
        this.map.load(selectedMapData);

        const mapWidthPixels = this.map.width * TILE_SIZE;
        const mapHeightPixels = this.map.height * TILE_SIZE;
        
        // åˆå§‹åŒ–æ€§èƒ½ä¼˜åŒ–æ¨¡å—
        // ç©ºé—´ç½‘æ ¼çš„å•å…ƒæ ¼å°ºå¯¸é€šå¸¸è®¾ç½®ä¸ºæœ€å¤§å•ä½è§†é‡èŒƒå›´å·¦å³ï¼Œä»¥ä¿è¯ä¸€æ¬¡æŸ¥è¯¢å°±èƒ½è¦†ç›–é‚»å±…
        const gridCellSize = TILE_SIZE * 15; 
        this.spatialGrid = new SpatialGrid(mapWidthPixels, mapHeightPixels, gridCellSize);
        this.fogOfWar = new FogOfWar(mapWidthPixels, mapHeightPixels);
        
        // æ ¹æ®æ¸¸æˆæ¨¡å¼åˆ›å»ºåŸºåœ°
        const baseGridY = Math.floor(this.map.height / 2) - 1; 
        if (this.gameMode === 'annihilation' || this.gameMode === 'defend') {
            this.playerBase = new Base('player', 6, baseGridY);
            this.placeBaseOnMap(this.playerBase);
        }
        if (this.gameMode === 'annihilation' || this.gameMode === 'attack') {
            this.aiBase = new Base('ai', this.map.width - 9, baseGridY);
            this.placeBaseOnMap(this.aiBase);
        }

        // åˆ›å»ºç©å®¶å’ŒAI
        const initialManpower = 100;
        this.player = new Player('player', 'ç©å®¶', initialManpower);
        const aiManpower = settings.aiDifficulty === 'hell' ? Math.round(initialManpower * 1.5) : initialManpower;
        this.ai = new Player('ai', 'ç”µè„‘', aiManpower, true, {}, settings.aiDifficulty);
        
        // é“¾æ¥AIæ§åˆ¶å™¨å’Œç©å®¶åŸºåœ°
        this.ai.aiController.playerBase = this.playerBase;
        this.ai.aiController.deployUnits(this.map.width, this.map.height, TILE_SIZE);
        
        this.ui = new UI(this);
        this.gameSpeedModifier = GAME_SPEEDS[settings.gameSpeed];
        this.gameState = 'deployment';
        
        this.addEventListeners();
        this.setupInitialCamera();
        
        window.game = this; // æ–¹ä¾¿è°ƒè¯•
        requestAnimationFrame(this.gameLoop.bind(this));
    }
    
    /**
     * è®¾ç½®åˆå§‹é•œå¤´ä½ç½®ï¼Œèšç„¦äºç©å®¶åŸºåœ°æˆ–åœ°å›¾ä¸­å¿ƒã€‚
     */
    setupInitialCamera() {
        this.camera.zoom = 1.2;
        let focusPoint = this.playerBase 
            ? { x: this.playerBase.pixelX, y: this.playerBase.pixelY }
            : { x: (this.map.width * TILE_SIZE) / 2, y: (this.map.height * TILE_SIZE) / 2 };
        
        this.camera.x = focusPoint.x - (this.canvas.width / 2) / this.camera.zoom;
        this.camera.y = focusPoint.y - (this.canvas.height / 2) / this.camera.zoom;
        
        this.constrainCamera();
    }
    
    /**
     * æ¸¸æˆä¸»å¾ªç¯ã€‚
     * @param {number} currentTime - `requestAnimationFrame` ä¼ å…¥çš„æ—¶é—´æˆ³ã€‚
     */
    gameLoop(currentTime) {
        if (!this.lastTime) this.lastTime = currentTime;
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;
        
        const adjustedDeltaTime = deltaTime / this.gameSpeedModifier;
        
        this.update(adjustedDeltaTime);
        this.draw();
        this.ui.update();
        
        requestAnimationFrame(this.gameLoop.bind(this));
    }

    /**
     * æ›´æ–°æ‰€æœ‰æ¸¸æˆé€»è¾‘ã€‚
     * @param {number} deltaTime - ç»è¿‡æ¸¸æˆé€Ÿåº¦è°ƒæ•´åçš„å¸§æ—¶é—´å·®ã€‚
     */
    update(deltaTime) {
        if (this.gameState === 'gameover' || this.gameState === 'setup') return;

        this.handleEdgeScrolling(deltaTime);
        this.constrainCamera();

        const allPlayerUnits = this.player.units;
        const allAiUnits = this.ai.units;
        const allUnits = [...allPlayerUnits, ...allAiUnits];
        
        // æ€§èƒ½ä¼˜åŒ–ï¼šæ¯å¸§æ¸…ç©ºå¹¶é‡æ–°æ’å…¥æ‰€æœ‰å•ä½åˆ°ç©ºé—´ç½‘æ ¼
        this.spatialGrid.clear();
        allUnits.forEach(unit => this.spatialGrid.insert(unit));
        
        if (this.gameState === 'playing' || this.gameState === 'deployment') {
            // æ›´æ–°å•ä½é€»è¾‘ï¼Œå¹¶ä¼ å…¥ç©ºé—´ç½‘æ ¼ç”¨äºé«˜æ•ˆç´¢æ•Œ
            allPlayerUnits.forEach(unit => unit.update(deltaTime, allAiUnits, this.map, this.aiBase, this, this.spatialGrid));
            allAiUnits.forEach(unit => unit.update(deltaTime, allPlayerUnits, this.map, this.playerBase, this, this.spatialGrid));
            
            // AIç©å®¶çš„å®è§‚æ›´æ–°
            if (this.gameState === 'playing') {
                 this.ai.update(deltaTime, this.player, this.map, this.spatialGrid);
            }
        }
        
        // æ›´æ–°ç‰©ç†ï¼ˆç¢°æ’ï¼‰å’Œå¼¹é“
        this.updatePhysics(deltaTime, allUnits);
        this.updateProjectiles(deltaTime);

        // æ¸…ç†æ­»äº¡å•ä½å’Œè¿‡æœŸçš„ç‰¹æ•ˆ
        this.explosions = this.explosions.filter(e => !e.update(deltaTime));
        this.player.units = this.player.units.filter(u => u.hp > 0);
        this.ai.units = this.ai.units.filter(u => u.hp > 0);
        this.selectedUnits = this.selectedUnits.filter(u => u.hp > 0);
        
        // æ›´æ–°æˆ˜äº‰è¿·é›¾
        const visionSources = [...this.player.units, this.playerBase].filter(Boolean);
        this.fogOfWar.update(visionSources);

        if (this.gameState === 'playing') {
            this.checkWinConditions();
        }
    }

    /**
     * æ¸²æŸ“æ‰€æœ‰å¯è§çš„æ¸¸æˆå…ƒç´ ã€‚
     */
    draw() {
        // æ¸…å±
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.save();
        
        // åº”ç”¨é•œå¤´å˜æ¢
        this.ctx.scale(this.camera.zoom, this.camera.zoom);
        this.ctx.translate(-this.camera.x, -this.camera.y);

        // æ€§èƒ½ä¼˜åŒ–ï¼šè®¡ç®—é•œå¤´å¯è§èŒƒå›´ï¼Œåªç»˜åˆ¶èŒƒå›´å†…çš„ç‰©ä½“ (Culling)
        const viewBounds = {
            left: this.camera.x,
            top: this.camera.y,
            right: this.camera.x + this.canvas.width / this.camera.zoom,
            bottom: this.camera.y + this.canvas.height / this.camera.zoom
        };
        const isVisible = (entity, padding = TILE_SIZE * 2) => {
            const x = entity.pixelX || entity.x;
            const y = entity.pixelY || entity.y;
            return x > viewBounds.left - padding && x < viewBounds.right + padding &&
                   y > viewBounds.top - padding && y < viewBounds.bottom + padding;
        };

        // æŒ‰å±‚çº§ç»˜åˆ¶
        this.map.draw(this.ctx, this.camera);
        if (this.playerBase) this.playerBase.draw(this.ctx, this.camera.zoom);
        if (this.aiBase) this.aiBase.draw(this.ctx, this.camera.zoom);

        const allUnits = [...this.player.units, ...this.ai.units];
        const groundSeaUnits = allUnits.filter(u => u.stats.moveType !== 'air');
        const airUnits = allUnits.filter(u => u.stats.moveType === 'air');

        // 1. ç»˜åˆ¶åœ°é¢/æµ·ä¸Šå•ä½
        groundSeaUnits.forEach(unit => {
            if (isVisible(unit)) {
                unit.draw(this.ctx, this.selectedUnits.includes(unit), this.camera.zoom, this.showDetails);
            }
        });
        
        // 2. ç»˜åˆ¶å¼¹é“å’Œçˆ†ç‚¸
        this.projectiles.forEach(p => { if(isVisible(p)) p.draw(this.ctx); });
        this.explosions.forEach(e => { if(isVisible(e)) e.draw(this.ctx); });
        
        // 3. ç»˜åˆ¶ç©ºä¸­å•ä½ï¼ˆç¡®ä¿åœ¨å¼¹é“ä¹‹ä¸Šï¼‰
        airUnits.forEach(unit => {
             if (isVisible(unit)) {
                unit.draw(this.ctx, this.selectedUnits.includes(unit), this.camera.zoom, this.showDetails);
            }
        });

        // 4. ç»˜åˆ¶æˆ˜äº‰è¿·é›¾
        this.fogOfWar.draw(this.ctx);

        this.ctx.restore();
        
        // ç»˜åˆ¶UIå…ƒç´ ï¼ˆå¦‚é€‰æ‹©æ¡†ï¼‰ï¼Œä¸å—é•œå¤´å½±å“
        if (this.isDragging && !this.isDraggingMap) {
            this.ctx.strokeStyle = 'rgba(100, 255, 100, 0.7)';
            this.ctx.lineWidth = 1;
            const rect = { 
                x: Math.min(this.dragStart.x, this.dragEnd.x), 
                y: Math.min(this.dragStart.y, this.dragEnd.y),
                w: Math.abs(this.dragStart.x - this.dragEnd.x),
                h: Math.abs(this.dragStart.y - this.dragEnd.y)
            };
            this.ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
        }
    }
    
    /**
     * æ›´æ–°å¼¹é“é€»è¾‘ï¼Œå¤„ç†å‘½ä¸­å’Œé”€æ¯ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    updateProjectiles(deltaTime) {
        const remainingProjectiles = [];
        for (const p of this.projectiles) {
            if (!p.update(deltaTime)) { // updateè¿”å›trueè¡¨ç¤ºå¼¹é“ç”Ÿå‘½å‘¨æœŸç»“æŸ
                remainingProjectiles.push(p);
            } else {
                this.handleProjectileHit(p);
            }
        }
        this.projectiles = remainingProjectiles;
    }

    /**
     * æ ¸å¿ƒé‡æ„: ä½¿ç”¨ç©ºé—´ç½‘æ ¼è¿›è¡Œé«˜æ•ˆçš„ç‰©ç†ç¢°æ’æ£€æµ‹ã€‚
     * é¿å…äº† O(n^2) çš„å…¨å±€éå†ï¼Œæ˜¾è‘—æå‡å•ä½å¤šæ—¶çš„æ€§èƒ½ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @param {Array<Unit>} allUnits - åœºæ™¯ä¸­çš„æ‰€æœ‰å•ä½ã€‚
     */
    updatePhysics(deltaTime, allUnits) {
        const PUSH_FORCE = 30;
        const processedPairs = new Set(); // é˜²æ­¢A-Bå’ŒB-Aé‡å¤è®¡ç®—

        for (const unitA of allUnits) {
            // ä»ç©ºé—´ç½‘æ ¼è·å–é™„è¿‘çš„å•ä½ï¼Œè€Œä¸æ˜¯éå†æ‰€æœ‰å•ä½
            const nearbyUnits = this.spatialGrid.getNearby(unitA);
            
            for (const unitB of nearbyUnits) {
                if (unitA.id === unitB.id) continue;

                // ä½¿ç”¨IDç»„åˆæ¥å”¯ä¸€æ ‡è¯†ä¸€å¯¹å•ä½ï¼Œé¿å…é‡å¤å¤„ç†
                const pairKey = unitA.id < unitB.id ? `${unitA.id}-${unitB.id}` : `${unitB.id}-${unitA.id}`;
                if (processedPairs.has(pairKey)) continue;
                processedPairs.add(pairKey);

                // ç©ºä¸­å•ä½å’Œéç©ºä¸­å•ä½ä¹‹é—´ä¸å‘ç”Ÿç¢°æ’
                const isAirA = unitA.stats.moveType === 'air';
                const isAirB = unitB.stats.moveType === 'air';
                if (isAirA !== isAirB) {
                    continue;
                }

                const distance = getDistance(unitA, unitB);
                // ä½¿ç”¨æ›´ç²¾ç¡®çš„åŠå¾„è¿›è¡Œç¢°æ’æ£€æµ‹
                const collisionRadius = (unitA.stats.drawScale + unitB.stats.drawScale) / 2 * (TILE_SIZE / 4);
                
                if (distance > 0 && distance < collisionRadius) {
                    const overlap = collisionRadius - distance;
                    const angle = Math.atan2(unitB.y - unitA.y, unitB.x - unitA.x);
                    
                    // æ ¹æ®é‡å ç¨‹åº¦å’ŒdeltaTimeè®¡ç®—æ¨å¼€çš„é‡
                    const pushAmount = overlap * PUSH_FORCE * deltaTime;
                    const pushX = Math.cos(angle) * pushAmount;
                    const pushY = Math.sin(angle) * pushAmount;
                    
                    // ä¸¤ä¸ªå•ä½å„æ¨å¼€ä¸€åŠ
                    unitA.x -= pushX * 0.5;
                    unitA.y -= pushY * 0.5;
                    unitB.x += pushX * 0.5;
                    unitB.y += pushY * 0.5;
                }
            }
        }
    }

    // --- äº‹ä»¶ç›‘å¬ä¸å¤„ç† ---
    
    addEventListeners() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        window.addEventListener('keydown', (e) => { 
            if (e.key === 'Escape') {
                this.selectedUnits = [];
                this.ui.clearDeploymentSelection();
            }
        });
        
        // è§¦æ‘¸äº‹ä»¶
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
        this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
    }

    handleMouseDown(e) {
        const pos = this.getMousePos(e);
        // å·¦é”®æˆ–ä¸­é”®æ‹–åŠ¨åœ°å›¾
        if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
            this.isDraggingMap = true;
            this.lastDragPos = { x: e.clientX, y: e.clientY };
            this.canvas.style.cursor = 'grabbing';
        } 
        // å·¦é”®å¼€å§‹é€‰æ‹©
        else if (e.button === 0) {
            this.isDragging = true;
            this.dragStart = pos;
            this.dragEnd = pos;
        }
    }

    handleMouseMove(e) {
        this.mousePos = this.getMousePos(e);
        this.globalMousePos = { x: e.clientX, y: e.clientY };
        
        if (this.isDraggingMap) {
            const dx = e.clientX - this.lastDragPos.x;
            const dy = e.clientY - this.lastDragPos.y;
            this.camera.x -= dx / this.camera.zoom;
            this.camera.y -= dy / this.camera.zoom;
            this.lastDragPos = { x: e.clientX, y: e.clientY };
        } else if (this.isDragging) {
            this.dragEnd = this.mousePos;
        }
    }

    handleMouseUp(e) {
        // å³é”®å‘½ä»¤
        if (e.button === 2) {
            const pos = this.getMousePos(e);
            this.handleRightClick(this.screenToWorld(pos.x, pos.y));
            return;
        }

        if (this.isDraggingMap) {
            this.isDraggingMap = false;
            this.canvas.style.cursor = 'default';
        } else if (this.isDragging) {
            this.isDragging = false;
            const pos = this.getMousePos(e);
            
            // å¦‚æœæ‹–åŠ¨è·ç¦»å¾ˆå°ï¼Œè§†ä¸ºå•å‡»
            if (getDistance(this.dragStart, pos) < 10) {
                this.handleLeftClick(this.screenToWorld(pos.x, pos.y));
            } else {
                this.handleBoxSelection();
            }
        }
    }
    
    /**
     * å¤„ç†å·¦é”®å•å‡»äº‹ä»¶ã€‚
     * @param {{x: number, y: number}} worldPos - ç‚¹å‡»ä½ç½®çš„ä¸–ç•Œåæ ‡ã€‚
     */
    handleLeftClick(worldPos) {
        // å¦‚æœUIä¸­é€‰æ‹©äº†å¾…éƒ¨ç½²å•ä½ï¼Œåˆ™å°è¯•éƒ¨ç½²
        if (this.ui.selectedUnitToDeploy) {
            this.tryDeployUnit(worldPos, this.ui.selectedUnitToDeploy);
            return;
        }
        
        // å¦‚æœå½“å‰æœ‰å•ä½è¢«é€‰ä¸­ï¼Œåˆ™æ¸…é™¤é€‰æ‹©
        if (this.selectedUnits.length > 0) {
            this.issueCommandForSelectedUnits(worldPos);
            return;
        }

        // å°è¯•é€‰ä¸­ä¸€ä¸ªå•ä½
        const clickedUnit = this.player.units.find(unit => getDistance(worldPos, unit) < TILE_SIZE / 2);
        this.selectedUnits = clickedUnit ? [clickedUnit] : [];
    }

    /**
     * å¤„ç†å³é”®å•å‡»äº‹ä»¶ï¼Œä¸ºé€‰ä¸­çš„å•ä½ä¸‹è¾¾å‘½ä»¤ã€‚
     * @param {{x: number, y: number}} worldPos - ç‚¹å‡»ä½ç½®çš„ä¸–ç•Œåæ ‡ã€‚
     */
    handleRightClick(worldPos) {
        if (this.selectedUnits.length > 0) {
            this.issueCommandForSelectedUnits(worldPos);
        }
    }

    /**
     * ä¸ºå½“å‰é€‰ä¸­çš„å•ä½ä¸‹è¾¾ç§»åŠ¨æˆ–æ”»å‡»å‘½ä»¤ã€‚
     * @param {{x: number, y: number}} worldPos - ç›®æ ‡ä¸–ç•Œåæ ‡ã€‚
     */
    issueCommandForSelectedUnits(worldPos) {
        let targetEnemy = null;
        const allEnemies = [...this.ai.units, this.aiBase].filter(Boolean);
        
        // æ£€æŸ¥æ˜¯å¦ç‚¹ä¸­äº†æ•Œäºº
        for (const enemy of allEnemies) {
            const enemyPos = { x: enemy.pixelX || enemy.x, y: enemy.pixelY || enemy.y };
            const clickRadius = (enemy instanceof Base) ? (enemy.width * TILE_SIZE / 2) : (TILE_SIZE / 2);
            if (getDistance(worldPos, enemyPos) < clickRadius) {
                targetEnemy = enemy;
                break;
            }
        }
        
        // å¦‚æœç‚¹ä¸­äº†æ•Œäººï¼Œåˆ™ä¸‹è¾¾æ”»å‡»å‘½ä»¤
        if (targetEnemy) {
            this.selectedUnits.forEach(unit => unit.target = targetEnemy);
        } 
        // å¦åˆ™ï¼Œä¸‹è¾¾ç§»åŠ¨å‘½ä»¤
        else {
            this.selectedUnits.forEach(unit => unit.target = null);
            if (this.selectedUnits.length === 1) {
                this.selectedUnits[0].issueMoveCommand(worldPos, this.map);
            } else {
                this.issueGroupMoveCommand(worldPos, this.map);
            }
        }
    }

    /**
     * åœ¨æŒ‡å®šä½ç½®éƒ¨ç½²ä¸€ä¸ªå•ä½ã€‚
     * @param {{x: number, y: number}} worldPos - éƒ¨ç½²ä½ç½®çš„ä¸–ç•Œåæ ‡ã€‚
     * @param {string} unitType - è¦éƒ¨ç½²çš„å•ä½ç±»å‹IDã€‚
     */
    tryDeployUnit(worldPos, unitType) {
        const cost = UNIT_TYPES[unitType].cost;
        
        // æ£€æŸ¥èµ„æºå’Œéƒ¨ç½²åŒºåŸŸ
        if (this.player.canAfford(cost) && worldPos.x < (this.map.width * TILE_SIZE) / 3) {
            const gridX = Math.floor(worldPos.x / TILE_SIZE);
            const gridY = Math.floor(worldPos.y / TILE_SIZE);
            const tile = this.map.getTile(gridX, gridY);
            const unitStats = UNIT_TYPES[unitType];

            // æ£€æŸ¥åœ°å½¢æ˜¯å¦å¯é€šè¡Œ
            const isTraversable = tile && TERRAIN_TYPES[tile.type].traversableBy.includes(unitStats.moveType);
            if (unitStats.moveType === 'air' || isTraversable) {
                this.player.units.push(new Unit(unitType, 'player', worldPos.x, worldPos.y));
                this.player.deductManpower(cost);
                this.ui.update();
            } else {
                this.ui.showGameMessage("è¯¥å•ä½æ— æ³•éƒ¨ç½²åœ¨æ­¤åœ°å½¢ä¸Šï¼");
            }
        } else {
            if (!this.player.canAfford(cost)) {
                this.ui.showGameMessage("èµ„æºä¸è¶³ï¼");
            } else {
                this.ui.showGameMessage("åªèƒ½åœ¨åœ°å›¾å·¦ä¾§1/3åŒºåŸŸéƒ¨ç½²ï¼");
            }
        }
    }

    /**
     * å¤„ç†é¼ æ ‡æ‹–æ‹½ç»“æŸåçš„æ¡†é€‰é€»è¾‘ã€‚
     */
    handleBoxSelection() {
        this.ui.clearDeploymentSelection();
        this.selectedUnits = [];
        
        const rect = { 
            x: Math.min(this.dragStart.x, this.dragEnd.x), 
            y: Math.min(this.dragStart.y, this.dragEnd.y),
            w: Math.abs(this.dragStart.x - this.dragEnd.x),
            h: Math.abs(this.dragStart.y - this.dragEnd.y)
        };
        
        this.player.units.forEach(unit => {
            const screenPos = this.worldToScreen(unit.x, unit.y);
            if (screenPos.x > rect.x && screenPos.x < rect.x + rect.w && 
                screenPos.y > rect.y && screenPos.y < rect.y + rect.h) {
                this.selectedUnits.push(unit);
            }
        });
    }

    /**
     * ä¸ºå¤šä¸ªå•ä½ä¸‹è¾¾ç§»åŠ¨å‘½ä»¤ï¼Œå¹¶ä¿æŒå…¶ç›¸å¯¹é˜µå‹ã€‚
     * @param {{x: number, y: number}} targetPos - ç›®æ ‡ç‚¹çš„ä¸–ç•Œåæ ‡ã€‚
     * @param {GameMap} map - æ¸¸æˆåœ°å›¾ã€‚
     */
    issueGroupMoveCommand(targetPos, map) {
        if (this.selectedUnits.length === 0) return;
        
        // è®¡ç®—é€‰ä¸­å•ä½çš„å‡ ä½•ä¸­å¿ƒ
        const centroid = this.selectedUnits.reduce((acc, unit) => ({ x: acc.x + unit.x, y: acc.y + unit.y }), { x: 0, y: 0 });
        centroid.x /= this.selectedUnits.length;
        centroid.y /= this.selectedUnits.length;
        
        // è®¡ç®—æ¯ä¸ªå•ä½ç›¸å¯¹äºä¸­å¿ƒçš„åç§»é‡
        const offsets = this.selectedUnits.map(unit => ({ dx: unit.x - centroid.x, dy: unit.y - centroid.y }));
        
        // ä¸ºæ¯ä¸ªå•ä½è®¾ç½®å¸¦æœ‰åç§»é‡çš„ç›®æ ‡ç‚¹
        this.selectedUnits.forEach((unit, index) => {
            const unitTargetPos = { 
                x: targetPos.x + offsets[index].dx,
                y: targetPos.y + offsets[index].dy 
            };
            unit.issueMoveCommand(unitTargetPos, map);
        });
    }

    // --- åæ ‡è½¬æ¢ä¸é•œå¤´ ---
    
    getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        return { 
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY 
        };
    }
    
    worldToScreen(worldX, worldY) {
        return { 
            x: (worldX - this.camera.x) * this.camera.zoom,
            y: (worldY - this.camera.y) * this.camera.zoom 
        };
    }

    screenToWorld(screenX, screenY) {
        return {
            x: screenX / this.camera.zoom + this.camera.x,
            y: screenY / this.camera.zoom + this.camera.y 
        };
    }
    
    constrainCamera() {
        if (!this.map) return;
        const mapWidthPixels = this.map.width * TILE_SIZE;
        const mapHeightPixels = this.map.height * TILE_SIZE;
        const viewWidth = this.canvas.width / this.camera.zoom;
        const viewHeight = this.canvas.height / this.camera.zoom;
        
        this.camera.x = Math.max(0, Math.min(this.camera.x, mapWidthPixels - viewWidth));
        this.camera.y = Math.max(0, Math.min(this.camera.y, mapHeightPixels - viewHeight));
    }
    
    handleWheel(e) {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 1.05 : 0.95;
        this.zoomAtPoint(zoomFactor, this.getMousePos(e));
    }

    zoomAtPoint(factor, point) {
        const oldZoom = this.camera.zoom;
        const newZoom = Math.max(this.camera.minZoom, Math.min(this.camera.maxZoom, oldZoom / factor));
        if (newZoom === oldZoom) return;
        
        const worldMouseX = point.x / oldZoom + this.camera.x;
        const worldMouseY = point.y / oldZoom + this.camera.y;
        
        this.camera.zoom = newZoom;
        this.camera.x = worldMouseX - point.x / newZoom;
        this.camera.y = worldMouseY - point.y / newZoom;
    }

    // --- è§¦æ‘¸æ§åˆ¶ ---

    handleTouchStart(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            this.activeTouches.set(touch.identifier, this.getTouchPos(touch));
        }
        this.updateTouchState();
    }
    
    handleTouchMove(e) {
        e.preventDefault();
        for (const touch of e.changedTouches) {
            this.activeTouches.set(touch.identifier, this.getTouchPos(touch));
        }
        
        const touches = Array.from(this.activeTouches.values());
        // åŒæŒ‡ç¼©æ”¾å’Œæ‹–åŠ¨
        if (touches.length === 2) {
            const currentCenter = { x: (touches[0].x + touches[1].x) / 2, y: (touches[0].y + touches[1].y) / 2 };
            const currentDistance = getDistance(touches[0], touches[1]);
            
            if (this.lastTouchCenter) {
                const dx = currentCenter.x - this.lastTouchCenter.x;
                const dy = currentCenter.y - this.lastTouchCenter.y;
                this.camera.x -= dx / this.camera.zoom;
                this.camera.y -= dy / this.camera.zoom;
            }
            if (this.lastTouchDistance > 0) {
                const zoomFactor = this.lastTouchDistance / currentDistance;
                this.zoomAtPoint(zoomFactor, currentCenter);
            }
            
            this.lastTouchCenter = currentCenter;
            this.lastTouchDistance = currentDistance;
        }
    }
    
    handleTouchEnd(e) {
        for (const touch of e.changedTouches) {
            this.activeTouches.delete(touch.identifier);
        }
        this.updateTouchState();
    }
    
    updateTouchState() {
        if (this.activeTouches.size < 2) {
            this.lastTouchDistance = 0;
            this.lastTouchCenter = null;
        }
    }
    
    getTouchPos(touch) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        return { 
            x: (touch.clientX - rect.left) * scaleX,
            y: (touch.clientY - rect.top) * scaleY 
        };
    }
    
    // --- æ¸¸æˆæµç¨‹ ---

    /**
     * é¼ æ ‡é è¿‘å±å¹•è¾¹ç¼˜æ—¶æ»šåŠ¨åœ°å›¾ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    handleEdgeScrolling(deltaTime) {
        if (this.isDraggingMap || this.isDragging || this.activeTouches.size > 0) return;
        
        const edgeMargin = 20;
        const scrollSpeed = 600 / this.camera.zoom;
        
        if (this.globalMousePos.x < edgeMargin) this.camera.x -= scrollSpeed * deltaTime;
        if (this.globalMousePos.x > window.innerWidth - edgeMargin) this.camera.x += scrollSpeed * deltaTime;
        if (this.globalMousePos.y < edgeMargin) this.camera.y -= scrollSpeed * deltaTime;
        if (this.globalMousePos.y > window.innerHeight - edgeMargin) this.camera.y += scrollSpeed * deltaTime;
    }
    
    /**
     * å¤„ç†å¼¹é“å‘½ä¸­é€»è¾‘ï¼ŒåŒ…æ‹¬ç›´æ¥ä¼¤å®³å’Œæº…å°„ä¼¤å®³ã€‚
     * @param {Projectile} p - å‘½ä¸­çš„å¼¹é“å¯¹è±¡ã€‚
     */
    handleProjectileHit(p) {
        this.explosions.push(new Explosion(p.x, p.y, p.stats.splashRadius || 10));

        // å¯¹ä¸»ç›®æ ‡é€ æˆä¼¤å®³
        if (p.target && p.target.hp > 0) {
            p.target.takeDamage(p.stats.damage);
        }

        // å¤„ç†æº…å°„ä¼¤å®³
        if (p.stats.splashRadius > 0) {
            const allTargets = [...this.player.units, ...this.ai.units, this.playerBase, this.aiBase].filter(Boolean);
            allTargets.forEach(entity => {
                if (entity.owner !== p.owner && entity.id !== p.target?.id && entity.hp > 0) {
                    const entityPos = { x: entity.pixelX || entity.x, y: entity.pixelY || entity.y };
                    const distance = getDistance(entityPos, p);
                    if (distance < p.stats.splashRadius) {
                        // ä¼¤å®³éšè·ç¦»è¡°å‡
                        const splashDamage = p.stats.damage * (1 - distance / p.stats.splashRadius);
                        entity.takeDamage(splashDamage);
                    }
                }
            });
        }
    }

    /**
     * å¼€å§‹æˆ˜æ–—ï¼Œå°†æ¸¸æˆçŠ¶æ€ä» 'deployment' åˆ‡æ¢åˆ° 'playing'ã€‚
     */
    startGame() {
        if (this.gameState === 'deployment') {
            this.gameState = 'playing';
        }
    }
    
    /**
     * æ£€æŸ¥èƒœåˆ©æˆ–å¤±è´¥æ¡ä»¶ã€‚
     */
    checkWinConditions() {
        if (this.gameState !== 'playing') return;
        
        const minCost = Math.min(...Object.values(UNIT_TYPES).map(u => u.cost));
        const pCanDeploy = this.player.manpower >= minCost;
        const pOutOfForces = this.player.units.length === 0 && !pCanDeploy;

        switch (this.gameMode) {
            case 'annihilation': // æ­¼ç­æ¨¡å¼
                if (this.playerBase?.hp <= 0) this.endGame(this.ai);
                else if (this.aiBase?.hp <= 0) this.endGame(this.player);
                break;
            case 'attack': // è¿›æ”»æ¨¡å¼
                if (this.aiBase?.hp <= 0) this.endGame(this.player);
                else if (pOutOfForces) this.endGame(this.ai);
                break;
            case 'defend': // é˜²å®ˆæ¨¡å¼
                if (this.playerBase?.hp <= 0) this.endGame(this.ai);
                else if (this.ai.units.length === 0 && this.ai.manpower < minCost) this.endGame(this.player);
                break;
        }
    }

    /**
     * ç»“æŸæ¸¸æˆå¹¶å®£å¸ƒèƒœåˆ©è€…ã€‚
     * @param {Player} winner - èƒœåˆ©çš„ç©å®¶å¯¹è±¡ã€‚
     */
    endGame(winner) {
        if (this.gameState === 'gameover') return;
        this.gameState = 'gameover';
        console.log(`${winner.name} è·èƒœ!`);
        this.ui.showWinner(winner.name);
        
        if (this.returnToDialogue()) {
            return;
        }
    }
    
    returnToDialogue() {
        const urlParams = new URLSearchParams(window.location.search);
        const fromDialogue = urlParams.get('fromDialogue');
        const user = urlParams.get('user');
        
        if (fromDialogue === 'true') {
            window.location.href = `./loading.html?target=dialogue.html&returnFromGame=true&user=${user}`;
            return true;
        }
        return false;
    }
    
    /**
     * åœ¨åœ°å›¾ä¸Šæ”¾ç½®åŸºåœ°ï¼Œå¹¶å°†å…¶åœ°å—ç±»å‹è®¾ä¸º'base'ã€‚
     * @param {Base} base - è¦æ”¾ç½®çš„åŸºåœ°å¯¹è±¡ã€‚
     */
    placeBaseOnMap(base) {
        for (let y = 0; y < base.height; y++) {
            for (let x = 0; x < base.width; x++) {
                this.map.setTileType(base.gridX + x, base.gridY + y, 'base');
            }
        }
    }
}
```

---

### `fog-of-war.js`
```javascript
// js/fog-of-war.js

import { TILE_SIZE } from './config.js';

/**
 * @class FogOfWar
 * @description ç®¡ç†æˆ˜äº‰è¿·é›¾æ•ˆæœã€‚
 * ä½¿ç”¨ä¸€ä¸ªç¦»å±Canvasè¿›è¡Œé¢„æ¸²æŸ“ä»¥æå‡æ€§èƒ½ã€‚
 */
export class FogOfWar {
    /**
     * @param {number} mapWidth - åœ°å›¾æ€»åƒç´ å®½åº¦ã€‚
     * @param {number} mapHeight - åœ°å›¾æ€»åƒç´ é«˜åº¦ã€‚
     */
    constructor(mapWidth, mapHeight) {
        this.mapWidth = mapWidth;
        this.mapHeight = mapHeight;

        // åˆ›å»ºç¦»å±Canvasç”¨äºç»˜åˆ¶è¿·é›¾
        this.fogCanvas = document.createElement('canvas');
        this.fogCanvas.width = this.mapWidth;
        this.fogCanvas.height = this.mapHeight;
        this.fogCtx = this.fogCanvas.getContext('2d');
    }

    /**
     * æ ¹æ®ç©å®¶å•ä½å’Œå»ºç­‘çš„ä½ç½®æ›´æ–°è¿·é›¾çº¹ç†ã€‚
     * è¿™æ˜¯ä¸€ä¸ªè®¡ç®—å¯†é›†å‹æ“ä½œï¼Œä½†ç”±äºåœ¨ç¦»å±Canvasä¸Šè¿›è¡Œï¼Œä¸ä¼šé˜»å¡ä¸»æ¸²æŸ“çº¿ç¨‹ã€‚
     * @param {Array<Unit|Base>} visibleEntities - ç©å®¶çš„æ‰€æœ‰å•ä½å’ŒåŸºåœ°æ•°ç»„ï¼Œç”¨äºæä¾›è§†é‡ã€‚
     */
    update(visibleEntities) {
        const ctx = this.fogCtx;

        // 1. å…ˆç”¨çº¯é»‘ fog è¦†ç›–æ•´ä¸ªåœ°å›¾
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, this.mapWidth, this.mapHeight);

        // 2. ä½¿ç”¨ 'destination-out' æ¨¡å¼åœ¨ fog ä¸Šâ€œå‡¿å¼€â€è§†é‡åŒºåŸŸ
        ctx.globalCompositeOperation = 'destination-out';

        visibleEntities.forEach(entity => {
            // ä¸ºå•ä½æˆ–åŸºåœ°è®¾ç½®è§†é‡èŒƒå›´
            const vision = entity.stats ? entity.stats.visionRange : 10 * TILE_SIZE; // åŸºåœ°é»˜è®¤è§†é‡
            const entityX = entity.pixelX || entity.x;
            const entityY = entity.pixelY || entity.y;
            
            // åˆ›å»ºä¸€ä¸ªå¾„å‘æ¸å˜ï¼Œå®ç°è§†é‡è¾¹ç¼˜çš„å¹³æ»‘è¿‡æ¸¡æ•ˆæœ
            const gradient = ctx.createRadialGradient(entityX, entityY, vision * 0.7, entityX, entityY, vision);
            gradient.addColorStop(0, 'rgba(0,0,0,1)'); // ä¸­å¿ƒå®Œå…¨é€æ˜
            gradient.addColorStop(1, 'rgba(0,0,0,0)'); // è¾¹ç¼˜æ¸å˜ä¸ºä¸é€æ˜

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(entityX, entityY, vision, 0, Math.PI * 2);
            ctx.fill();
        });

        // é‡ç½®æ··åˆæ¨¡å¼ï¼Œä»¥å¤‡ä¸‹æ¬¡æ›´æ–°
        ctx.globalCompositeOperation = 'source-over';
    }

    /**
     * å°†é¢„æ¸²æŸ“å¥½çš„è¿·é›¾Canvasç»˜åˆ¶åˆ°ä¸»æ¸¸æˆCanvasä¸Šã€‚
     * è¿™æ˜¯ä¸€ä¸ªéå¸¸å¿«é€Ÿçš„å›¾åƒç»˜åˆ¶æ“ä½œã€‚
     * @param {CanvasRenderingContext2D} mainCtx - ä¸»æ¸¸æˆçš„æ¸²æŸ“ä¸Šä¸‹æ–‡ã€‚
     */
    draw(mainCtx) {
        mainCtx.drawImage(this.fogCanvas, 0, 0);
    }
}
```

---

### `main.js`
```javascript
// js/main.js

import { Game } from './game.js';
import { MAP_DEFINITIONS } from './maps-data.js';
import { UNIT_TYPES } from './config.js';

/**
 * @class AssetManager
 * @description ä¸€ä¸ªç®€å•çš„èµ„æºç®¡ç†å™¨ï¼Œç”¨äºé¢„åŠ è½½å›¾ç‰‡ã€‚
 */
class AssetManager {
    constructor() {
        this.assets = {};
        this.downloadQueue = [];
        this.successCount = 0;
        this.errorCount = 0;
    }

    /**
     * å°†ä¸€ä¸ªå›¾ç‰‡è·¯å¾„æ·»åŠ åˆ°ä¸‹è½½é˜Ÿåˆ—ã€‚
     * @param {string} path - å›¾ç‰‡çš„URLã€‚
     */
    queueDownload(path) {
        if (path && !this.downloadQueue.includes(path)) {
            this.downloadQueue.push(path);
        }
    }

    /**
     * æ£€æŸ¥æ˜¯å¦æ‰€æœ‰èµ„æºéƒ½å·²åŠ è½½å®Œæˆï¼ˆæ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼‰ã€‚
     * @returns {boolean}
     */
    isDone() {
        return this.downloadQueue.length === this.successCount + this.errorCount;
    }

    /**
     * å¼€å§‹ä¸‹è½½é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èµ„æºã€‚
     * @param {function} callback - æ‰€æœ‰èµ„æºåŠ è½½å®Œæˆåè°ƒç”¨çš„å›è°ƒå‡½æ•°ã€‚
     */
    downloadAll(callback) {
        if (this.downloadQueue.length === 0) {
            callback();
            return;
        }
        
        this.downloadQueue.forEach(path => {
            const img = new Image();
            img.onload = () => {
                this.successCount++;
                if (this.isDone()) {
                    callback();
                }
            };
            img.onerror = () => {
                this.errorCount++;
                console.error("Error loading image: " + path);
                if (this.isDone()) {
                    callback();
                }
            };
            img.src = path;
            this.assets[path] = img;
        });
    }
}

// DOMåŠ è½½å®Œæˆåæ‰§è¡Œ
window.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('game-canvas');
    const setupScreen = document.getElementById('setup-screen');
    const startNewGameBtn = document.getElementById('start-new-game-btn');
    const mapSelect = document.getElementById('map-select');
    
    // åŠ¨æ€å¡«å……åœ°å›¾é€‰æ‹©ä¸‹æ‹‰æ¡†
    MAP_DEFINITIONS.forEach(map => {
        const option = document.createElement('option');
        option.value = map.id;
        option.textContent = map.name;
        mapSelect.appendChild(option);
    });

    // é¢„åŠ è½½æ‰€æœ‰å•ä½å›¾ç‰‡
    const assetManager = new AssetManager();
    Object.values(UNIT_TYPES).forEach(unit => {
        assetManager.queueDownload(unit.imageSrc);
    });
    
    // å°†åŠ è½½å¥½çš„å›¾ç‰‡å­˜æ”¾åœ¨å…¨å±€ï¼Œæ–¹ä¾¿æ¸¸æˆå†…å…¶ä»–æ¨¡å—è®¿é—®
    window.assetManager = assetManager.assets; 
    
    startNewGameBtn.disabled = true;
    startNewGameBtn.textContent = 'æ­£åœ¨åŠ è½½èµ„æº...';
    assetManager.downloadAll(() => {
        startNewGameBtn.disabled = false;
        startNewGameBtn.textContent = 'åˆ›å»ºæ¸¸æˆ';
    });
    
    /**
     * è°ƒæ•´æ¸¸æˆCanvaså°ºå¯¸ä»¥é€‚åº”çª—å£å˜åŒ–ã€‚
     */
    function resizeGame() {
        const sidebar = document.getElementById('sidebar');
        const sidebarWidth = sidebar ? sidebar.offsetWidth : 0;
        canvas.width = window.innerWidth - sidebarWidth;
        canvas.height = window.innerHeight;
        
        // å¦‚æœæ¸¸æˆå·²ç»å¼€å§‹ï¼Œåˆ™çº¦æŸé•œå¤´èŒƒå›´
        if (window.game && window.game.constrainCamera) {
            window.game.constrainCamera();
        }
    }

    resizeGame();
    window.addEventListener('resize', resizeGame);

    // "åˆ›å»ºæ¸¸æˆ" æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    startNewGameBtn.addEventListener('click', () => {
        const urlParams = new URLSearchParams(window.location.search);
        
        const showDetailsCheckbox = document.getElementById('show-details-checkbox');
        
        // ä»UIæ”¶é›†æ¸¸æˆè®¾ç½®
        const settings = {
            gameMode: document.getElementById('game-mode-select').value,
            mapId: mapSelect.value,
            gameSpeed: document.getElementById('game-speed-select').value,
            aiDifficulty: document.getElementById('ai-difficulty-select').value,
            showDetails: showDetailsCheckbox.checked, // è¯»å–å¤é€‰æ¡†çŠ¶æ€
            fromDialogue: urlParams.get('fromDialogue') === 'true',
            user: urlParams.get('user')
        };
        
        setupScreen.style.display = 'none';
        
        const game = new Game(canvas);
        game.init(settings);
    });
});
```

---

### `map.js`
```javascript
// js/map.js

import { TILE_SIZE, TERRAIN_TYPES } from './config.js';

/**
 * ç”Ÿæˆä¸€ä¸ªåŸºäºç§å­çš„ä¼ªéšæœºæ•°ã€‚
 * @param {number} seed - ç§å­ã€‚
 * @returns {number} - è¿”å›ä¸€ä¸ªåœ¨ [0, 1) åŒºé—´å†…çš„æµ®ç‚¹æ•°ã€‚
 */
function seededRandom(seed) {
    let x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
}

/**
 * @class GameMap
 * @description ç®¡ç†æ¸¸æˆåœ°å›¾æ•°æ®å’Œæ¸²æŸ“ã€‚
 */
export class GameMap {
    constructor() {
        this.width = 0;
        this.height = 0;
        this.grid = []; // äºŒç»´æ•°ç»„ï¼Œå­˜å‚¨æ¯ä¸ªæ ¼å­çš„åœ°å½¢ä¿¡æ¯
        this.terrainDetails = new Map(); // ç¼“å­˜åœ°å½¢ç»†èŠ‚ï¼Œé¿å…é‡å¤è®¡ç®—
    }

    /**
     * ä»åœ°å›¾æ•°æ®åŠ è½½åœ°å›¾ã€‚
     * @param {object} mapData - æ¥è‡ª maps-data.js çš„åœ°å›¾å®šä¹‰å¯¹è±¡ã€‚
     */
    load(mapData) {
        this.width = mapData.width;
        this.height = mapData.height;
        const terrainMap = { 'g': 'grass', 'f': 'forest', 'r': 'road', 'w': 'water', 'b': 'building' };
        
        this.grid = Array(this.height).fill(null).map(() => Array(this.width).fill(null));
        
        for (let y = 0; y < this.height; y++) {
            const rowString = mapData.grid[y] || '';
            for (let x = 0; x < this.width; x++) {
                const char = rowString[x] || 'g'; // é»˜è®¤ä¸ºè‰åœ°
                const type = terrainMap[char];
                this.grid[y][x] = { type };
            }
        }
    }

    /**
     * ç»˜åˆ¶åœ°å›¾ï¼ŒåŒ…å«åœ°å½¢æ··åˆå’Œç»†èŠ‚æ¸²æŸ“ã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {object} camera - é•œå¤´å¯¹è±¡ï¼Œç”¨äºè§†å£å‰”é™¤ã€‚
     */
    draw(ctx, camera) {
        // è®¡ç®—éœ€è¦æ¸²æŸ“çš„æ ¼å­èŒƒå›´ (è§†å£å‰”é™¤)
        const startX = Math.floor(camera.x / TILE_SIZE);
        const startY = Math.floor(camera.y / TILE_SIZE);
        const endX = Math.ceil((camera.x + ctx.canvas.width / camera.zoom) / TILE_SIZE);
        const endY = Math.ceil((camera.y + ctx.canvas.height / camera.zoom) / TILE_SIZE);

        for (let y = startY; y < endY; y++) {
            for (let x = startX; x < endX; x++) {
                if (x < 0 || y < 0 || x >= this.width || y >= this.height) continue;
                
                const tile = this.getTile(x, y);
                if (!tile) continue;
                
                // 1. ç»˜åˆ¶åŸºç¡€åœ°å½¢é¢œè‰²
                const baseColor = TERRAIN_TYPES[tile.type].color;
                ctx.fillStyle = baseColor;
                ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE + 1, TILE_SIZE + 1); // +1 ä¿®å¤æ ¼å­é—´ç¼éš™

                // 2. ç»˜åˆ¶åœ°å½¢è¾¹ç¼˜æ··åˆæ•ˆæœ
                this.drawTerrainBlend(ctx, x, y);

                // 3. ç»˜åˆ¶åœ°å½¢ç»†èŠ‚ (å°æ‚è‰²ç‚¹)
                this.drawTerrainDetails(ctx, x, y, baseColor);
            }
        }
    }

    /**
     * æ£€æŸ¥é‚»å±…å¹¶ç»˜åˆ¶åœ°å½¢æ··åˆæ•ˆæœã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {number} x - æ ¼å­Xåæ ‡ã€‚
     * @param {number} y - æ ¼å­Yåæ ‡ã€‚
     */
    drawTerrainBlend(ctx, x, y) {
        const neighbors = [
            { dx: 0, dy: -1, dir: 'top' }, 
            { dx: 1, dy: 0, dir: 'right' }, 
            { dx: 0, dy: 1, dir: 'bottom' }, 
            { dx: -1, dy: 0, dir: 'left' }
        ];
        
        const currentType = TERRAIN_TYPES[this.getTile(x, y).type];

        for (const neighbor of neighbors) {
            const nx = x + neighbor.dx;
            const ny = y + neighbor.dy;

            const neighborTile = this.getTile(nx, ny);
            if (neighborTile) {
                const neighborType = TERRAIN_TYPES[neighborTile.type];

                // å¦‚æœé‚»å±…åœ°å½¢çš„æ¸²æŸ“ä¼˜å…ˆçº§æ›´é«˜ï¼Œåˆ™åœ¨æ­¤æ ¼å­çš„è¾¹ç¼˜ç»˜åˆ¶é‚»å±…åœ°å½¢çš„é¢œè‰²ï¼Œå½¢æˆæ··åˆæ•ˆæœ
                if (neighborType.priority > currentType.priority && currentType.priority > 0) {
                    this._drawBlendPattern(ctx, x, y, neighbor.dir, neighborType.color);
                }
            }
        }
    }

    /**
     * ç»˜åˆ¶åœ°å½¢ä¸Šçš„éšæœºç»†èŠ‚ï¼Œå¢åŠ è§†è§‰ä¸°å¯Œåº¦ã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {number} x - æ ¼å­Xåæ ‡ã€‚
     * @param {number} y - æ ¼å­Yåæ ‡ã€‚
     * @param {string} baseColor - æ ¼å­çš„åŸºç¡€é¢œè‰²ã€‚
     */
    drawTerrainDetails(ctx, x, y, baseColor) {
        const detailKey = `${x},${y}`;
        if (!this.terrainDetails.has(detailKey)) {
            const details = [];
            const numDetails = Math.floor(seededRandom(y * this.width + x + 1) * 5);
            for (let i = 0; i < numDetails; i++) {
                details.push({
                    x: seededRandom(i + x * y + 2) * TILE_SIZE,
                    y: seededRandom(i * 2 + x * y + 3) * TILE_SIZE,
                    size: seededRandom(i * 3 + x * y + 4) * (TILE_SIZE / 4) + 2,
                    color: this.adjustColor(baseColor, (seededRandom(i * 4 + x * y + 5) - 0.5) * 0.2)
                });
            }
            this.terrainDetails.set(detailKey, details);
        }

        const cachedDetails = this.terrainDetails.get(detailKey);
        for(const detail of cachedDetails) {
            ctx.fillStyle = detail.color;
            ctx.fillRect(x * TILE_SIZE + detail.x, y * TILE_SIZE + detail.y, detail.size, detail.size);
        }
    }

    /**
     * æ ¹æ®æ–¹å‘ç»˜åˆ¶ç¡®å®šçš„éšæœºæ··åˆå›¾æ¡ˆï¼Œå®ç°è‡ªç„¶çš„è¿‡æ¸¡æ•ˆæœã€‚
     * @private
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {number} x - å½“å‰ç“¦ç‰‡çš„æ ¼å­Xåæ ‡ã€‚
     * @param {number} y - å½“å‰ç“¦ç‰‡çš„æ ¼å­Yåæ ‡ã€‚
     * @param {string} direction - é‚»å±…çš„æ–¹å‘ ('top', 'right', 'bottom', 'left')ã€‚
     * @param {string} blendColor - é‚»å±…ï¼ˆé«˜ä¼˜å…ˆçº§åœ°å½¢ï¼‰çš„é¢œè‰²ã€‚
     */
    _drawBlendPattern(ctx, x, y, direction, blendColor) {
        ctx.fillStyle = blendColor;
        const subTileCount = 4; // å°†ç“¦ç‰‡è¾¹ç¼˜åˆ†ä¸º4ä¸ªå°å—è¿›è¡Œå¤„ç†
        const subTileSize = TILE_SIZE / subTileCount; 
        const pixelX = x * TILE_SIZE;
        const pixelY = y * TILE_SIZE;

        for (let i = 0; i < subTileCount; i++) {
            // ä½¿ç”¨ç“¦ç‰‡åæ ‡å’Œå—ç´¢å¼•ä½œä¸ºç§å­ï¼Œç¡®ä¿æ¯æ¬¡æ¸²æŸ“çš„å›¾æ¡ˆéƒ½ç›¸åŒ
            const seed = x * 13 + y * 31 + i * 7 + direction.charCodeAt(0);
            const randomVal = seededRandom(seed);
            
            if (randomVal < 0.6) { // çº¦60%çš„æ¦‚ç‡ç»˜åˆ¶æ··åˆå—
                // æ··åˆæ·±åº¦éšæœºï¼Œä½†ç¡®å®š
                const blendDepth = Math.ceil(seededRandom(seed * 2) * 2) * (subTileSize / 2);
                
                let rectX, rectY, rectW, rectH;

                switch (direction) {
                    case 'top':
                        rectX = pixelX + i * subTileSize; rectY = pixelY;
                        rectW = subTileSize; rectH = blendDepth;
                        break;
                    case 'bottom':
                        rectX = pixelX + i * subTileSize; rectY = pixelY + TILE_SIZE - blendDepth;
                        rectW = subTileSize; rectH = blendDepth;
                        break;
                    case 'left':
                        rectX = pixelX; rectY = pixelY + i * subTileSize;
                        rectW = blendDepth; rectH = subTileSize;
                        break;
                    case 'right':
                        rectX = pixelX + TILE_SIZE - blendDepth; rectY = pixelY + i * subTileSize;
                        rectW = blendDepth; rectH = subTileSize;
                        break;
                }
                 ctx.fillRect(rectX, rectY, rectW + 1, rectH + 1); // +1 ä¿®å¤ç¼éš™
            }
        }
    }

    /**
     * å¾®è°ƒé¢œè‰²ï¼Œç”¨äºç”Ÿæˆåœ°å½¢ç»†èŠ‚ã€‚
     * @param {string} hex - 16è¿›åˆ¶é¢œè‰²å­—ç¬¦ä¸² (e.g., '#FF0000')ã€‚
     * @param {number} percent - è°ƒæ•´ç™¾åˆ†æ¯” (e.g., -0.2 to 0.2)ã€‚
     * @returns {string} - è°ƒæ•´åçš„16è¿›åˆ¶é¢œè‰²å­—ç¬¦ä¸²ã€‚
     */
    adjustColor(hex, percent) {
        let r = parseInt(hex.substring(1, 3), 16);
        let g = parseInt(hex.substring(3, 5), 16);
        let b = parseInt(hex.substring(5, 7), 16);
        const amount = Math.floor(255 * percent);
        r = Math.max(0, Math.min(255, r + amount));
        g = Math.max(0, Math.min(255, g + amount));
        b = Math.max(0, Math.min(255, b + amount));
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    /**
     * è·å–æŒ‡å®šåæ ‡çš„æ ¼å­ä¿¡æ¯ã€‚
     * @param {number} x - æ ¼å­Xåæ ‡ã€‚
     * @param {number} y - æ ¼å­Yåæ ‡ã€‚
     * @returns {object|null} - è¿”å›æ ¼å­å¯¹è±¡ï¼Œå¦‚æœè¶Šç•Œåˆ™è¿”å›nullã€‚
     */
    getTile(x, y) {
        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
            return this.grid[y][x];
        }
        return null;
    }

    /**
     * è®¾ç½®æŒ‡å®šåæ ‡æ ¼å­çš„åœ°å½¢ç±»å‹ã€‚
     * @param {number} x - æ ¼å­Xåæ ‡ã€‚
     * @param {number} y - æ ¼å­Yåæ ‡ã€‚
     * @param {string} newType - æ–°çš„åœ°å½¢ç±»å‹IDã€‚
     */
    setTileType(x, y, newType) {
        const tile = this.getTile(x, y);
        if (tile && TERRAIN_TYPES[newType]) {
            tile.type = newType;
        }
    }
}```

---

### `maps-data.js`
```javascript
// js/maps-data.js

/**
 * @file å­˜æ”¾æ‰€æœ‰åœ°å›¾çš„å®šä¹‰æ•°æ®ã€‚
 * åœ°å›¾æ ¼å­å­—ç¬¦ä»£è¡¨:
 * 'g': è‰åœ° (grass)
 * 'f': æ£®æ— (forest)
 * 'r': é©¬è·¯ (road)
 * 'w': æµ·æ´‹ (water)
 * 'b': å»ºç­‘ (building)
 */
export const MAP_DEFINITIONS = [
    {
        id: 'map_new_01',
        name: 'åå­—è·¯å£å†²çª (Crossroads Clash)',
        description: 'ä¸­å¿ƒé“è·¯æ˜¯å…µå®¶å¿…äº‰ä¹‹åœ°ï¼Œä¸¤ä¾§çš„æ£®æ—ä¸ºä¼å‡»æä¾›äº†å¯èƒ½ã€‚',
        width: 80, 
        height: 60,
        grid: (() => {
            const w = 80, h = 60;
            let grid = Array(h).fill(null).map(() => Array(w).fill('g'));
            
            // ä¸»å¹²é“
            for (let y = 0; y < h; y++) {
                grid[y][Math.floor(w/2) -1] = 'r';
                grid[y][Math.floor(w/2)] = 'r';
            }
             for (let x = 0; x < w; x++) {
                grid[Math.floor(h/2) -1][x] = 'r';
                grid[Math.floor(h/2)][x] = 'r';
            }
            
            // å››è§’çš„æ£®æ—åŒºåŸŸ
            for (let y = 10; y < 22; y++) {
                for(let x = 10; x < 25; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
                for(let x = w - 25; x < w - 10; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
            }
             for (let y = h - 22; y < h - 10; y++) {
                for(let x = 10; x < 25; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
                for(let x = w - 25; x < w - 10; x++) if(Math.random() > 0.3) grid[y][x] = 'f';
            }

            // ä¸Šä¸‹çš„æ²³æµï¼ˆå¸¦æ¡¥ï¼‰
            for (let x = 28; x < 52; x++) {
                 if (x > 38 && x < 42) continue; // æ¡¥çš„ä½ç½®ç•™ç©º
                 grid[5][x] = 'w';
                 grid[h-6][x] = 'w';
            }
            return grid.map(row => row.join(''));
        })()
    },
    {
        id: 'map01',
        name: 'åŒå­æ¡¥ (Twin Bridges)',
        description: 'ä¸€æ¡æ²³æµå°†åœ°å›¾ä¸€åˆ†ä¸ºäºŒï¼Œåªæœ‰ä¸¤åº§æ¡¥æ¢å¯ä¾›åœ°é¢éƒ¨é˜Ÿé€šè¿‡ã€‚',
        width: 100, 
        height: 60,
        grid: (() => {
            const w = 100, h = 60;
            let grid = Array(h).fill(null).map(() => Array(w).fill('g'));
            
            // æ²³æµ
            for (let y = 28; y < 32; y++) {
                for (let x = 0; x < w; x++) grid[y][x] = 'w';
            }
            
            // æ¡¥æ¢ (ç”¨é©¬è·¯ä»£æ›¿)
            for (let y = 28; y < 32; y++) {
                for(let x = 20; x < 28; x++) grid[y][x] = 'r';
                for(let x = 72; x < 80; x++) grid[y][x] = 'r';
            }

            // æ·»åŠ ä¸€äº›éšæœºæ£®æ—
            for (let i = 0; i < 200; i++) {
                const randX = Math.floor(Math.random() * w);
                const randY = Math.floor(Math.random() * h);
                if (grid[randY][randX] === 'g') grid[randY][randX] = 'f';
            }
            return grid.map(row => row.join(''));
        })()
    },
];
```

---

### `pathfinding.js`
```javascript
// js/pathfinding.js

import { TILE_SIZE, TERRAIN_TYPES } from './config.js';

/**
 * @class Node
 * @description A* å¯»è·¯ç®—æ³•ä¸­ä½¿ç”¨çš„èŠ‚ç‚¹ã€‚
 */
class Node {
    constructor(parent = null, position = null) {
        this.parent = parent;
        this.position = position; // {x, y} æ ¼å­åæ ‡
        this.g = 0; // ä»èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„ä»£ä»·
        this.h = 0; // ä»å½“å‰èŠ‚ç‚¹åˆ°ç»ˆç‚¹çš„é¢„ä¼°ä»£ä»· (å¯å‘å¼)
        this.f = 0; // æ€»ä»£ä»· (g + h)
    }

    /**
     * æ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦ä¸å¦ä¸€ä¸ªèŠ‚ç‚¹ä½ç½®ç›¸åŒã€‚
     * @param {Node} other - å¦ä¸€ä¸ªèŠ‚ç‚¹ã€‚
     * @returns {boolean}
     */
    equals(other) {
        return this.position.x === other.position.x && this.position.y === other.position.y;
    }
}

/**
 * ä½¿ç”¨ A* ç®—æ³•åœ¨åœ°å›¾ä¸Šå¯»æ‰¾è·¯å¾„ã€‚
 * @param {GameMap} map - æ¸¸æˆåœ°å›¾å¯¹è±¡ã€‚
 * @param {{x: number, y: number}} start - èµ·ç‚¹æ ¼å­åæ ‡ã€‚
 * @param {{x: number, y: number}} end - ç»ˆç‚¹æ ¼å­åæ ‡ã€‚
 * @param {string} moveType - ç§»åŠ¨å•ä½çš„ç±»å‹ ('ground', 'air', etc.)ã€‚
 * @returns {Array<{x: number, y: number}>|null} - è¿”å›ä¸€ä¸ªåŒ…å«è·¯å¾„èŠ‚ç‚¹åæ ‡çš„æ•°ç»„ï¼Œå¦‚æœæ‰¾ä¸åˆ°è·¯å¾„åˆ™è¿”å›nullã€‚
 */
export function findPath(map, start, end, moveType) {
    // å¯¹äºç©ºä¸­å•ä½ï¼Œè·¯å¾„å°±æ˜¯ä¸€æ¡ç›´çº¿ï¼Œæ— éœ€å¯»è·¯
    if (moveType === 'air') {
        return [start, end];
    }
    
    const startNode = new Node(null, start);
    const endNode = new Node(null, end);

    let openList = []; // å¾…è¯„ä¼°çš„èŠ‚ç‚¹
    let closedList = []; // å·²è¯„ä¼°çš„èŠ‚ç‚¹

    openList.push(startNode);
    
    // è®¾ç½®æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œé˜²æ­¢å› åœ°å›¾è¿‡å¤§æˆ–æ— è§£å¯¼è‡´çš„æ€§èƒ½é—®é¢˜
    const maxIterations = map.width * map.height * 1.5;
    let iterations = 0;

    while (openList.length > 0 && iterations < maxIterations) {
        iterations++;
        
        // ä» openList ä¸­æ‰¾åˆ° f å€¼æœ€å°çš„èŠ‚ç‚¹
        let currentNode = openList[0];
        let currentIndex = 0;
        for (let i = 1; i < openList.length; i++) {
            if (openList[i].f < currentNode.f) {
                currentNode = openList[i];
                currentIndex = i;
            }
        }

        // å°†å½“å‰èŠ‚ç‚¹ä» openList ç§»åˆ° closedList
        openList.splice(currentIndex, 1);
        closedList.push(currentNode);

        // å¦‚æœåˆ°è¾¾ç»ˆç‚¹ï¼Œåˆ™å›æº¯è·¯å¾„å¹¶è¿”å›
        if (currentNode.equals(endNode)) {
            let path = [];
            let current = currentNode;
            while (current !== null) {
                path.push(current.position);
                current = current.parent;
            }
            return path.reverse();
        }

        // æ£€æŸ¥æ‰€æœ‰ç›¸é‚»çš„æ ¼å­
        const adjacentSquares = [
            { x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 },
            { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 }
        ];

        for (const newPosition of adjacentSquares) {
            const nodePosition = {
                x: currentNode.position.x + newPosition.x,
                y: currentNode.position.y + newPosition.y,
            };

            const tile = map.getTile(nodePosition.x, nodePosition.y);
            // å¦‚æœé‚»å±…èŠ‚ç‚¹ä¸å¯é€šè¡Œï¼Œåˆ™è·³è¿‡
            if (!tile || !TERRAIN_TYPES[tile.type].traversableBy.includes(moveType)) {
                continue;
            }
            
            const childNode = new Node(currentNode, nodePosition);
            
            // å¦‚æœé‚»å±…èŠ‚ç‚¹å·²åœ¨ closedList ä¸­ï¼Œåˆ™è·³è¿‡
            if (closedList.find(node => node.equals(childNode))) {
                 continue;
            }

            // è®¡ç®— g, h, f å€¼
            const moveCost = (newPosition.x !== 0 && newPosition.y !== 0) ? 1.414 : 1; // å¯¹è§’çº¿ç§»åŠ¨ä»£ä»·æ›´é«˜
            childNode.g = currentNode.g + moveCost;
            childNode.h = Math.sqrt(((childNode.position.x - endNode.position.x) ** 2) + ((childNode.position.y - endNode.position.y) ** 2));
            childNode.f = childNode.g + childNode.h;

            // å¦‚æœé‚»å±…èŠ‚ç‚¹å·²åœ¨ openList ä¸­ï¼Œä¸”æ–°çš„è·¯å¾„ä»£ä»·æ›´é«˜ï¼Œåˆ™è·³è¿‡
            const existingNode = openList.find(node => node.equals(childNode));
            if (existingNode && childNode.g >= existingNode.g) {
                continue;
            }
            
            // æ›´æ–°æˆ–æ·»åŠ èŠ‚ç‚¹åˆ° openList
            if (existingNode) {
                existingNode.parent = currentNode;
                existingNode.g = childNode.g;
                existingNode.f = childNode.f;
            } else {
                openList.push(childNode);
            }
        }
    }

    return null; // æ‰¾ä¸åˆ°è·¯å¾„
}


/**
 * æ£€æŸ¥ä¸¤ç‚¹ä¹‹é—´æ˜¯å¦æœ‰åœ°å½¢éšœç¢ï¼Œç”¨äºè·¯å¾„å¹³æ»‘å¤„ç†ï¼ˆæ‹‰ç›´è·¯å¾„ï¼‰ã€‚
 * @param {{x: number, y: number}} startPos - èµ·ç‚¹åƒç´ åæ ‡ã€‚
 * @param {{x: number, y: number}} endPos - ç»ˆç‚¹åƒç´ åæ ‡ã€‚
 * @param {GameMap} map - æ¸¸æˆåœ°å›¾å¯¹è±¡ã€‚
 * @param {string} moveType - ç§»åŠ¨å•ä½çš„ç±»å‹ã€‚
 * @returns {boolean} - å¦‚æœæ²¡æœ‰éšœç¢åˆ™è¿”å›trueã€‚
 */
export function isLineOfSightClear(startPos, endPos, map, moveType) {
    // ç©ºä¸­å•ä½æ°¸è¿œè§†é‡æ¸…æ™°ï¼Œæ— è§†åœ°å½¢éšœç¢
    if (moveType === 'air') {
        return true;
    }

    const dx = endPos.x - startPos.x;
    const dy = endPos.y - startPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const step = TILE_SIZE / 2; // æ£€æŸ¥æ­¥é•¿ï¼ŒåŠä¸ªæ ¼å­å¤§å°
    const steps = Math.ceil(distance / step);

    // æ²¿ç›´çº¿æ­¥è¿›æ£€æŸ¥æ¯ä¸ªç‚¹æ‰€åœ¨çš„åœ°å½¢æ˜¯å¦å¯é€šè¡Œ
    for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const checkX = startPos.x + dx * t;
        const checkY = startPos.y + dy * t;

        const gridX = Math.floor(checkX / TILE_SIZE);
        const gridY = Math.floor(checkY / TILE_SIZE);

        const tile = map.getTile(gridX, gridY);
        if (!tile || !TERRAIN_TYPES[tile.type].traversableBy.includes(moveType)) {
            return false; // é‡åˆ°éšœç¢
        }
    }
    
    return true; // è·¯å¾„æ¸…æ™°
}
```

---

### `player.js`
```javascript
// js/player.js

import { AIController } from './ai.js';

/**
 * @class Player
 * @description ä»£è¡¨ä¸€ä¸ªç©å®¶ï¼Œå¯ä»¥æ˜¯äººç±»æˆ–AIã€‚
 */
export class Player {
    /**
     * @param {string} id - ç©å®¶ID ('player' or 'ai')ã€‚
     * @param {string} name - ç©å®¶åç§°ã€‚
     * @param {number} manpower - åˆå§‹èµ„æºã€‚
     * @param {boolean} [isAI=false] - æ˜¯å¦ä¸ºAIç©å®¶ã€‚
     * @param {object} [baseArea] - åŸºåœ°èŒƒå›´ (æœªä½¿ç”¨)ã€‚
     * @param {string} [aiDifficulty='medium'] - AIéš¾åº¦ã€‚
     */
    constructor(id, name, manpower, isAI = false, baseArea, aiDifficulty = 'medium') {
        this.id = id;
        this.name = name;
        this.manpower = manpower;
        this.isAI = isAI;
        this.units = [];
        this.baseArea = baseArea; 
        this.baseCaptureTimer = 0; // for capture mechanics (not implemented)

        if (isAI) {
            this.aiController = new AIController(this, aiDifficulty);
        }
    }

    /**
     * æ›´æ–°ç©å®¶é€»è¾‘ï¼Œä¸»è¦ç”¨äºé©±åŠ¨AIã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @param {Player} enemyPlayer - æ•Œæ–¹ç©å®¶å¯¹è±¡ã€‚
     * @param {GameMap} map - æ¸¸æˆåœ°å›¾ã€‚
     * @param {SpatialGrid} spatialGrid - ç©ºé—´ç½‘æ ¼ï¼Œä¼ é€’ç»™AIæ§åˆ¶å™¨ç”¨äºç´¢æ•Œã€‚
     */
    update(deltaTime, enemyPlayer, map, spatialGrid) {
        if (this.isAI) {
            this.aiController.update(this.units, enemyPlayer.units, map, deltaTime, spatialGrid);
        }
    }
    
    /**
     * æ£€æŸ¥èµ„æºæ˜¯å¦è¶³å¤Ÿã€‚
     * @param {number} unitCost - å•ä½èŠ±è´¹ã€‚
     * @returns {boolean}
     */
    canAfford(unitCost) {
        return this.manpower >= unitCost;
    }
    
    /**
     * æ‰£é™¤èµ„æºã€‚
     * @param {number} amount - æ‰£é™¤æ•°é‡ã€‚
     */
    deductManpower(amount) {
        this.manpower -= amount;
    }
}
```

---

### `projectile.js`
```javascript
// js/projectile.js

import { getDistance } from './utils.js';

let nextProjectileId = 0;

/**
 * @class Projectile
 * @description ä»£è¡¨ä¸€ä¸ªé£è¡Œä¸­çš„å¼¹é“ç‰©ä½“ï¼Œå¦‚å­å¼¹ã€ç‚®å¼¹æˆ–å¯¼å¼¹ã€‚
 */
export class Projectile {
    /**
     * @param {string} owner - å‘å°„è€…çš„owner ID ('player' or 'ai')ã€‚
     * @param {{x: number, y: number}} startPos - å‘å°„ä½ç½®ã€‚
     * @param {Unit|Base} target - ç›®æ ‡å¯¹è±¡ã€‚
     * @param {object} stats - å¼¹é“å±æ€§ (ä¼¤å®³, é€Ÿåº¦, ç±»å‹ç­‰)ã€‚
     */
    constructor(owner, startPos, target, stats) {
        this.id = nextProjectileId++;
        this.owner = owner;
        this.x = startPos.x;
        this.y = startPos.y;
        this.target = target;
        this.stats = stats;

        const targetPos = { x: target.pixelX || target.x, y: target.pixelY || target.y };
        const angle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
        this.vx = Math.cos(angle) * this.stats.ammoSpeed;
        this.vy = Math.sin(angle) * this.stats.ammoSpeed;
        
        this.trail = []; // ç”¨äºæ‹–å°¾æ•ˆæœçš„ç²’å­æ•°ç»„
        this.life = 0; // å¼¹é“çš„ç”Ÿå‘½å‘¨æœŸè®¡æ—¶
    }

    /**
     * æ›´æ–°å¼¹é“ä½ç½®å’ŒçŠ¶æ€ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @returns {boolean} - å¦‚æœå¼¹é“åº”è¯¥è¢«é”€æ¯ï¼ˆå‘½ä¸­æˆ–è¶…æ—¶ï¼‰ï¼Œåˆ™è¿”å›trueã€‚
     */
    update(deltaTime) {
        const targetPos = this.target ? { x: this.target.pixelX || this.target.x, y: this.target.pixelY || this.target.y } : {x: this.x + this.vx, y: this.y + this.vy};

        // å¯¼å¼¹çš„ç®€å•è¿½è¸ªé€»è¾‘
        if (this.stats.ammoType === 'missile' && this.target && this.target.hp > 0) {
            const angle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
            const targetVx = Math.cos(angle) * this.stats.ammoSpeed;
            const targetVy = Math.sin(angle) * this.stats.ammoSpeed;
            // ä½¿ç”¨çº¿æ€§æ’å€¼ä½¿å¯¼å¼¹è½¬å‘æ›´å¹³æ»‘
            this.vx = this.vx * 0.98 + targetVx * 0.02;
            this.vy = this.vy * 0.98 + targetVy * 0.02;
        }

        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        this.life += deltaTime;

        // æ›´æ–°æ‹–å°¾æ•ˆæœ
        this.updateTrail(deltaTime);

        const dist = getDistance(this, targetPos);
        // å‘½ä¸­åˆ¤å®šï¼ˆè·ç¦»è¶³å¤Ÿè¿‘ï¼‰æˆ–è¶…æ—¶ï¼ˆé£è¡Œæ—¶é—´è¿‡é•¿ï¼‰
        return dist < 10 || this.life > 5;
    }
    
    /**
     * æ›´æ–°æ‹–å°¾ç²’å­æ•ˆæœã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    updateTrail(deltaTime) {
        if (this.stats.ammoType === 'missile' || this.stats.ammoType === 'shell') {
            // æ¯éš”ä¸€å°æ®µè·ç¦»æ·»åŠ ä¸€ä¸ªæ–°çš„æ‹–å°¾ç²’å­
            if (this.trail.length === 0 || getDistance(this.trail[this.trail.length-1], this) > 5) {
                this.trail.push({ x: this.x, y: this.y, life: 1.0 });
            }
        }
        
        // æ›´æ–°å¹¶ç§»é™¤ç”Ÿå‘½å‘¨æœŸç»“æŸçš„æ‹–å°¾ç²’å­
        for (let i = this.trail.length - 1; i >= 0; i--) {
            this.trail[i].life -= deltaTime * 2.5;
            if (this.trail[i].life <= 0) {
                this.trail.splice(i, 1);
            }
        }
    }

    /**
     * ç»˜åˆ¶å¼¹é“å’Œå…¶æ‹–å°¾ã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     */
    draw(ctx) {
        // ç»˜åˆ¶æ‹–å°¾ï¼ˆçƒŸé›¾ï¼‰
        if (this.stats.ammoType === 'missile' || this.stats.ammoType === 'shell') {
             ctx.fillStyle = `rgba(180, 180, 180, 0.4)`;
             this.trail.forEach(p => {
                ctx.beginPath();
                // ç²’å­å¤§å°éšç”Ÿå‘½å‘¨æœŸå‡å°
                const radius = p.life * (this.stats.ammoType === 'missile' ? 4 : 2.5);
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ç»˜åˆ¶å¼¹å¤´
        switch (this.stats.ammoType) {
            case 'missile':
                ctx.fillStyle = `rgba(255, 200, 100, 1)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                break;
            case 'bullet':
                 ctx.fillStyle = 'yellow';
                 ctx.fillRect(this.x - 1, this.y - 1, 3, 3);
                 break;
            case 'shell':
                 ctx.fillStyle = '#ddd';
                 ctx.beginPath();
                 ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                 ctx.fill();
                 break;
        }
    }
}


/**
 * @class Explosion
 * @description ç®¡ç†ä¸€ä¸ªçˆ†ç‚¸çš„è§†è§‰æ•ˆæœï¼ŒåŒ…æ‹¬ç«å…‰å’ŒçƒŸé›¾ç²’å­ã€‚
 */
export class Explosion {
    /**
     * @param {number} x - çˆ†ç‚¸ä¸­å¿ƒXåæ ‡ã€‚
     * @param {number} y - çˆ†ç‚¸ä¸­å¿ƒYåæ ‡ã€‚
     * @param {number} radius - çˆ†ç‚¸çš„æœ€å¤§åŠå¾„ã€‚
     */
    constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius < 10 ? 10 : radius; // æœ€å°çˆ†ç‚¸åŠå¾„
        this.maxLife = 0.6; // çˆ†ç‚¸æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
        this.life = this.maxLife;
        
        // åˆ›å»ºçƒŸé›¾ç²’å­
        this.particles = [];
        const particleCount = 15 + Math.floor(this.radius / 5);
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * this.radius * 0.5;
            this.particles.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                size: Math.random() * 5 + 2,
                alpha: Math.random() * 0.3 + 0.1,
            });
        }
    }

    /**
     * æ›´æ–°çˆ†ç‚¸æ•ˆæœçš„ç”Ÿå‘½å‘¨æœŸå’Œç²’å­çŠ¶æ€ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @returns {boolean} - å¦‚æœçˆ†ç‚¸æ•ˆæœåº”è¯¥è¢«é”€æ¯ï¼Œåˆ™è¿”å›trueã€‚
     */
    update(deltaTime) {
        this.life -= deltaTime;
        
        // æ›´æ–°æ¯ä¸ªçƒŸé›¾ç²’å­çš„çŠ¶æ€
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.life -= deltaTime * 0.8;
             if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
        
        return this.life <= 0 && this.particles.length === 0;
    }

    /**
     * ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     */
    draw(ctx) {
        const progress = 1 - (this.life / this.maxLife);
        
        // ç»˜åˆ¶çƒŸé›¾ç²’å­
        this.particles.forEach(p => {
            ctx.fillStyle = `rgba(80, 80, 80, ${p.alpha * p.life})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (1 + progress), 0, Math.PI * 2);
            ctx.fill();
        });

        // ç»˜åˆ¶ç«å…‰ (å¤šå±‚å åŠ ï¼Œå®ç°ä½“ç§¯æ„Ÿ)
        if (this.life > 0) {
            // ä½¿ç”¨sinå‡½æ•°å®ç°å¹³æ»‘çš„æ·¡å…¥æ·¡å‡ºæ•ˆæœ
            const alpha = Math.sin(Math.PI * progress);
            
            // 1. å¤–å±‚æ©™çº¢è‰²ç«ç„°
            let currentRadius = this.radius * progress;
            ctx.fillStyle = `rgba(255, 120, 0, ${alpha * 0.7})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // 2. ä¸­å±‚é»„è‰²ç«ç„°
            currentRadius *= 0.7;
            ctx.fillStyle = `rgba(255, 220, 100, ${alpha * 0.9})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();

            // 3. æ ¸å¿ƒç™½çƒ­åŒ–ç«ç„°
            currentRadius *= 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}
```

---

### `spatial-grid.js`
```javascript
// js/spatial-grid.js

/**
 * @file ç©ºé—´ç½‘æ ¼æ•°æ®ç»“æ„ï¼Œç”¨äºRTSæ¸¸æˆä¸­çš„æ ¸å¿ƒæ€§èƒ½ä¼˜åŒ–ã€‚
 * å®ƒå°†æ¸¸æˆä¸–ç•Œåˆ’åˆ†ä¸ºä¸€ä¸ªç½‘æ ¼ï¼Œæ¯ä¸ªå•ä½è¢«æ”¾ç½®åœ¨å¯¹åº”çš„æ ¼å­é‡Œã€‚
 * å½“éœ€è¦æŸ¥è¯¢ä¸€ä¸ªå•ä½é™„è¿‘çš„å…¶å®ƒå•ä½æ—¶ï¼Œåªéœ€æ£€æŸ¥å…¶æ‰€åœ¨æ ¼å­åŠå‘¨å›´çš„æ ¼å­å³å¯ï¼Œ
 * é¿å…äº†å…¨å±€éå†æ‰€æœ‰å•ä½ï¼Œä»è€Œå°†ç¢°æ’æ£€æµ‹ã€ç´¢æ•Œç­‰æ“ä½œçš„å¤æ‚åº¦ä» O(n^2) é™ä½åˆ°æ¥è¿‘ O(n)ã€‚
 */

/**
 * @class SpatialGrid
 */
export class SpatialGrid {
    /**
     * @param {number} mapWidth - åœ°å›¾çš„æ€»åƒç´ å®½åº¦ã€‚
     * @param {number} mapHeight - åœ°å›¾çš„æ€»åƒç´ é«˜åº¦ã€‚
     * @param {number} cellSize - æ¯ä¸ªç©ºé—´æ ¼å­çš„åƒç´ å°ºå¯¸ã€‚è¿™ä¸ªå€¼é€šå¸¸åº”å¤§äºæˆ–ç­‰äºæœ€å¤§å•ä½çš„äº¤äº’åŠå¾„ï¼ˆå¦‚è§†é‡ã€å°„ç¨‹ï¼‰ã€‚
     */
    constructor(mapWidth, mapHeight, cellSize) {
        this.cellSize = cellSize;
        this.gridWidth = Math.ceil(mapWidth / cellSize);
        this.gridHeight = Math.ceil(mapHeight / cellSize);
        // ä½¿ç”¨Mapæ¥å­˜å‚¨æ ¼å­ï¼Œkeyæ˜¯ "x,y" æ ¼å¼çš„å­—ç¬¦ä¸²ï¼Œvalueæ˜¯è¯¥æ ¼å­å†…çš„å•ä½æ•°ç»„ã€‚
        // Mapæ¯”æ™®é€šå¯¹è±¡åœ¨é¢‘ç¹å¢åˆ é”®æ—¶æ€§èƒ½æ›´å¥½ã€‚
        this.grid = new Map(); 
    }

    /**
     * å°†ç½‘æ ¼åæ ‡è½¬æ¢ä¸ºå”¯ä¸€çš„å­—ç¬¦ä¸²é”®ã€‚
     * @private
     * @param {number} gridX - ç½‘æ ¼çš„Xåæ ‡ã€‚
     * @param {number} gridY - ç½‘æ ¼çš„Yåæ ‡ã€‚
     * @returns {string} - "x,y" æ ¼å¼çš„é”®ã€‚
     */
    _getKey(gridX, gridY) {
        return `${gridX},${gridY}`;
    }

    /**
     * æ¸…ç©ºæ‰€æœ‰æ ¼å­ã€‚æ­¤æ–¹æ³•åº”åœ¨æ¯å¸§æ›´æ–°å¼€å§‹æ—¶è°ƒç”¨ã€‚
     */
    clear() {
        this.grid.clear();
    }

    /**
     * å°†ä¸€ä¸ªå•ä½æ’å…¥åˆ°å…¶å½“å‰ä½ç½®å¯¹åº”çš„æ ¼å­ä¸­ã€‚
     * @param {Unit} unit - è¦æ’å…¥çš„å•ä½ã€‚
     */
    insert(unit) {
        const gridX = Math.floor(unit.x / this.cellSize);
        const gridY = Math.floor(unit.y / this.cellSize);
        const key = this._getKey(gridX, gridY);

        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(unit);
    }

    /**
     * è·å–ä¸€ä¸ªå•ä½é™„è¿‘ï¼ˆå…¶è‡ªèº«æ ¼å­ + å‘¨å›´8ä¸ªæ ¼å­ï¼‰çš„æ‰€æœ‰å•ä½ã€‚
     * è¿™æ˜¯æœ€å¸¸ç”¨çš„æŸ¥è¯¢æ–¹æ³•ï¼Œç”¨äºç¢°æ’æ£€æµ‹ç­‰ã€‚
     * @param {Unit} unit - è¦æŸ¥è¯¢çš„ä¸­å¿ƒå•ä½ã€‚
     * @returns {Array<Unit>} - é™„è¿‘å•ä½çš„æ•°ç»„ã€‚
     */
    getNearby(unit) {
        const nearbyUnits = [];
        const centralGridX = Math.floor(unit.x / this.cellSize);
        const centralGridY = Math.floor(unit.y / this.cellSize);

        // éå†ä¸­å¿ƒæ ¼å­åŠå…¶å‘¨å›´çš„8ä¸ªæ ¼å­ (3x3åŒºåŸŸ)
        for (let y = -1; y <= 1; y++) {
            for (let x = -1; x <= 1; x++) {
                const checkGridX = centralGridX + x;
                const checkGridY = centralGridY + y;
                const key = this._getKey(checkGridX, checkGridY);

                if (this.grid.has(key)) {
                    nearbyUnits.push(...this.grid.get(key));
                }
            }
        }
        return nearbyUnits;
    }
    
    /**
     * è·å–ä¸€ä¸ªç‚¹å‘¨å›´æŒ‡å®šåŠå¾„å†…çš„æ‰€æœ‰å•ä½ã€‚
     * è¿™ä¸ªæ–¹æ³•æ¯” getNearby æ›´ç²¾ç¡®ï¼Œä½†å¯èƒ½éœ€è¦æ£€æŸ¥æ›´å¤šçš„æ ¼å­ã€‚
     * @param {{x: number, y: number}} position - æŸ¥è¯¢çš„ä¸­å¿ƒç‚¹ã€‚
     * @param {number} radius - æŸ¥è¯¢åŠå¾„ã€‚
     * @returns {Array<Unit>} - åŠå¾„èŒƒå›´å†…çš„å•ä½æ•°ç»„ã€‚
     */
    getNearbyWithRadius(position, radius) {
        const nearbyUnits = new Set(); // ä½¿ç”¨Seté¿å…é‡å¤æ·»åŠ å•ä½
        const minGridX = Math.floor((position.x - radius) / this.cellSize);
        const maxGridX = Math.floor((position.x + radius) / this.cellSize);
        const minGridY = Math.floor((position.y - radius) / this.cellSize);
        const maxGridY = Math.floor((position.y + radius) / this.cellSize);

        for (let y = minGridY; y <= maxGridY; y++) {
            for (let x = minGridX; x <= maxGridX; x++) {
                const key = this._getKey(x, y);
                 if (this.grid.has(key)) {
                    this.grid.get(key).forEach(unit => nearbyUnits.add(unit));
                }
            }
        }
        return Array.from(nearbyUnits);
    }
}
```

---

### `ui.js`
```javascript
// js/ui.js

import { UNIT_TYPES, TERRAIN_TYPES, TILE_SIZE } from './config.js';

/**
 * @class UI
 * @description ç®¡ç†æ¸¸æˆçš„ç”¨æˆ·ç•Œé¢ï¼ŒåŒ…æ‹¬å•ä½é€‰æ‹©ã€ä¿¡æ¯æ˜¾ç¤ºå’Œç©å®¶äº¤äº’ã€‚
 */
export class UI {
    /**
     * @param {Game} game - æ¸¸æˆä¸»å¯¹è±¡çš„å¼•ç”¨ã€‚
     */
    constructor(game) {
        this.game = game;
        
        // DOMå…ƒç´ å¼•ç”¨
        this.unitListContainer = document.getElementById('unit-selection');
        this.playerManpower = document.getElementById('player-manpower');
        this.gameStatus = document.getElementById('game-status');
        this.startBattleBtn = document.getElementById('start-battle-btn');
        this.selectedUnitInfo = document.getElementById('selected-unit-info');
        
        this.selectedUnitToDeploy = null; // å½“å‰åœ¨éƒ¨ç½²åˆ—è¡¨ä¸­é€‰ä¸­çš„å•ä½ç±»å‹
        this.messageTimeout = null; // æ¸¸æˆæ¶ˆæ¯çš„è®¡æ—¶å™¨

        this.init();
    }

    /**
     * åˆå§‹åŒ–UIï¼Œå¡«å……å•ä½åˆ—è¡¨å¹¶ç»‘å®šäº‹ä»¶ã€‚
     */
    init() {
        this.populateUnitList();
        
        if (this.startBattleBtn) {
            this.startBattleBtn.addEventListener('click', () => this.game.startGame());
        }
    }

    /**
     * æ ¹æ®config.jsä¸­çš„å•ä½å®šä¹‰ï¼ŒåŠ¨æ€ç”Ÿæˆå¯éƒ¨ç½²å•ä½çš„åˆ—è¡¨ã€‚
     */
    populateUnitList() {
        if (!this.unitListContainer) return;
        
        this.unitListContainer.innerHTML = `
            <h3>å¯éƒ¨ç½²å…µç§</h3>
            <div id="unit-list-wrapper"></div>
        `;
        const listWrapper = this.unitListContainer.querySelector('#unit-list-wrapper');

        // æŒ‰å•ä½ç±»åˆ«è¿›è¡Œåˆ†ç»„
        const groupedUnits = {};
        for (const type in UNIT_TYPES) {
            const unit = UNIT_TYPES[type];
            if (!groupedUnits[unit.unitClass]) {
                groupedUnits[unit.unitClass] = [];
            }
            groupedUnits[unit.unitClass].push({ id: type, ...unit });
        }

        // æŒ‰é¢„è®¾é¡ºåºæ¸²æŸ“ç±»åˆ«
        const categoryOrder = ['æ­¥å…µ', 'è£…ç”²', 'é£è¡Œ', 'ç‚®å…µ', 'æµ·å†›'];
        for (const category of categoryOrder) {
            if (!groupedUnits[category]) continue;

            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'unit-category';
            categoryDiv.innerHTML = `<h4>${category}</h4>`;
            
            const ul = document.createElement('ul');
            ul.className = 'unit-list';

            groupedUnits[category].forEach(unit => {
                const li = document.createElement('li');
                li.dataset.unitType = unit.id;
                li.title = unit.description;

                li.innerHTML = `
                    <div class="unit-icon">${unit.icon}</div>
                    <div class="unit-details">
                        <strong>${unit.name}</strong>
                        <div class="unit-stats">è´¹ç”¨: ${unit.cost} | HP: ${unit.hp} | æ”»å‡»: ${unit.attack}</div>
                    </div>
                `;
                
                li.addEventListener('click', () => {
                    const wasSelected = li.classList.contains('selected');
                    this.clearAllSelectionsInList();
                    
                    if (!wasSelected) {
                        li.classList.add('selected');
                        this.selectedUnitToDeploy = unit.id;
                        // äº¤äº’ä¼˜åŒ–: é€‰æ‹©éƒ¨ç½²å•ä½æ—¶ï¼Œè‡ªåŠ¨å–æ¶ˆåœ°å›¾ä¸Šå·²é€‰ä¸­çš„å•ä½
                        this.game.selectedUnits = [];
                    } else {
                        this.selectedUnitToDeploy = null;
                    }
                });
                ul.appendChild(li);
            });

            categoryDiv.appendChild(ul);
            listWrapper.appendChild(categoryDiv);
        }
    }

    /**
     * æ¸…é™¤éƒ¨ç½²åˆ—è¡¨ä¸­æ‰€æœ‰å•ä½çš„é€‰ä¸­çŠ¶æ€ã€‚
     */
    clearAllSelectionsInList() {
        if (!this.unitListContainer) return;
        this.unitListContainer.querySelectorAll('li.selected').forEach(item => item.classList.remove('selected'));
    }

    /**
     * æ¸…é™¤å¾…éƒ¨ç½²å•ä½çš„é€‰æ‹©çŠ¶æ€ã€‚é€šå¸¸ç”±Gameç±»åœ¨å…¶ä»–æ“ä½œï¼ˆå¦‚æ¡†é€‰ï¼‰åè°ƒç”¨ã€‚
     */
    clearDeploymentSelection() {
        if (this.selectedUnitToDeploy) {
            this.selectedUnitToDeploy = null;
            this.clearAllSelectionsInList();
        }
    }

    /**
     * æ¯å¸§æ›´æ–°UIæ˜¾ç¤ºï¼Œå¦‚èµ„æºã€æ¸¸æˆçŠ¶æ€å’ŒåŸºåœ°è¡€é‡ã€‚
     */
    update() {
        if (this.playerManpower) this.playerManpower.textContent = this.game.player.manpower;
        if (this.gameStatus) this.gameStatus.textContent = `çŠ¶æ€: ${this.game.gameState}`;
        if (this.startBattleBtn) this.startBattleBtn.disabled = this.game.gameState !== 'deployment';
        
        // æ›´æ–°åŸºåœ°è¡€æ¡
        this.updateBaseHP('player');
        this.updateBaseHP('ai');

        // æ›´æ–°é€‰ä¸­å•ä½çš„ä¿¡æ¯é¢æ¿
        this.updateSelectedUnitInfo();
    }
    
    /**
     * æ›´æ–°æŒ‡å®šç©å®¶çš„åŸºåœ°HPæ¡ã€‚
     * @param {string} owner - 'player' or 'ai'.
     */
    updateBaseHP(owner) {
        const base = this.game[`${owner}Base`];
        const displayDiv = document.getElementById(`${owner}-base-hp-display`);
        if (!displayDiv) return;

        if (base) {
            displayDiv.style.display = 'block';
            const hpBar = document.getElementById(`${owner}-base-hp-bar`);
            if(hpBar) {
                const percentage = (base.hp / base.maxHp) * 100;
                hpBar.style.width = `${percentage}%`;
            }
        } else {
            displayDiv.style.display = 'none';
        }
    }

    /**
     * æ›´æ–°æ˜¾ç¤ºåœ¨UIå³ä¸‹è§’çš„é€‰ä¸­å•ä½ä¿¡æ¯ã€‚
     */
    updateSelectedUnitInfo() {
        if (!this.selectedUnitInfo) return;
        
        const selectedCount = this.game.selectedUnits.length;

        if (selectedCount === 1) {
            // æ˜¾ç¤ºå•ä¸ªå•ä½çš„è¯¦ç»†ä¿¡æ¯
            const unit = this.game.selectedUnits[0]; 
            const stats = unit.stats;
            
            let statusText = 'å¾…å‘½';
            if (unit.target) statusText = 'æ”»å‡»ä¸­';
            else if (unit.path && unit.path.length > 0) statusText = 'ç§»åŠ¨ä¸­';
            else if (unit.isLoitering) statusText = 'å·¡é€»ä¸­';
            else if (unit.isSettingUp) statusText = 'éƒ¨ç½²ä¸­';

            this.selectedUnitInfo.innerHTML = `
                <h4>${stats.name}</h4>
                <p>HP: ${unit.hp.toFixed(0)} / ${stats.hp}</p>
                <div class="hp-bar-container small">
                   <div class="hp-bar" style="width: ${(unit.hp / stats.hp) * 100}%; background-color: green;"></div>
                </div>
                <p>æ”»å‡»: ${stats.attack} | é˜²å¾¡: ${stats.defense}</p>
                <p>å°„ç¨‹: ${stats.range / TILE_SIZE}æ ¼ | çŠ¶æ€: ${statusText}</p> 
            `;
        } else if (selectedCount > 1) {
            // æ˜¾ç¤ºå¤šä¸ªå•ä½çš„æ¦‚è¦ä¿¡æ¯
            this.selectedUnitInfo.innerHTML = `
                <h4>é€‰ä¸­å¤šä¸ªå•ä½</h4>
                <p>${selectedCount} ä¸ªå•ä½è¢«é€‰ä¸­ã€‚</p>
            `;
        } else {
            // æ²¡æœ‰å•ä½è¢«é€‰ä¸­
            this.selectedUnitInfo.innerHTML = '<h4>é€‰ä¸­å•ä½ä¿¡æ¯</h4><p>æ— </p>';
        }
    }
    
    /**
     * åœ¨æ¸¸æˆç»“æŸæ—¶æ˜¾ç¤ºèƒœåˆ©è€…ä¿¡æ¯ã€‚
     * @param {string} winnerName - èƒœåˆ©è€…çš„åå­—ã€‚
     */
    showWinner(winnerName) {
        const winnerDiv = document.createElement('div');
        winnerDiv.className = 'winner-announcement';
        winnerDiv.textContent = `${winnerName} è·èƒœ!`;
        document.body.appendChild(winnerDiv);
    }

    /**
     * åœ¨å±å¹•ä¸Šæ˜¾ç¤ºä¸€æ¡ä¸´æ—¶æ¸¸æˆæ¶ˆæ¯ (å¦‚ "èµ„æºä¸è¶³")ã€‚
     * @param {string} message - è¦æ˜¾ç¤ºçš„æ¶ˆæ¯æ–‡æœ¬ã€‚
     */
    showGameMessage(message) {
        let messageDiv = document.getElementById('game-message');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.id = 'game-message';
            document.body.appendChild(messageDiv);
        }
        
        messageDiv.textContent = message;
        messageDiv.classList.add('show');

        if (this.messageTimeout) clearTimeout(this.messageTimeout);
        
        this.messageTimeout = setTimeout(() => {
            messageDiv.classList.remove('show');
        }, 3000);
    }
}
```

---

### `unit.js`
```javascript
// js/unit.js

import { TILE_SIZE, UNIT_TYPES } from './config.js';
import { getDistance } from './utils.js';
import { Base } from './base.js';
import { Projectile } from './projectile.js';
import { findPath, isLineOfSightClear } from './pathfinding.js';

let nextUnitId = 0;

/**
 * @class Unit
 * @description æ¸¸æˆä¸­çš„åŸºç¡€ä½œæˆ˜å•ä½ç±»ã€‚
 */
export class Unit {
    /**
     * @param {string} type - å•ä½ç±»å‹ID, å¯¹åº” config.js ä¸­çš„é”®ã€‚
     * @param {string} owner - æ‰€æœ‰è€… ('player' or 'ai')ã€‚
     * @param {number} x - åˆå§‹åƒç´ Xåæ ‡ã€‚
     * @param {number} y - åˆå§‹åƒç´ Yåæ ‡ã€‚
     */
    constructor(type, owner, x, y) {
        this.id = nextUnitId++;
        this.type = type;
        this.owner = owner;
        this.stats = { ...UNIT_TYPES[type] }; // å¤åˆ¶å•ä½å±æ€§ï¼Œé˜²æ­¢ä¿®æ”¹å…¨å±€é…ç½®
        this.image = window.assetManager[this.stats.imageSrc];

        // ä½ç½®å’ŒçŠ¶æ€
        this.x = x;
        this.y = y;
        this.hp = this.stats.hp;
        this.angle = Math.random() * Math.PI * 2; // å½“å‰æœå‘
        this.targetAngle = this.angle; // ç›®æ ‡æœå‘
        this.rotationSpeed = Math.PI * 2.0; // æ¯ç§’æ—‹è½¬é€Ÿåº¦
        
        // æˆ˜æ–—ç›¸å…³
        this.target = null;
        this.attackCooldown = 0;
        this.findTargetCooldown = Math.random() * 0.5; // é”™å¼€AIå•ä½çš„ç´¢æ•Œè®¡ç®—ï¼Œé¿å…åŒæ—¶è®¡ç®—é€ æˆå¡é¡¿

        // ç§»åŠ¨ç›¸å…³
        this.path = [];
        this.currentPathIndex = 0;
        this.moveTargetPos = null; // å½“å‰å¹³æ»‘è·¯å¾„çš„ç›®æ ‡ç‚¹
        
        // ç‰¹æ®Šè¡Œä¸ºçŠ¶æ€
        this.isLoitering = false; // æ˜¯å¦åœ¨å·¡é€»ï¼ˆä¸»è¦ç”¨äºé£æœºï¼‰
        this.loiterCenter = null;
        this.loiterRadius = TILE_SIZE * 5;
        this.loiterAngle = 0;
        this.strafeDirection = Math.random() < 0.5 ? 1 : -1; // é£æœºç»•åœˆæ–¹å‘
        
        this.isSettingUp = false; // æ˜¯å¦åœ¨éƒ¨ç½²ï¼ˆç‚®å…µï¼‰
        this.setupTimer = 0;
    }

    /**
     * å•ä½çš„ä¸»æ›´æ–°é€»è¾‘ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @param {Array<Unit>} enemyUnits - æ•Œæ–¹å•ä½æ•°ç»„ (å·²åºŸå¼ƒï¼Œæ”¹ç”¨spatialGrid)ã€‚
     * @param {GameMap} map - åœ°å›¾å¯¹è±¡ã€‚
     * @param {Base} enemyBase - æ•Œæ–¹åŸºåœ°ã€‚
     * @param {Game} game - æ¸¸æˆä¸»å¯¹è±¡ã€‚
     * @param {SpatialGrid} spatialGrid - ç”¨äºé«˜æ•ˆç´¢æ•Œçš„ç©ºé—´ç½‘æ ¼ã€‚
     */
    update(deltaTime, enemyUnits, map, enemyBase, game, spatialGrid) {
        if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;
        if (this.findTargetCooldown > 0) this.findTargetCooldown -= deltaTime;
        
        this.updateRotation(deltaTime);

        // ç‚®å…µç­‰å•ä½éƒ¨ç½²ä¸­ä¸èƒ½åšä»»ä½•äº‹
        if (this.isSettingUp) {
            this.setupTimer -= deltaTime;
            if (this.setupTimer <= 0) this.isSettingUp = false;
            return;
        }
        
        // æ ¸å¿ƒé€»è¾‘ï¼šæ”»å‡»æˆ–ç§»åŠ¨
        if (this.target && this.target.hp > 0) {
            this.handleAttack(this.target, game);
        } else {
            this.target = null;
            this.handleMovement(deltaTime, map);
        }

        // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ç©ºé—´ç½‘æ ¼è¿›è¡ŒèŠ‚æµç´¢æ•Œ
        // åªæœ‰å½“å•ä½ç©ºé—²ä¸”ç´¢æ•Œå†·å´ç»“æŸæ—¶æ‰æ‰§è¡Œ
        if (!this.target && this.path.length === 0 && !this.moveTargetPos && this.findTargetCooldown <= 0) {
            this.findTarget(enemyBase, spatialGrid);
            this.findTargetCooldown = 0.5 + Math.random() * 0.2; // æ— è®ºæ˜¯å¦æ‰¾åˆ°éƒ½é‡ç½®è®¡æ—¶å™¨
            
            // å¦‚æœæ²¡æ‰¾åˆ°ç›®æ ‡ï¼Œç‰¹å®šç©ºå†›å•ä½è¿›å…¥å·¡é€»æ¨¡å¼
            if (!this.target && this.stats.moveType === 'air' && (this.type === 'fighter_jet' || this.type === 'recon_drone')) {
                this.handleLoitering(deltaTime);
            }
        }
    }

    /**
     * å¤„ç†æ”»å‡»ç›®æ ‡çš„é€»è¾‘ã€‚
     * @param {Unit|Base} target - æ”»å‡»ç›®æ ‡ã€‚
     * @param {Game} game - æ¸¸æˆä¸»å¯¹è±¡ã€‚
     */
    handleAttack(target, game) {
        const targetPos = { x: target.pixelX || target.x, y: target.pixelY || target.y };
        const distanceToTarget = getDistance(this, targetPos);
        const engageRange = this.stats.range * 0.9; // è¿›å…¥æ­¤èŒƒå›´æ‰å¼€ç«ï¼Œé¿å…åœ¨æœ€å¤§å°„ç¨‹è¾¹ç¼˜åå¤æ¨ªè·³

        // å¦‚æœè·ç¦»å¤ªè¿œï¼Œåˆ™å‘ç›®æ ‡ç§»åŠ¨
        if (distanceToTarget > engageRange) {
            // åªæœ‰åœ¨æ²¡æœ‰ç§»åŠ¨è·¯å¾„æ—¶æ‰é‡æ–°å¯»è·¯ï¼Œé˜²æ­¢é¢‘ç¹è®¡ç®—
            if (!this.path.length && !this.moveTargetPos) {
                this.issueMoveCommand(targetPos, game.map, true);
            }
        } else {
            // è¿›å…¥å°„ç¨‹ï¼Œåœæ­¢ç§»åŠ¨
            this.path = [];
            this.moveTargetPos = null;
        }
        
        // è½¬å‘ç›®æ ‡
        this.setTargetAngle(targetPos);
        
        // åœ¨å°„ç¨‹å†…ä¸”å†·å´å®Œæ¯•ï¼Œåˆ™å¼€ç«
        if (distanceToTarget <= this.stats.range) {
            // æ£€æŸ¥æ˜¯å¦å·²å¯¹å‡†ç›®æ ‡
            let angleDiff = Math.abs(this.angle - this.targetAngle);
            if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
            
            if (this.attackCooldown <= 0 && !this.isSettingUp && angleDiff < 0.2) {
                this.attack(game);
            }
        }
    }
    
    /**
     * å¤„ç†ç§»åŠ¨é€»è¾‘ï¼ŒåŒ…æ‹¬è·¯å¾„å¹³æ»‘ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     * @param {GameMap} map - åœ°å›¾å¯¹è±¡ã€‚
     */
    handleMovement(deltaTime, map) {
        // å¦‚æœæœ‰è·¯å¾„ä½†æ²¡æœ‰å¹³æ»‘ç›®æ ‡ç‚¹ï¼Œåˆ™è®¡ç®—ä¸‹ä¸€ä¸ªå¹³æ»‘ç›®æ ‡ç‚¹
        if (this.path.length > 0 && !this.moveTargetPos) {
            this.findSmoothedPathTarget(map);
        }
        
        if (this.moveTargetPos) {
            this.setTargetAngle(this.moveTargetPos);
            const distanceToNode = getDistance(this, this.moveTargetPos);
            
            // åˆ°è¾¾è·¯å¾„èŠ‚ç‚¹
            if (distanceToNode < TILE_SIZE / 2) {
                this.moveTargetPos = null; 
                // åˆ°è¾¾æœ€ç»ˆç›®çš„åœ°
                if (this.currentPathIndex >= this.path.length -1) {
                    this.path = [];
                    // å¦‚æœæ˜¯ç‚®å…µï¼Œåˆ°è¾¾åéœ€è¦éƒ¨ç½²
                    if (this.stats.special === 'SETUP_TO_FIRE') {
                        this.isSettingUp = true;
                        this.setupTimer = 2.0;
                    }
                }
            } else {
                this.move(deltaTime);
            }
        }
    }

    /**
     * å¤„ç†ç©ºä¸­å•ä½çš„å·¡é€»ï¼ˆç»•åœˆï¼‰è¡Œä¸ºã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    handleLoitering(deltaTime) {
        if (!this.isLoitering) {
            this.isLoitering = true;
            this.loiterCenter = { x: this.x, y: this.y };
            this.loiterAngle = Math.atan2(this.y - this.loiterCenter.y, this.x - this.loiterCenter.x);
        }
        
        this.loiterAngle += 0.8 * deltaTime;
        
        const targetX = this.loiterCenter.x + Math.cos(this.loiterAngle) * this.loiterRadius;
        const targetY = this.loiterCenter.y + Math.sin(this.loiterAngle) * this.loiterRadius;
        
        this.setTargetAngle({x: targetX, y: targetY});
        this.move(deltaTime);
    }

    /**
     * æ ¹æ®å½“å‰æœå‘å’Œé€Ÿåº¦ç§»åŠ¨å•ä½ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    move(deltaTime) {
        const speed = this.stats.speed * deltaTime;
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;
    }

    /**
     * ä¸‹è¾¾ç§»åŠ¨å‘½ä»¤ï¼Œè®¡ç®—è·¯å¾„ã€‚
     * @param {{x: number, y: number}} targetPos - ç›®æ ‡åƒç´ åæ ‡ã€‚
     * @param {GameMap} map - åœ°å›¾å¯¹è±¡ã€‚
     * @param {boolean} [isEngaging=false] - è¿™æ¬¡ç§»åŠ¨æ˜¯å¦æ˜¯ä¸ºäº†æ”»å‡»ã€‚
     */
    issueMoveCommand(targetPos, map, isEngaging = false) {
        if (!isEngaging) this.target = null; // æ™®é€šç§»åŠ¨å‘½ä»¤ä¼šå–æ¶ˆæ”»å‡»ç›®æ ‡
        this.isLoitering = false;
        this.isSettingUp = false;
        this.moveTargetPos = null;
        
        const startGrid = { x: Math.floor(this.x / TILE_SIZE), y: Math.floor(this.y / TILE_SIZE) };
        const endGrid = { x: Math.floor(targetPos.x / TILE_SIZE), y: Math.floor(targetPos.y / TILE_SIZE) };
        const path = findPath(map, startGrid, endGrid, this.stats.moveType);
        
        if (path && path.length > 0) {
            this.path = path;
            this.currentPathIndex = 0;
        } else {
            this.path = [];
        }
    }

    /**
     * å¹³æ»‘åœ°æ›´æ–°å•ä½æœå‘ã€‚
     * @param {number} deltaTime - å¸§æ—¶é—´å·®ã€‚
     */
    updateRotation(deltaTime) {
        let diff = this.targetAngle - this.angle;
        // ç¡®ä¿é€‰æ‹©æœ€çŸ­è·¯å¾„æ—‹è½¬
        while (diff <= -Math.PI) diff += 2 * Math.PI;
        while (diff > Math.PI) diff -= 2 * Math.PI;
        
        const turnStep = this.rotationSpeed * deltaTime;
        if (Math.abs(diff) < turnStep) {
            this.angle = this.targetAngle;
        } else {
            this.angle += Math.sign(diff) * turnStep;
        }
        // å°†è§’åº¦æ ‡å‡†åŒ–åˆ° [0, 2*PI)
        this.angle = (this.angle + 2 * Math.PI) % (2 * Math.PI);
    }
    
    /**
     * è®¾ç½®å•ä½çš„ç›®æ ‡æœå‘è§’åº¦ã€‚
     * @param {{x: number, y: number}} targetPos - ç›®æ ‡ç‚¹åƒç´ åæ ‡ã€‚
     */
    setTargetAngle(targetPos) {
        this.targetAngle = Math.atan2(targetPos.y - this.y, targetPos.x - this.x);
    }

    /**
     * ç»˜åˆ¶å•ä½åŠå…¶UIå…ƒç´ ï¼ˆè¡€æ¡ã€é€‰æ‹©æ¡†ç­‰ï¼‰ã€‚
     * @param {CanvasRenderingContext2D} ctx - ç»˜å›¾ä¸Šä¸‹æ–‡ã€‚
     * @param {boolean} isSelected - å•ä½å½“å‰æ˜¯å¦è¢«é€‰ä¸­ã€‚
     * @param {number} [zoom=1] - å½“å‰é•œå¤´ç¼©æ”¾ã€‚
     * @param {boolean} [showDetails=false] - æ˜¯å¦æ˜¾ç¤ºé¢å¤–ä¿¡æ¯ï¼ˆå°„ç¨‹åœˆã€è·¯å¾„çº¿ï¼‰ã€‚
     */
    draw(ctx, isSelected, zoom = 1, showDetails = false) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI / 2); // å›¾åƒèµ„æºé€šå¸¸æ˜¯æœä¸Šçš„ï¼Œæ—‹è½¬90åº¦
        const size = TILE_SIZE * (this.stats.drawScale || 1.5); 
        
        if (this.image) {
            ctx.drawImage(this.image, -size / 2, -size / 2, size, size);
        }
        ctx.restore();

        // ç»˜åˆ¶é€‰ä¸­çŠ¶æ€å’Œè¯¦ç»†ä¿¡æ¯
        if (isSelected) {
            ctx.strokeStyle = this.owner === 'player' ? 'yellow' : 'orange';
            ctx.lineWidth = 2 / zoom;
            ctx.beginPath();
            ctx.arc(this.x, this.y, TILE_SIZE * this.stats.drawScale / 2, 0, Math.PI * 2);
            ctx.stroke();

            if (showDetails) {
                // ç»˜åˆ¶å°„ç¨‹åœˆ
                if (this.stats.range > 0) {
                    ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
                    ctx.lineWidth = 1 / zoom;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.range, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // ç»˜åˆ¶è·¯å¾„çº¿
                if (this.path && this.path.length > 0) {
                    const endNode = this.path[this.path.length - 1];
                    const destX = endNode.x * TILE_SIZE + TILE_SIZE / 2;
                    const destY = endNode.y * TILE_SIZE + TILE_SIZE / 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(destX, destY);
                    ctx.strokeStyle = this.target ? 'rgba(255, 50, 50, 0.7)' : 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([5 / zoom, 3 / zoom]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        // ç»˜åˆ¶è¡€æ¡
        const hpBarWidth = TILE_SIZE;
        const hpBarHeight = 5 / zoom;
        const hpBarYOffset = TILE_SIZE * 0.8;
        ctx.fillStyle = '#333';
        ctx.fillRect(this.x - hpBarWidth / 2, this.y - hpBarYOffset, hpBarWidth, hpBarHeight);
        ctx.fillStyle = this.owner === 'player' ? 'green' : '#c0392b';
        ctx.fillRect(this.x - hpBarWidth / 2, this.y - hpBarYOffset, hpBarWidth * (this.hp / this.stats.hp), hpBarHeight);
    }
    
    /**
     * æ ¸å¿ƒé‡æ„ (æ€§èƒ½ä¼˜åŒ–): ä½¿ç”¨ç©ºé—´ç½‘æ ¼è¿›è¡Œé«˜æ•ˆç´¢æ•Œã€‚
     * @param {Base} enemyBase - æ•Œæ–¹åŸºåœ°å¯¹è±¡ã€‚
     * @param {SpatialGrid} spatialGrid - ç©ºé—´ç½‘æ ¼ã€‚
     */
    findTarget(enemyBase, spatialGrid) {
        let closestTarget = null;
        let minDistance = this.stats.visionRange; // åªåœ¨è§†é‡èŒƒå›´å†…æœç´¢
        const validTargetTypes = this.stats.canTarget || ['ground', 'air', 'sea'];

        // 1. ä»ç©ºé—´ç½‘æ ¼è·å–è§†é‡èŒƒå›´å†…çš„æ‰€æœ‰æ½œåœ¨ç›®æ ‡
        const potentialTargets = spatialGrid.getNearbyWithRadius(this, minDistance);
        
        for (const target of potentialTargets) {
            if (target.owner === this.owner || target.hp <= 0) continue;
            
            // æ£€æŸ¥å•ä½ç±»å‹æ˜¯å¦å¯æ”»å‡»
            if (target instanceof Unit && !validTargetTypes.includes(target.stats.moveType)) continue;

            const distance = getDistance(this, target);
            if (distance < minDistance) {
                minDistance = distance;
                closestTarget = target;
            }
        }

        // 2. å¦‚æœæ²¡æœ‰æ‰¾åˆ°å•ä½ï¼Œå†æ£€æŸ¥åŸºåœ°
        if (!closestTarget && enemyBase && enemyBase.hp > 0 && validTargetTypes.includes('ground')) {
            const distanceToBase = getDistance(this, {x: enemyBase.pixelX, y: enemyBase.pixelY});
            if (distanceToBase < minDistance) {
                closestTarget = enemyBase;
            }
        }
        
        this.target = closestTarget;
    }
    
    /**
     * æ‰§è¡Œæ”»å‡»ï¼Œåˆ›å»ºä¸€ä¸ªå¼¹é“å¯¹è±¡ã€‚
     * @param {Game} game - æ¸¸æˆä¸»å¯¹è±¡ã€‚
     */
    attack(game) {
        if (!this.target || !this.stats.ammoType) return;
        
        const pStats = {
            damage: this.stats.attack,
            ammoType: this.stats.ammoType,
            ammoSpeed: this.stats.ammoSpeed,
            splashRadius: this.stats.ammoSplashRadius,
        };
        const projectile = new Projectile(this.owner, { x: this.x, y: this.y }, this.target, pStats);
        game.projectiles.push(projectile);
        
        this.attackCooldown = this.stats.attackSpeed;
    }

    /**
     * å•ä½æ‰¿å—ä¼¤å®³ã€‚
     * @param {number} amount - ä¼¤å®³å€¼ã€‚
     */
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) this.hp = 0;
    }

    /**
     * è·¯å¾„å¹³æ»‘å¤„ç†ï¼šä»è·¯å¾„çš„æœ«ç«¯å‘å‰æŸ¥æ‰¾ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸å½“å‰ä½ç½®æ— éšœç¢çš„èŠ‚ç‚¹ä½œä¸ºä¸‹ä¸€ä¸ªç›®æ ‡ç‚¹ã€‚
     * è¿™å¯ä»¥é¿å…å•ä½ä¸¥æ ¼æŒ‰ç…§æ ¼å­ä¸­å¿ƒç‚¹ç§»åŠ¨ï¼Œä½¿ç§»åŠ¨è½¨è¿¹æ›´è‡ªç„¶ã€‚
     * @param {GameMap} map - åœ°å›¾å¯¹è±¡ã€‚
     */
    findSmoothedPathTarget(map) {
        if (!this.path || this.path.length === 0 || this.currentPathIndex >= this.path.length) return;
        
        // ä»è·¯å¾„ç»ˆç‚¹å‘å‰æœç´¢
        for (let i = this.path.length - 1; i > this.currentPathIndex; i--) {
            const node = this.path[i];
            const targetPos = { x: node.x * TILE_SIZE + TILE_SIZE / 2, y: node.y * TILE_SIZE + TILE_SIZE / 2 };
            if (isLineOfSightClear(this, targetPos, map, this.stats.moveType)) {
                this.moveTargetPos = targetPos;
                this.currentPathIndex = i;
                return;
            }
        }
        
        // å¦‚æœæ— æ³•æ‹‰ç›´è·¯å¾„ï¼Œåˆ™ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        const nextNode = this.path[this.currentPathIndex];
        if (nextNode) {
            this.moveTargetPos = { x: nextNode.x * TILE_SIZE + TILE_SIZE / 2, y: nextNode.y * TILE_SIZE + TILE_SIZE / 2 };
        }
    }
}
```

---

### `utils.js`
```javascript
// js/utils.js

/**
 * @file å­˜æ”¾é€šç”¨çš„è¾…åŠ©å‡½æ•°ã€‚
 */

/**
 * è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚
 * @param {{x: number, y: number}} p1 - ç¬¬ä¸€ä¸ªç‚¹ã€‚
 * @param {{x: number, y: number}} p2 - ç¬¬äºŒä¸ªç‚¹ã€‚
 * @returns {number} - ä¸¤ç‚¹é—´çš„è·ç¦»ã€‚
 */
export function getDistance(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
}
```